<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lyl&#39;blog</title>
  
  
  <link href="https://sunrisel135.github.io/blog_lyl/atom.xml" rel="self"/>
  
  <link href="https://sunrisel135.github.io/blog_lyl/"/>
  <updated>2024-03-10T01:43:38.106Z</updated>
  <id>https://sunrisel135.github.io/blog_lyl/</id>
  
  <author>
    <name>lyl_L-</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java面试-IO</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/10/Java%E9%9D%A2%E8%AF%95-IO/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/10/Java%E9%9D%A2%E8%AF%95-IO/</id>
    <published>2024-03-10T01:42:29.000Z</published>
    <updated>2024-03-10T01:43:38.106Z</updated>
    
    <content type="html"><![CDATA[<p>持续补充！</p><span id="more"></span><h3 id="【Java-IO基础】"><a href="#【Java-IO基础】" class="headerlink" title="【Java IO基础】"></a>【Java IO基础】</h3><h4 id="–-IO流"><a href="#–-IO流" class="headerlink" title="– IO流"></a>– IO流</h4><p>即 <code>Input/Output</code>，输入和输出。</p><ul><li>输入-数据输入到计算机内存的过程。</li><li>输出-输出到外部存储（比如数据库，文件，远程主机）的过程。</li></ul><p>可分为：</p><ul><li>输入流和输出流 </li><li>字节流和字符流 (根据数据的处理方式)</li></ul><p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li><code>InputStream</code> (字节输入流) &#x2F; <code>Reader</code> (字符输入流) : 所有输入流的基类</li><li><code>OutputStream</code> (字节输出流) &#x2F; <code>Writer</code> (字符输出流) : 所有输出流的基类。</li></ul><h4 id="–-字节流"><a href="#–-字节流" class="headerlink" title="– 字节流"></a>– 字节流</h4><h5 id="InputStream（字节输入流）"><a href="#InputStream（字节输入流）" class="headerlink" title="InputStream（字节输入流）"></a>InputStream（字节输入流）</h5><ol><li><p><code>InputStream</code>用于从源头 (通常是文件) 读取数据 (字节信息) 到内存中，<code>java.io.InputStream</code>抽象类是所有字节输入流的父类。</p></li><li><p><code>FileInputStream</code> 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。</p><p>不过，一般我们是不会直接单独使用 FileInputStream ，通常会配合 <code>BufferedInputStream</code>（字节缓冲输入流）来使用。</p></li><li><p><code>DataInputStream</code> 用于读取指定类型数据，不能单独使用，必须结合其它流，比如 <code>FileInputStream</code> 。</p></li><li><p><code>ObjectInputStream</code> 用于从输入流中读取 Java 对象（<strong>反序列化</strong>），<code>ObjectOutputStream</code> 用于将对象写入到输出流(<strong>序列化</strong>)。</p><p>用于序列化和反序列化的类必须实现 <code>Serializable</code> 接口，对象中如果有属性不想被序列化，使用 <code>transient</code> 修饰。</p></li></ol><h5 id="OutputStream（字节输出流）"><a href="#OutputStream（字节输出流）" class="headerlink" title="OutputStream（字节输出流）"></a>OutputStream（字节输出流）</h5><ol><li><code>OutputStream</code>用于将数据 (字节信息) 写入到目的地 (通常是文件)，<code>java.io.OutputStream</code>抽象类是所有字节输出流的父类。</li><li><code>FileOutputStream</code> 是最常用的字节输出流对象，可直接指定文件路径，可以直接输出单字节数据，也可以输出指定的字节数组。</li><li><code>DataOutputStream</code> 用于写入指定类型数据，不能单独使用，必须结合其它流，比如 <code>FileOutputStream</code> 。</li><li><code>ObjectOutputStream</code>，将对象写入到输出流(序列化)。</li></ol><h4 id="–-字符流"><a href="#–-字符流" class="headerlink" title="– 字符流"></a>– 字符流</h4><ul><li>不管是文件读写还是网络发送接收，信息的<strong>最小存储单元</strong>都是<strong>字节</strong>。</li></ul><h5 id="那为什么-I-O-流操作要分为字节流操作和字符流操作呢？"><a href="#那为什么-I-O-流操作要分为字节流操作和字符流操作呢？" class="headerlink" title="那为什么 I&#x2F;O 流操作要分为字节流操作和字符流操作呢？"></a>那为什么 I&#x2F;O 流操作要分为字节流操作和字符流操作呢？</h5><ul><li>字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时。</li><li>使用字节流时，如果我们<strong>不知道编码类型</strong>就<strong>很容易出现乱码问题</strong>。（中文）</li><li>因此，I&#x2F;O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。</li><li>如果<strong>音频文件、图片</strong>等<strong>媒体文件</strong>用<strong>字节流</strong>比较好，如果涉及到<strong>字符</strong>的话使用<strong>字符流</strong>比较好。</li></ul><h5 id="Reader（字符输入流）"><a href="#Reader（字符输入流）" class="headerlink" title="Reader（字符输入流）"></a>Reader（字符输入流）</h5><ol><li><p><code>Reader</code>用于从源头（通常是文件）读取数据（字符信息）到内存中，<code>java.io.Reader</code>抽象类是所有字符输入流的父类。</p><p><code>Reader</code> 用于读取文本， <code>InputStream</code> 用于读取原始字节。</p></li><li><p><strong>InputStreamReader</strong> 是字节流转换为字符流的<strong>桥梁</strong>，其<strong>子类</strong> <code>FileReader</code> 是基于该基础上的封装，可以直接操作字符文件。</p></li></ol><h5 id="Writer（字符输出流）"><a href="#Writer（字符输出流）" class="headerlink" title="Writer（字符输出流）"></a>Writer（字符输出流）</h5><ol><li><code>Writer</code>用于将数据（字符信息）写入到目的地（通常是文件），<code>java.io.Writer</code>抽象类是所有字符输出流的父类。</li><li><code>OutputStreamWriter</code> 是字符流转换为字节流的桥梁，其子类 <code>FileWriter</code> 是基于该基础上的封装，可以直接将字符写入到文件。</li></ol><h4 id="–-缓冲流"><a href="#–-缓冲流" class="headerlink" title="– 缓冲流"></a>– 缓冲流</h4><ul><li>IO 操作是很消耗<strong>性能</strong>的，缓冲流将数据加载至缓冲区，<strong>一次性读取&#x2F;写入多个字节</strong>，从而避免频繁的 IO 操作，提高流的<strong>传输效率</strong>。</li><li>字节缓冲流这里采用了<strong>装饰器模式</strong>来<strong>增强 <code>InputStream</code> 和<code>OutputStream</code>子类对象</strong>的功能。</li><li>字节流和字节缓冲流的性能差别主要体现在我们使用两者的时候都是调用 write(int b) 和 read() 这两个一次只读取一个字节的方法的时候。由于字节缓冲流内部有缓冲区（字节数组），因此，字节缓冲流会先将读取到的字节存放在缓存区，大幅减少 IO 次数，提高读取效率。</li></ul><h5 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h5><ol><li><p><strong>BufferedInputStream（字节缓冲输入流）</strong></p><ul><li><p><code>BufferedInputStream</code> 从源头（通常是文件）读取数据（字节信息）到内存的过程中不会一个字节一个字节的读取，而是会<strong>先将读取到的字节存放在缓存区，并从内部缓冲区中单独读取字节</strong>。这样大幅减少了 IO 次数，提高了读取效率。</p></li><li><p><code>BufferedInputStream</code> 内部维护了一个<strong>缓冲区</strong>，这个缓冲区实际就是一个<strong>字节数组</strong>。</p></li></ul></li><li><p><strong>BufferedOutputStream（字节缓冲输出流）</strong></p><ul><li><code>BufferedOutputStream</code> 将数据（字节信息）写入到目的地（通常是文件）的过程中不会一个字节一个字节的写入，而是会先将要写入的字节存放在缓存区，并从内部缓冲区中单独写入字节。这样大幅减少了 IO 次数，提高了读取效率</li></ul></li></ol><h5 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h5><p><code>BufferedReader</code> （<strong>字符缓冲输入流</strong>）和 <code>BufferedWriter</code>（<strong>字符缓冲输出流</strong>）类似于 <code>BufferedInputStream</code>（字节缓冲输入流）和<code>BufferedOutputStream</code>（字节缓冲输入流），内部都维护了一个字节数组作为缓冲区。不过，前者主要是用来操作字符信息。</p><h4 id="–-打印流"><a href="#–-打印流" class="headerlink" title="– 打印流"></a>– 打印流</h4><ul><li><code>System.out</code> 实际是用于获取一个 PrintStream 对象，print方法实际调用的是 PrintStream 对象的 write 方法。</li><li><code>PrintStream</code> 属于<strong>字节打印流</strong>，与之对应的是 <code>PrintWriter</code> （<strong>字符打印流</strong>）。PrintStream 是 OutputStream 的子类，PrintWriter 是 Writer 的子类。</li></ul><h4 id="–-随机访问流"><a href="#–-随机访问流" class="headerlink" title="– 随机访问流"></a>– 随机访问流</h4><ul><li>支持<strong>随意跳转到文件的任意位置进行读写</strong>的 <code>RandomAccessFile</code> 。</li><li><code>RandomAccessFile</code> 比较常见的一个应用就是实现大文件的 <strong>断点续传</strong> 。</li><li><strong>断点续传？</strong>简单来说就是上传文件中途暂停或失败（比如遇到网络问题）之后，不需要重新上传，只需要上传那些未成功上传的文件分片即可。<strong>分片</strong>（先将文件切分成多个文件分片）<strong>上传</strong>是断点续传的基础。</li></ul><h3 id="【Java-IO-设计模式】"><a href="#【Java-IO-设计模式】" class="headerlink" title="【Java IO 设计模式】"></a>【Java IO 设计模式】</h3><h4 id="–-装饰器模式"><a href="#–-装饰器模式" class="headerlink" title="– 装饰器模式"></a>– 装饰器模式</h4><p>详解：<a href="https://zhuanlan.zhihu.com/p/444298983">https://zhuanlan.zhihu.com/p/444298983</a></p><ul><li>装饰器（Decorator）模式 指<strong>在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的</strong>模式，它属于对象结构型模式。</li><li>装饰器模式<strong>通过组合替代继承来扩展原始类的功能</strong>，在一些继承关系比较复杂的场景（IO 这一场景各种类的继承关系就比较复杂）更加实用。</li><li>例如，<code>InputStream</code> 的子类 <code>FilterInputStream</code>，<code>Reader</code> 的子类 <code>BufferedReader</code> 以及 <code>FilterReader</code>，还有 <code>Writer</code> 的子类 <code>BufferedWriter、FilterWriter</code> 以及 <code>PrintWriter</code> 等，它们都是抽象装饰类。</li></ul><ol><li>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</li><li>具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。</li><li>抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li><li>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li><li>代码</li></ol><h4 id="–-适配器模式"><a href="#–-适配器模式" class="headerlink" title="– 适配器模式"></a>– 适配器模式</h4><p>详解：<a href="https://segmentfault.com/a/1190000040524953">java - 一文彻底弄懂适配器模式(Adapter Pattern) - 个人文章 - SegmentFault 思否</a></p><ul><li>适配器（Adapter Pattern）模式 是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。</li><li>适配器模式中存在被适配的对象或者类称为 <strong>适配者(Adaptee)</strong> ，作用于适配者的对象或者类称为<strong>适配器(Adapter)</strong> 。适配器分为<strong>对象适配器</strong>和<strong>类适配器</strong>。类适配器使用<strong>继承关系</strong>来实现，对象适配器使用<strong>组合关系</strong>来实现。</li><li>IO 流中的<strong>字符流和字节流</strong>的接口不同，它们<strong>之间</strong>可以<strong>协调工作</strong>就是基于适配器模式来做的，更准确点来说是对象适配器。通过适配器，我们可以将字节流对象适配成一个字符流对象。</li><li><strong><code>InputStreamReader</code></strong> 和 <strong><code>OutputStreamWriter</code></strong> 就是两个适配器(Adapter)， 同时，它们两个也是字节流和字符流之间的桥梁。</li><li>代码</li></ul><h4 id="–-适配器模式和装饰器模式有什么区别呢？"><a href="#–-适配器模式和装饰器模式有什么区别呢？" class="headerlink" title="– 适配器模式和装饰器模式有什么区别呢？"></a>– 适配器模式和装饰器模式有什么区别呢？</h4><ul><li><strong>装饰器模式</strong> 更侧重于动态地增强原始类的功能，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。并且，装饰器模式支持对原始类嵌套使用多个装饰器。</li><li><strong>适配器模式</strong> 更侧重于让接口不兼容而不能交互的类可以一起工作，当我们调用适配器对应的方法时，适配器内部会调用适配者类或者和适配类相关的类的方法，这个过程透明的。</li></ul><h4 id="–-工厂模式"><a href="#–-工厂模式" class="headerlink" title="– 工厂模式"></a>– 工厂模式</h4><p>详解：<a href="https://blog.csdn.net/qq_42804736/article/details/115168313">java工厂模式：简单工厂、工厂方法、抽象工厂（通俗易懂）_java 抽象工厂模式-CSDN博客</a></p><p>工厂模式用于<strong>创建对象</strong>，NIO 中大量用到了工厂模式，</p><ol><li>比如 <code>Files</code> 类的 <code>newInputStream</code> 方法用于创建 <code>InputStream</code> 对象（<strong>静态工厂</strong>）</li><li>Paths 类的 get 方法创建 Path 对象（静态工厂）</li><li>ZipFileSystem 类（sun.nio包下的类，属于 java.nio 相关的一些内部实现）的 getPath 的方法创建 Path 对象（<strong>简单工厂</strong>）</li></ol><h4 id="–-观察者模式"><a href="#–-观察者模式" class="headerlink" title="– 观察者模式"></a>– 观察者模式</h4><p>详解：<a href="https://segmentfault.com/a/1190000040530952">java - 一文彻底搞懂观察者模式(Observer Pattern) - 个人文章 - SegmentFault 思否</a></p><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><p>NIO 中的文件目录监听服务使用到了观察者模式。</p><ul><li>NIO 中的文件目录监听服务基于 WatchService 接口和 Watchable 接口。WatchService 属于观察者，Watchable 属于被观察者。</li><li>Watchable 接口定义了一个用于将对象注册到 WatchService（监控服务） 并绑定监听事件的方法 register 。</li></ul><h3 id="【Java-IO-模型】"><a href="#【Java-IO-模型】" class="headerlink" title="【Java IO 模型】"></a>【Java IO 模型】</h3><p><a href="https://www.javabetter.cn/sidebar/sanfene/javase.html#_44-bio">https://www.javabetter.cn/sidebar/sanfene/javase.html#_44-bio</a></p><p>三种IO</p><ul><li><p><strong>BIO(blocking I&#x2F;O)</strong> ： 就是传统的 IO，<strong>同步阻塞</strong>，服务器实现模式为一个连接一个线程，即<strong>客户端有连接请求时服务器端就需要启动一个线程进行处理</strong>，如果这个连接不做任何事情会造成不必要的线程开销，可以通过连接池机制改善(实现多个客户连接服务器)。</p><p>BIO 方式适用于<strong>连接数目比较小且固定的架构</strong>，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，程序简单易理解。</p></li><li><p><strong>NIO</strong> ：全称 java non-blocking IO，是指 JDK 提供的新 API。从 JDK1.4 开始，Java 提供了一系列改进的输入&#x2F;输出的新特性，被统称为 NIO(即 New IO)。</p><p>NIO 是<strong>同步非阻塞</strong>的，服务器端<strong>用一个线程处理多个连接</strong>，客户端发送的<strong>连接请求会注册到多路复用器上</strong>，<strong>多路复用器轮询到连接有 IO 请求就进行处理</strong>。</p><p>NIO 的数据是面向<strong>缓冲区 Buffer</strong>的，必须从 Buffer 中读取或写入。</p></li><li><p><strong>AIO</strong>：JDK 7 引入了 Asynchronous I&#x2F;O，是<strong>异步不阻塞</strong>的 IO。在进行 I&#x2F;O 编程中，常用到两种模式：Reactor 和 Proactor。Java 的 NIO 就是 Reactor，<strong>当有事件触发时，服务器端得到通知，进行相应的处理，完成后才通知服务端程序启动线程去处理</strong>，一般适用于<strong>连接数较多且连接时间较长</strong>的应用。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;持续补充！&lt;/p&gt;</summary>
    
    
    
    <category term="Java IO" scheme="https://sunrisel135.github.io/blog_lyl/categories/Java-IO/"/>
    
    
    <category term="面试" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java面试-集合</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/10/Java%E9%9D%A2%E8%AF%95-%E9%9B%86%E5%90%88/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/10/Java%E9%9D%A2%E8%AF%95-%E9%9B%86%E5%90%88/</id>
    <published>2024-03-10T01:40:11.000Z</published>
    <updated>2024-03-10T03:08:07.646Z</updated>
    
    <content type="html"><![CDATA[<p>Java集合框架总结…</p><span id="more"></span><h3 id="【集合概述】"><a href="#【集合概述】" class="headerlink" title="【集合概述】"></a>【集合概述】</h3><h4 id="–-Java集合"><a href="#–-Java集合" class="headerlink" title="– Java集合"></a>– Java集合</h4><p>Java 集合， 也叫作容器，主要是由两大接口派生而来：</p><ol><li><code>Collection</code>接口，主要用于存放<strong>单一元素</strong>；</li><li><code>Map</code> 接口，主要用于存放<strong>键值对</strong>。</li></ol><h4 id="–-说说-List-Set-Queue-Map-四者的区别？"><a href="#–-说说-List-Set-Queue-Map-四者的区别？" class="headerlink" title="– 说说 List, Set, Queue, Map 四者的区别？"></a>– 说说 List, Set, Queue, Map 四者的区别？</h4><ul><li><code>List</code>(<em>对付顺序的好帮手</em>): 存储的元素是<strong>有序的</strong>、<strong>可重复</strong>的。</li><li><code>Set</code>(<em>注重独一无二的性质</em>): 存储的元素<strong>不可重复</strong>的。</li><li><code>Queue</code>(<em>实现排队功能的叫号机</em>): 按特定的<strong>排队</strong>规则来确定先后顺序，存储的元素是<strong>有序</strong>的、<strong>可重复</strong>的。</li><li><code>Map</code>(<em>用 key 来搜索的专家</em>): 使用<strong>键值对（key-value）</strong>存储，<strong>key 是无序的、不可重复的</strong>，<strong>value 是无序的、可重复的</strong>，<strong>每个键最多映射到一个值</strong>。</li></ul><h4 id="–-集合框架底层数据结构总结"><a href="#–-集合框架底层数据结构总结" class="headerlink" title="– 集合框架底层数据结构总结"></a>– 集合框架底层数据结构总结</h4><ul><li><strong>Collection</strong><ul><li><code>List</code><ul><li><code>ArrayList</code>：**<code>Object[]</code> 数组**。详细可以查看：<a href="">ArrayList 源码分析</a>。</li><li><code>Vector</code>：<code>Object[]</code> 数组。</li><li><code>LinkedList</code>：<strong>双向链表</strong> (JDK1.6 之前为循环链表，JDK1.7 取消了循环)。详细可以查看：<a href="">LinkedList 源码分析</a>。</li></ul></li><li><code>Set</code><ul><li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 HashMap 来保存元素。</li><li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 LinkedHashMap 来实现的。</li><li><code>TreeSet</code>(有序，唯一): <strong>红黑树</strong>(自平衡的排序二叉树)</li></ul></li><li><strong>Queue</strong><ul><li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现小顶堆。详细可以查看：<a href="">PriorityQueue 源码分析</a>。</li><li><code>DelayQueue</code>:<code>PriorityQueue</code>。详细可以查看：<a href="">DelayQueue 源码分析</a>。</li><li><code>ArrayDeque</code>: 可扩容动态双向数组。</li></ul></li></ul></li><li><strong>Map</strong><ul><li><code>HashMap</code>：<strong>JDK1.8 之前</strong> <code>HashMap</code> 由<strong>数组+链表</strong>组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。<strong>JDK1.8 以后</strong>在解决哈希冲突时有了较大的变化，<strong>当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树</strong>，以减少搜索时间。详细可以查看：<a href="">HashMap 源码分析</a>。</li><li><code>LinkedHashMap</code>：<code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于<strong>拉链式散列结构即由数组和链表或红黑树组成</strong>。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条<strong>双向链表</strong>，使得上面的结构可以保持键值对的插入顺序。</li><li><code>Hashtable</code>：<strong>数组+链表</strong>组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的。</li><li><code>TreeMap</code>：红黑树（自平衡的排序二叉树）。</li></ul></li></ul><h4 id="–-如何选用集合"><a href="#–-如何选用集合" class="headerlink" title="– 如何选用集合?"></a>– 如何选用集合?</h4><ul><li>根据<strong>键值</strong>获取到元素值时就选用 <code>Map</code> 接口下的集合<ul><li>需要<strong>排序</strong>时选择 <code>TreeMap</code></li><li>不需要排序时就选择 <code>HashMap</code></li><li>需要保证<strong>线程安全</strong>就选用 <code>ConcurrentHashMap</code></li></ul></li><li>只需要存放<strong>元素值</strong>时，就选择实现<code>Collection</code> 接口的集合，<ul><li>需要<strong>保证元素唯一</strong>时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code>，</li><li>不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code>，然后再根据实现这些接口的集合的特点来选用。</li></ul></li></ul><h4 id="–-为什么要使用集合？"><a href="#–-为什么要使用集合？" class="headerlink" title="– 为什么要使用集合？"></a>– 为什么要使用集合？</h4><ul><li>数组：存储一组类型相同的数据</li><li>集合：存储的数据类型多种多样且数量不确定</li><li>Java 集合提高了数据的存储和处理灵活性，可以更好地适应现代软件开发中多样化的数据需求，并支持高质量的代码编写</li></ul><h4 id="【List】"><a href="#【List】" class="headerlink" title="【List】"></a>【List】</h4><h4 id="–-ArrayList-和-Array（数组）的区别？"><a href="#–-ArrayList-和-Array（数组）的区别？" class="headerlink" title="– ArrayList 和 Array（数组）的区别？"></a>– ArrayList 和 Array（数组）的区别？</h4><p><code>ArrayList</code> 动态数组，比 Array（静态数组） 使用起来更加灵活：</p><ul><li><code>ArrayList</code>会<strong>动态地扩容或缩容</strong>，而 <code>Array</code> 创建后就无法改变长度。</li><li><code>ArrayList</code> 可使用<strong>泛型</strong>来确保类型安全，<code>Array</code> 则不行。</li><li><code>ArrayList</code> 中<strong>只能存储对象</strong>。对于基本类型数据，需要使用其对应的<strong>包装类</strong>（如 Integer、Double 等）。<code>Array</code> 则是都可以存储。</li><li><code>ArrayList</code> 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度的数组，<strong>只能按照下标访问其中的元素，不具备动态添加、删除元素的能力</strong>。</li><li><code>ArrayList</code><strong>创建时不需要指定大小</strong>，而<code>Array</code>创建时<strong>必须指定大小</strong>。</li></ul><h4 id="–-ArrayList-和-Vector-的区别-（了解即可）"><a href="#–-ArrayList-和-Vector-的区别-（了解即可）" class="headerlink" title="– ArrayList 和 Vector 的区别?（了解即可）"></a>– ArrayList 和 Vector 的区别?（了解即可）</h4><ul><li><code>ArrayList</code> 是 List 的主要实现类，底层使用 Object[]存储，适用于频繁的查找工作，线程不安全 </li><li><code>Vector</code> 是 List 的古老实现类，底层使用Object[] 存储，<strong>线程安全</strong></li></ul><h4 id="–-Vector-和-Stack-的区别-（了解即可）"><a href="#–-Vector-和-Stack-的区别-（了解即可）" class="headerlink" title="– Vector 和 Stack 的区别?（了解即可）"></a>– Vector 和 Stack 的区别?（了解即可）</h4><ul><li><code>Vector</code> 和 Stack 两者都是线程安全的，都是使用 synchronized 关键字进行同步处理。</li><li><code>Stack</code> 继承自 Vector，是一个后进先出的栈，而 Vector 是一个列表。</li></ul><p>随着 Java 并发编程的发展，Vector 和 Stack 已经被淘汰，推荐使用并发集合类（例如 <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code> 等）或者手动实现线程安全的方法来提供安全的多线程操作支持。</p><h4 id="–-ArrayList-可以添加-null-值吗？"><a href="#–-ArrayList-可以添加-null-值吗？" class="headerlink" title="– ArrayList 可以添加 null 值吗？"></a>– ArrayList 可以添加 null 值吗？</h4><p><code>ArrayList</code> 中可以<strong>存储任何类型的对象</strong>，包括 null 值。</p><p>不建议向ArrayList 中添加 null 值， null 值无意义，会让代码难以维护比如忘记做判空处理就会导致空指针异常。</p><h4 id="–-ArrayList-插入和删除元素的时间复杂度？"><a href="#–-ArrayList-插入和删除元素的时间复杂度？" class="headerlink" title="– ArrayList 插入和删除元素的时间复杂度？"></a>– ArrayList 插入和删除元素的时间复杂度？</h4><p><strong>对于插入：</strong></p><ul><li><p><strong>头插：</strong>需将所有元素依次向后移一个位置，所以<strong>O(n)</strong></p></li><li><p><strong>尾插</strong>：<code>ArrayList</code> 的容量未达到极限时，**O(1)**，只需在数组末尾添加元素；</p><p>容量已达到极限需要扩容时，需要执行一次 <strong>O(n)</strong> 的操作将原数组复制到新的更大的数组中，然后<strong>再</strong>执行 <strong>O(1)</strong> 的操作添加元素。</p></li><li><p><strong>指定位置插入：</strong>目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n&#x2F;2 个元素，因此时间复杂度为 **O(n)**。</p></li></ul><p><strong>对于删除：</strong></p><ul><li>头部删除：需将所有元素依次向前移动一个位置，**O(n)**。</li><li>尾部删除：**O(1)**。</li><li>指定位置删除：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 **O(n)**。</li></ul><h4 id="–-LinkedList-插入和删除元素的时间复杂度？"><a href="#–-LinkedList-插入和删除元素的时间复杂度？" class="headerlink" title="– LinkedList 插入和删除元素的时间复杂度？"></a>– LinkedList 插入和删除元素的时间复杂度？</h4><ul><li>头部插入&#x2F;删除：只需修改头结点的指针即可，时间复杂度为 **O(1)**。</li><li>尾部插入&#x2F;删除：只需修改尾结点的指针即可，时间复杂度为 **O(1)**。</li><li>指定位置插入&#x2F;删除：需<strong>先移动</strong>到指定位置，<strong>再修改</strong>指定节点的指针完成插入&#x2F;删除，因此需移动平均 n&#x2F;2 个元素，时间复杂度为 **O(n)**。</li></ul><h4 id="–-RandomAccess-接口？LinkedList-为什么不能实现-RandomAccess-接口？"><a href="#–-RandomAccess-接口？LinkedList-为什么不能实现-RandomAccess-接口？" class="headerlink" title="– RandomAccess 接口？LinkedList 为什么不能实现 RandomAccess 接口？"></a>– RandomAccess 接口？LinkedList 为什么不能实现 RandomAccess 接口？</h4><p>★<code>RandomAccess</code> 是一个<strong>标记接口</strong>，用来<strong>表明实现该接口的类支持随机访问（即可以通过索引快速访问元素）</strong>。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</p><p>在 <code>binarySearch（)</code> 方法中，它要判断传入的 list 是否 <code>RandomAccess</code> 的实例，如果是，调用<code>indexedBinarySearch()</code>方法，如果不是，那么调用<code>iteratorBinarySearch()</code>方法</p><p><code>LinkedList</code> 底层数据结构是链表，内存地址不连续，<strong>只能通过指针来定位</strong>，<strong>不支持随机快速访问</strong>，所以不能实现 <code>RandomAccess</code> 接口。</p><h4 id="–-ArrayList-与-LinkedList-区别"><a href="#–-ArrayList-与-LinkedList-区别" class="headerlink" title="– ArrayList 与 LinkedList 区别?"></a>– ArrayList 与 LinkedList 区别?</h4><ul><li><p><strong>是否保证线程安全</strong>：<code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也<strong>就</strong>是<strong>不保证线程安全</strong>；</p></li><li><p><strong>底层数据结构</strong>：<code>ArrayList</code> 底层使用的是 <code>Object</code> <strong>数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。）</p></li><li><p><strong>插入和删除是否受元素位置的影响：</strong></p><p><code>ArrayList</code> 采用<strong>数组存储</strong>，插入和删除元素的时间复杂度受元素位置的影响；</p><p><code>add(E e)</code>方法， <code>ArrayList</code> 会默认追加到列表的末尾。</p><p><code>LinkedList</code> 采用<strong>链表存储</strong>，在<strong>头尾插入或者删除元素</strong>不受元素位置的影响<code>LinkedList</code> 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响。<strong>指定位置</strong>需要先移动到指定位置再插入和删除。</p></li><li><p><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code>（实现了 <code>RandomAccess</code> 接口） 支持。</p></li><li><p><strong>内存空间占用：</strong> <code>ArrayList</code> 的空间浪费主要体现在在 list 列表的结尾会<strong>预留</strong>一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p></li></ul><h4 id="–-双向链表和双向循环链表"><a href="#–-双向链表和双向循环链表" class="headerlink" title="– 双向链表和双向循环链表"></a>– 双向链表和双向循环链表</h4><ul><li><strong>双向链表：</strong> 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。</li><li><strong>双向循环链表：</strong> 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。</li></ul><h4 id="–-说一说-ArrayList-的扩容机制吧"><a href="#–-说一说-ArrayList-的扩容机制吧" class="headerlink" title="– 说一说 ArrayList 的扩容机制吧"></a>– 说一说 ArrayList 的扩容机制吧</h4><h3 id="【Set】"><a href="#【Set】" class="headerlink" title="【Set】"></a>【Set】</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java集合框架总结…&lt;/p&gt;</summary>
    
    
    
    <category term="Java集合" scheme="https://sunrisel135.github.io/blog_lyl/categories/Java%E9%9B%86%E5%90%88/"/>
    
    
    <category term="面试" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java面试-并发编程</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/08/Java%E9%9D%A2%E8%AF%95-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/08/Java%E9%9D%A2%E8%AF%95-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</id>
    <published>2024-03-08T05:45:56.000Z</published>
    <updated>2024-03-08T07:51:13.415Z</updated>
    
    <content type="html"><![CDATA[<p>常看常新，持续更新…</p><span id="more"></span><h3 id="【线程】"><a href="#【线程】" class="headerlink" title="【线程】"></a>【线程】</h3><h4 id="–-什么是线程和进程"><a href="#–-什么是线程和进程" class="headerlink" title="– 什么是线程和进程?"></a>– 什么是线程和进程?</h4><h5 id="进程？"><a href="#进程？" class="headerlink" title="进程？"></a>进程？</h5><ul><li><strong>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。</strong></li><li>系统运行一个程序即是一个进程从创建，运行到消亡的过程。</li><li>Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</li></ul><h5 id="线程"><a href="#线程" class="headerlink" title="线程?"></a>线程?</h5><ul><li><strong>与进程相似，线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。</strong></li><li>与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</li></ul><h5 id="用户线程、内核线程？"><a href="#用户线程、内核线程？" class="headerlink" title="用户线程、内核线程？"></a>用户线程、内核线程？</h5><ul><li>用户线程 (jdk1.2前)：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）。<br>内核线程 (jdk1.2及以后)：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）。</li><li>现在的 Java 线程的本质其实就是操作系统的线程。</li></ul><h4 id="–-线程与进程的关系-区别及优缺点？"><a href="#–-线程与进程的关系-区别及优缺点？" class="headerlink" title="– 线程与进程的关系,区别及优缺点？"></a>– 线程与进程的关系,区别及优缺点？</h4><p>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p><h4 id="–-并发与并行的区别"><a href="#–-并发与并行的区别" class="headerlink" title="– 并发与并行的区别"></a>– 并发与并行的区别</h4><ul><li><strong>并发</strong>：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li><li><strong>并行</strong>：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li></ul><p>最关键的点是：是否是 <strong>同时</strong> 执行。</p><h4 id="–-同步和异步的区别"><a href="#–-同步和异步的区别" class="headerlink" title="– 同步和异步的区别"></a>– 同步和异步的区别</h4><ul><li>同步：发出一个调用之后，在<strong>没有得到结果之前</strong>， 该调用就不可以返回，<strong>一直等待</strong>。</li><li>异步：调用在发出之后，<strong>不用等待返回结果</strong>，该调用直接返回。</li></ul><h4 id="–-为什么要使用多线程"><a href="#–-为什么要使用多线程" class="headerlink" title="– 为什么要使用多线程?"></a>– 为什么要使用多线程?</h4><ul><li>线程是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li><li>可以大大提高系统整体的并发能力以及性能。</li></ul><h4 id="–-使用多线程可能带来什么问题"><a href="#–-使用多线程可能带来什么问题" class="headerlink" title="– 使用多线程可能带来什么问题?"></a>– 使用多线程可能带来什么问题?</h4><p>并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：<strong>内存泄漏、死锁、线程不安全</strong>等。</p><h4 id="–-如何理解线程安全？"><a href="#–-如何理解线程安全？" class="headerlink" title="– 如何理解线程安全？"></a>– 如何理解线程安全？</h4><p><strong>多线程环境下对于同一份数据的访问是否能够保证其正确性和一致性。</strong></p><p>线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。</p><h4 id="–-线程的生命周期和状态-★"><a href="#–-线程的生命周期和状态-★" class="headerlink" title="– 线程的生命周期和状态? ★"></a>– 线程的生命周期和状态? ★</h4><p>六种状态：</p><ul><li><strong>NEW: 初始状态</strong>，线程被创建出来但没有被调用 <code>start()</code> 。</li><li><strong>RUNNABLE: 运行状态</strong>，线程被调用了 <code>start()</code>等待运行的状态。</li><li><strong>BLOCKED：阻塞状态</strong>，需要等待锁释放。</li><li><strong>WAITING：等待状态</strong>，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</li><li><strong>TIME_WAITING：超时等待状态</strong>，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</li><li><strong>TERMINATED：终止状态</strong>，表示该线程已经运行完毕。</li></ul><ol><li>线程创建之后它将处于 NEW（新建） 状态，调用 start() 方法后开始运行，线程这时候处于 READY（可运行） 状态。</li><li>可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 RUNNING（运行） 状态。</li><li>当线程执行 wait()方法之后，线程进入 WAITING（等待） 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。</li><li>TIMED_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制，比如通过 sleep（long millis）方法或 wait（long millis）方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。</li><li>当线程进入 synchronized 方法&#x2F;块或者调用 wait 后（被 notify）重新进入 synchronized 方法&#x2F;块，但是锁被其它线程占有，这个时候线程就会进入 BLOCKED（阻塞） 状态。</li><li>线程在执行完了 run()方法之后之后将会进入到 TERMINATED（终止） 状态。</li></ol><h4 id="–-什么是线程上下文切换"><a href="#–-什么是线程上下文切换" class="headerlink" title="– 什么是线程上下文切换?"></a>– 什么是线程上下文切换?</h4><p>当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p><ul><li>主动让出 CPU，比如调用了 sleep(), wait() 等。</li><li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li><li>被终止或结束运行</li></ul><p>这其中前三种都会发生线程切换，<strong>线程切换</strong>意味着<strong>需要保存当前线程的上下文</strong>，<strong>待线程下次占用 CPU 的时候恢复</strong>现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 上下文切换。</p><p>因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p><h4 id="–-什么是线程死锁-如何避免死锁"><a href="#–-什么是线程死锁-如何避免死锁" class="headerlink" title="– 什么是线程死锁?如何避免死锁?"></a>– 什么是线程死锁?如何避免死锁?</h4><h5 id="什么是死锁："><a href="#什么是死锁：" class="headerlink" title="什么是死锁："></a>什么是死锁：</h5><ul><li><strong>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。</strong>由于线程被无限期地阻塞，因此程序不可能正常终止。</li><li>线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</li></ul><h5 id="产生死锁的四个必要条件："><a href="#产生死锁的四个必要条件：" class="headerlink" title="产生死锁的四个必要条件："></a>产生死锁的四个必要条件：</h5><ol><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。如何预防和避</li></ol><h5 id="预防和避免线程死锁："><a href="#预防和避免线程死锁：" class="headerlink" title="预防和避免线程死锁："></a>预防和避免线程死锁：</h5><p>破坏死锁的产生的必要条件即可：</p><ol><li>破坏请求与保持条件：一次性申请所有的资源。</li><li>破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li>破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li></ol><p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态</p><h4 id="–-sleep-方法和-wait-方法对比"><a href="#–-sleep-方法和-wait-方法对比" class="headerlink" title="– sleep() 方法和 wait() 方法对比"></a>– sleep() 方法和 wait() 方法对比</h4><p><strong>共同点</strong>：两者都可以暂停线程的执行。</p><p><strong>区别</strong>: </p><ul><li><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁 。</li><li><code>wait()</code> 通常被用于线程间交互&#x2F;通信，<code>sleep()</code>通常被用于暂停执行。</li><li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li><li><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法（因为wait要释放当前线程占有的对象锁，操作的对象自然是Object）。</li></ul><h4 id="–-可以直接调用-Thread-类的-run-方法吗？"><a href="#–-可以直接调用-Thread-类的-run-方法吗？" class="headerlink" title="– 可以直接调用 Thread 类的 run 方法吗？"></a>– 可以直接调用 Thread 类的 run 方法吗？</h4><p><strong>调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。</strong></p><h3 id="【volatile-关键字】"><a href="#【volatile-关键字】" class="headerlink" title="【volatile 关键字】"></a>【volatile 关键字】</h3><h4 id="–-volatile总结"><a href="#–-volatile总结" class="headerlink" title="– volatile总结"></a>– volatile总结</h4><ul><li>volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。</li><li>防止 JVM 的指令重排序。</li></ul><h4 id="–-保证变量的可见性？"><a href="#–-保证变量的可见性？" class="headerlink" title="– 保证变量的可见性？"></a>– 保证变量的可见性？</h4><p>将变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JMM(Java内存模型): </span><br><span class="line">线程1 &lt;-&gt; 本地内存(共享变量副本) &lt;--&gt; 主内存-共享变量</span><br><span class="line">强制在主内存中进行读取:</span><br><span class="line">线程1 &lt;-&gt; 本地内存(共享变量副本) &lt;--&gt; 主内存-共享变量</span><br><span class="line"> &lt;---------------------&gt; 主内存-共享变量</span><br></pre></td></tr></table></figure><h4 id="–-volatile-可以保证原子性么？"><a href="#–-volatile-可以保证原子性么？" class="headerlink" title="– volatile 可以保证原子性么？"></a>– volatile 可以保证原子性么？</h4><p>不能。</p><ul><li><p>线程 1 对 inc 进行读取操作之后，还未对其进行修改。线程 2 又读取了 inc的值并对其进行修改（+1），再将inc 的值写回内存。</p><p>线程 2 操作完毕后，线程 1 对 inc的值进行修改（+1），再将inc 的值写回内存。</p><p>这也就导致两个线程分别对 inc 进行了一次自增操作后，inc 实际上只增加了 1。</p></li><li><p>如果想要保证上面的代码运行正确也非常简单，利用 synchronized、Lock或者AtomicInteger都可以。</p></li></ul><h4 id="–-禁止指令重排序？"><a href="#–-禁止指令重排序？" class="headerlink" title="– 禁止指令重排序？"></a>– 禁止指令重排序？</h4><p>将变量声明为 volatile ，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。</p><h4 id="–-指令重排序"><a href="#–-指令重排序" class="headerlink" title="– 指令重排序"></a>– 指令重排序</h4><ul><li><p>为了提升执行速度&#x2F;性能，计算机在执行程序代码的时候，会对指令进行重排序。</p></li><li><p>系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行</p></li><li><p>常见的指令重排序有下面 2 种情况：</p><ul><li><p>编译器优化重排：编译器（包括 JVM、JIT 编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序。</p></li><li><p>指令并行重排：现代处理器采用了指令级并行技术(Instruction-Level Parallelism，ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p></li></ul></li><li><p>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致 ，所以在多线程下，指令重排序可能会导致一些问题。</p></li></ul><h4 id="–-乐观锁和悲观锁"><a href="#–-乐观锁和悲观锁" class="headerlink" title="– 乐观锁和悲观锁"></a>– 乐观锁和悲观锁</h4><h5 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h5><ul><li>总是假设最坏的情况。<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。</strong></li><li>synchronized 和 ReentrantLock 等<strong>独占锁</strong>就是悲观锁思想的实现。</li></ul><h5 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h5><ul><li>总是假设最好的情况。</li><li>共享资源每次被访问的时候不会出现问题，<strong>线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源</strong>（也就是数据）<strong>是否被其它线程修改了</strong>（具体方法可以使用<strong>版本号机制</strong>或 <strong>CAS 算法</strong>）。</li></ul><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul><li>悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。如果乐观锁解决了频繁失败和重试这个问题的话（比如LongAdder），也是可以考虑使用乐观锁的，要视实际情况而定。</li><li>乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。主要针对的对象是单个共享变量。</li></ul><h5 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h5><p>在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。</p><h5 id="CAS算法-乐观锁使用更多"><a href="#CAS算法-乐观锁使用更多" class="headerlink" title="CAS算法(乐观锁使用更多)"></a>CAS算法(乐观锁使用更多)</h5><p>用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</p><h3 id="【synchronized-关键字】"><a href="#【synchronized-关键字】" class="headerlink" title="【synchronized 关键字】"></a>【synchronized 关键字】</h3><ul><li>Java 中的一个关键字，主要解决的是<strong>多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行</strong>。</li><li>Java 6 进行了<strong>优化</strong></li><li><strong>修饰实例方法、修饰静态方法、修饰代码块</strong></li></ul><h4 id="–-构造方法可以用-synchronized-修饰么？"><a href="#–-构造方法可以用-synchronized-修饰么？" class="headerlink" title="– 构造方法可以用 synchronized 修饰么？"></a>– 构造方法可以用 synchronized 修饰么？</h4><p>构造方法本身就属于线程安全的，不存在同步的构造方法一说。</p><h4 id="–-synchronized-和-volatile-有什么区别？"><a href="#–-synchronized-和-volatile-有什么区别？" class="headerlink" title="– synchronized 和 volatile 有什么区别？"></a>– synchronized 和 volatile 有什么区别？</h4><p>互补。</p><ul><li>volatile 关键字是线程同步的轻量级实现，所以 volatile性能肯定比synchronized关键字要好 。但是 volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块 。</li><li>volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。</li><li>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。</li></ul><h3 id="【ReentrantLock】"><a href="#【ReentrantLock】" class="headerlink" title="【ReentrantLock】"></a>【ReentrantLock】</h3><h4 id="–-ReentrantLock-是什么？"><a href="#–-ReentrantLock-是什么？" class="headerlink" title="– ReentrantLock 是什么？"></a>– ReentrantLock 是什么？</h4><ul><li>实现了 <strong><code>Lock</code></strong> 接口，是一个<strong>可重入且独占式的锁</strong>，和 synchronized 关键字类似。不过，ReentrantLock 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</li><li>ReentrantLock 默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁。</li></ul><h4 id="–-公平锁和非公平锁有什么区别？"><a href="#–-公平锁和非公平锁有什么区别？" class="headerlink" title="– 公平锁和非公平锁有什么区别？"></a>– 公平锁和非公平锁有什么区别？</h4><ul><li><strong>公平锁</strong> : 锁被释放之后，<strong>先申请的线程先得到锁</strong>。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</li><li>非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</li></ul><h4 id="–-synchronized-和-ReentrantLock-有什么区别？"><a href="#–-synchronized-和-ReentrantLock-有什么区别？" class="headerlink" title="– synchronized 和 ReentrantLock 有什么区别？"></a>– synchronized 和 ReentrantLock 有什么区别？</h4><ul><li><strong>两者都是可重入锁</strong><ul><li>可重入锁 也叫递归锁，指的是线程<strong>可以再次获取自己的内部锁</strong>。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</li><li>JDK 提供的所有现成的 Lock 实现类，包括 synchronized 关键字锁都是可重入的。</li></ul></li><li><strong>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</strong></li><li><strong>相比synchronized，ReentrantLock增加了一些高级功能</strong><ul><li>等待可中断</li><li>可实现公平锁</li><li>可实现选择性通知（锁可以绑定多个条件）</li></ul></li></ul><h4 id="–-可中断锁和不可中断锁有什么区别？"><a href="#–-可中断锁和不可中断锁有什么区别？" class="headerlink" title="– 可中断锁和不可中断锁有什么区别？"></a>– 可中断锁和不可中断锁有什么区别？</h4><ul><li>可中断锁：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。ReentrantLock 就属于是可中断锁。</li><li>不可中断锁：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 synchronized 就属于是不可中断锁。</li></ul><h3 id="【ThreadLocal】"><a href="#【ThreadLocal】" class="headerlink" title="【ThreadLocal】"></a>【ThreadLocal】</h3><h4 id="–-ThreadLocal-有什么用？"><a href="#–-ThreadLocal-有什么用？" class="headerlink" title="– ThreadLocal 有什么用？"></a>– ThreadLocal 有什么用？</h4><ul><li>ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以<strong>存储每个线程的私有数据</strong>。</li><li>创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，可以使用 get() 和 set() 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</li></ul><h4 id="–-ThreadLocal-原理了解吗？"><a href="#–-ThreadLocal-原理了解吗？" class="headerlink" title="– ThreadLocal 原理了解吗？"></a>– ThreadLocal 原理了解吗？</h4><ul><li>最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。</li><li>每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为 key ，Object 对象为 value 的键值对。</li></ul><h4 id="–-ThreadLocal-内存泄露问题是怎么导致的？"><a href="#–-ThreadLocal-内存泄露问题是怎么导致的？" class="headerlink" title="– ThreadLocal 内存泄露问题是怎么导致的？"></a>– ThreadLocal 内存泄露问题是怎么导致的？</h4><ul><li>ThreadLocalMap 中使用的 key 为 ThreadLocal 的<strong>弱引用</strong>，而 value 是<strong>强引用</strong>。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</li><li><strong>使用完 ThreadLocal方法后最好手动调用remove()方法</strong></li><li><strong>弱引用</strong>：在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</li></ul><h3 id="【线程池】"><a href="#【线程池】" class="headerlink" title="【线程池】"></a>【线程池】</h3><h4 id="–-线程池？"><a href="#–-线程池？" class="headerlink" title="– 线程池？"></a>– 线程池？</h4><ul><li>管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</li><li>使用线程池的好处：<ul><li>降低资源消耗</li><li>提高响应速度</li><li>提高线程的可管理性</li></ul></li></ul><h4 id="–-如何创建线程池？"><a href="#–-如何创建线程池？" class="headerlink" title="– 如何创建线程池？"></a>– 如何创建线程池？</h4><p>方式一：通过**<code>ThreadPoolExecutor</code>**构造函数来创建（推荐）</p><p>方式二：通过 <strong>Executor 框架</strong>的工具类 <strong>Executors</strong> 来创建。</p><h4 id="–-线程池常见参数有哪些？"><a href="#–-线程池常见参数有哪些？" class="headerlink" title="– 线程池常见参数有哪些？"></a>– 线程池常见参数有哪些？</h4><ul><li><p>ThreadPoolExecutor 3 个最重要的参数：</p><ul><li><strong>corePoolSize</strong> : 任务队列未达到队列容量时，<strong>最大可以同时运行的线程数量</strong>。</li><li><strong>maximumPoolSize</strong> : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong>workQueue:</strong> 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul></li><li><p>ThreadPoolExecutor其他常见参数 :</p><ul><li><p>keepAliveTime:线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，多余的空闲线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁，线程池回收线程时，会对核心线程和非核心线程一视同仁，直到线程池中线程的数量等于 corePoolSize ，回收过程才会停止</p></li><li><p>unit : keepAliveTime 参数的时间单位</p></li><li><p>threadFactory :executor 创建新线程的时候会用到</p></li><li><p>handler :<strong>饱和策略</strong></p></li></ul></li></ul><h4 id="–-线程池的饱和策略有哪些？"><a href="#–-线程池的饱和策略有哪些？" class="headerlink" title="– 线程池的饱和策略有哪些？"></a>– 线程池的饱和策略有哪些？</h4><ul><li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。(spring默认策略)</li><li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li><li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li><li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。</li></ul><h4 id="–-线程池常用的阻塞队列有哪些？"><a href="#–-线程池常用的阻塞队列有哪些？" class="headerlink" title="– 线程池常用的阻塞队列有哪些？"></a>– 线程池常用的阻塞队列有哪些？</h4><p>新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</p><ul><li>容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue（无界队列）</li><li>SynchronousQueue（同步队列）</li><li>DelayedWorkQueue（延迟阻塞队列）</li></ul><h4 id="–-线程池处理任务的流程了解吗？"><a href="#–-线程池处理任务的流程了解吗？" class="headerlink" title="– 线程池处理任务的流程了解吗？"></a>– 线程池处理任务的流程了解吗？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">提交任务 -》 核心线程池是否已满 -Y-》等待队列是否已满 -Y-》线程池是否已满 -Y-》按照策略处理</span><br><span class="line">   -N 》创建线程   - N-》创建队列 -N-》创建线程</span><br></pre></td></tr></table></figure><h3 id="【Future】"><a href="#【Future】" class="headerlink" title="【Future】"></a>【Future】</h3><h4 id="–-Future-类有什么用？"><a href="#–-Future-类有什么用？" class="headerlink" title="– Future 类有什么用？"></a>– Future 类有什么用？</h4><ul><li><p>当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 Future 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p></li><li><p>多线程中经典的 Future 模式，你可以将其看作是一种设计模式，核心思想是异步调用</p></li><li><p>Future 类只是一个泛型接口，位于 java.util.concurrent 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p><ul><li><p>取消任务；</p></li><li><p>判断任务是否被取消;</p></li><li><p>判断任务是否已经执行完成;</p></li><li><p>获取任务执行结果。</p></li></ul></li></ul><h3 id="【AQS】"><a href="#【AQS】" class="headerlink" title="【AQS】"></a>【AQS】</h3><h4 id="–-AQS-是什么？"><a href="#–-AQS-是什么？" class="headerlink" title="– AQS 是什么？"></a>– AQS 是什么？</h4><ul><li>AQS 的全称为 AbstractQueuedSynchronizer ，翻译过来的意思就是抽象队列同步器。</li><li>AQS 就是一个抽象类，主要用来构建锁和同步器。</li><li>AQS 为构建锁和同步器提供了一些通用功能的实现，因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue等等皆是基于 AQS 的。</li></ul><h3 id="【虚拟线程】"><a href="#【虚拟线程】" class="headerlink" title="【虚拟线程】"></a>【虚拟线程】</h3><h3 id="【JMM-Java内存模型-】"><a href="#【JMM-Java内存模型-】" class="headerlink" title="【JMM (Java内存模型)】"></a>【JMM (Java内存模型)】</h3><p><strong>抽象线程和主内存之间的关系</strong></p><h4 id="–-Java-内存区域和-JMM-有何区别？"><a href="#–-Java-内存区域和-JMM-有何区别？" class="headerlink" title="– Java 内存区域和 JMM 有何区别？"></a>– Java 内存区域和 JMM 有何区别？</h4><ul><li>JVM 内存结构和 Java 虚拟机的运行时区域相关，定义了 JVM 在运行时如何分区存储程序数据，就比如说堆主要用于存放对象实例。</li><li>Java 内存模型和 Java 的并发编程相关，抽象了线程和主内存之间的关系就比如说线程之间的共享变量必须存储在主内存中，规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。</li></ul><h3 id="–-并发编程三个重要特性"><a href="#–-并发编程三个重要特性" class="headerlink" title="– 并发编程三个重要特性"></a>– 并发编程三个重要特性</h3><ul><li><p>原子性：一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。</p></li><li><p>可见性：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。</p></li><li><p>有序性：由于指令重排序问题，代码的执行顺序未必就是编写代码时候的顺序。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;常看常新，持续更新…&lt;/p&gt;</summary>
    
    
    
    <category term="并发编程" scheme="https://sunrisel135.github.io/blog_lyl/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="面试" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot3与druid-无法自动装配问题</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/07/SpringBoot3%E4%B8%8Edruid-%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E9%97%AE%E9%A2%98/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/07/SpringBoot3%E4%B8%8Edruid-%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E9%97%AE%E9%A2%98/</id>
    <published>2024-03-07T12:08:30.000Z</published>
    <updated>2024-03-07T12:13:04.660Z</updated>
    
    <content type="html"><![CDATA[<p>SpringBoot3与druid，因为druid版本问题，无法在spring boot中自动装配。</p><span id="more"></span><ul><li><p>解决方式1：</p><p>通过源码分析，druid-spring-boot-3-starter目前最新版本是1.2.18，虽然适配了SpringBoot3，但缺少自动装配的配置文件。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">需要手动在resources目录下创建META-INF/spring  (注意创建时要使用/)</span><br><span class="line">文件：org.springframework.boot.autoconfigure.AutoConfiguration.imports，文件内容如下：</span><br><span class="line">com.alibaba.druid.spring.boot3.autoconfigure.DruidDataSourceAutoConfigure</span><br></pre></td></tr></table></figure><ul><li><p>解决方式2：</p><p>使用 druid1.2.20 版本</p></li></ul><p></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-3-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;SpringBoot3与druid，因为druid版本问题，无法在spring boot中自动装配。&lt;/p&gt;</summary>
    
    
    
    <category term="SpringBoot" scheme="https://sunrisel135.github.io/blog_lyl/categories/SpringBoot/"/>
    
    
    <category term="问题" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Spring从配置文件获取到的值与实际值不一致问题</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/07/Spring%E4%BB%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%8E%B7%E5%8F%96%E5%88%B0%E7%9A%84%E5%80%BC%E4%B8%8E%E5%AE%9E%E9%99%85%E5%80%BC%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/07/Spring%E4%BB%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%8E%B7%E5%8F%96%E5%88%B0%E7%9A%84%E5%80%BC%E4%B8%8E%E5%AE%9E%E9%99%85%E5%80%BC%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/</id>
    <published>2024-03-07T07:51:41.000Z</published>
    <updated>2024-03-07T07:52:33.123Z</updated>
    
    <content type="html"><![CDATA[<p>使用Spring框架对druid数据库连接池配置时，value&#x3D;${username}获取到的值并非配置文件中的值。。。</p><span id="more"></span><ul><li><p>参考链接: <a href="https://blog.csdn.net/qq_46274901/article/details/123835512">https://blog.csdn.net/qq_46274901/article/details/123835512</a></p></li><li><p>原因：</p><p>使用Spring框架对druid数据库连接池配置时，value&#x3D;${username}获取到的值并非配置文件中的值，而是获取的windows系统用户的值，也就是我的名字。从而导致配置信息错误，无法连接数据库。</p></li><li><p>解决：</p><p>将配置文件的username改名为user，将spring中的value配置信息改为value&#x3D;${user}.避免重名即可。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用Spring框架对druid数据库连接池配置时，value&amp;#x3D;${username}获取到的值并非配置文件中的值。。。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="https://sunrisel135.github.io/blog_lyl/categories/Spring/"/>
    
    
    <category term="问题" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>实例化对象方式</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/07/%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%E6%96%B9%E5%BC%8F/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/07/%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%E6%96%B9%E5%BC%8F/</id>
    <published>2024-03-07T07:15:31.000Z</published>
    <updated>2024-03-07T07:38:50.430Z</updated>
    
    <content type="html"><![CDATA[<p>实例化对象的几种方式总结。</p><span id="more"></span><ul><li>构造函数实例化<ul><li>无参构造函数</li><li>有参构造函数</li></ul></li><li>工厂模式实例化<ul><li>静态工厂</li><li>非静态工厂</li></ul></li><li>反射</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;实例化对象的几种方式总结。&lt;/p&gt;</summary>
    
    
    
    <category term="Java基础" scheme="https://sunrisel135.github.io/blog_lyl/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="知识点" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>子、父类加载顺序</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/06/%E5%AD%90%E3%80%81%E7%88%B6%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/06/%E5%AD%90%E3%80%81%E7%88%B6%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/</id>
    <published>2024-03-06T12:58:55.000Z</published>
    <updated>2024-03-07T07:38:57.767Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接: <a href="https://blog.csdn.net/j_love93/article/details/77693230">https://blog.csdn.net/j_love93/article/details/77693230</a></p><p>详解请查看全文。。。</p><span id="more"></span><h5 id="1-在没有子类的情况下"><a href="#1-在没有子类的情况下" class="headerlink" title="1.在没有子类的情况下"></a>1.在没有子类的情况下</h5><p>**在初始化类时候，首先加载类的静态变量和静态语句块（按照代码上下顺序执行），然后加载类的非静态变量和非静态语句块（按照代码上下顺序执行），最后加载类的构造函数。 </p><p>至于类的静态方法和非静态方法只有主动调用的时候才会执行,区别在于静态方法可以直接用类名直接调用(实例化对象也可以),而非静态方法只能先实例化对象后才能调用。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS:不管是父类还是子类加载（静态变量和静态语句块）都只能加载一次。</span><br><span class="line"></span><br><span class="line">总结：静态 -&gt; 非静态 -&gt; 构造函数</span><br></pre></td></tr></table></figure><h5 id="2-在有子类的情况下"><a href="#2-在有子类的情况下" class="headerlink" title="2.在有子类的情况下"></a>2.在有子类的情况下</h5><p>在初始化子类的时候，首先加载父类的静态变量和静态语句块（按照代码上下顺序执行），然后加载子类的静态变量和静态语句块（按照代码上下顺序执行），然后加载父类的非静态变量和非静态语句块（按照代码上下顺序执行），再加载父类的构造函数。然后加载子类的非静态变量和非静态语句块（按照代码上下顺序执行），最后加载子类的构造函数。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 父类的静态变量和静态语句块（按照代码上下顺序执行）</span><br><span class="line">2. 子类的静态变量和静态语句块（按照代码上下顺序执行）</span><br><span class="line">3. 父类的非静态变量和非静态语句块（按照代码上下顺序执行）</span><br><span class="line">4. 父类的构造函数</span><br><span class="line">5. 子类的非静态变量和非静态语句块（按照代码上下顺序执行）</span><br><span class="line">6. 子类的构造函数</span><br><span class="line"></span><br><span class="line">总结：父类静态--子类静态--父类非静态--父类构造--子类非静态--子类构造</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;参考链接: &lt;a href=&quot;https://blog.csdn.net/j_love93/article/details/77693230&quot;&gt;https://blog.csdn.net/j_love93/article/details/77693230&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;详解请查看全文。。。&lt;/p&gt;</summary>
    
    
    
    <category term="Java基础" scheme="https://sunrisel135.github.io/blog_lyl/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="知识点" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Java面试-Java基础</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/05/Java%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/05/Java%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/</id>
    <published>2024-03-05T02:21:45.000Z</published>
    <updated>2024-03-09T13:26:51.010Z</updated>
    
    <content type="html"><![CDATA[<p>持续更新。。。</p><span id="more"></span><h2 id="Java基础常见面试题-上"><a href="#Java基础常见面试题-上" class="headerlink" title="Java基础常见面试题(上)"></a>Java基础常见面试题(上)</h2><h3 id="【基础概念与常识】"><a href="#【基础概念与常识】" class="headerlink" title="【基础概念与常识】"></a>【基础概念与常识】</h3><h4 id="–Java-语言有哪些特点"><a href="#–Java-语言有哪些特点" class="headerlink" title="–Java 语言有哪些特点?"></a>–Java 语言有哪些特点?</h4><ul><li>面向对象（封装，继承，多态）</li><li>平台无关性（ Java 虚拟机实现平台无关性）</li><li>支持多线程</li><li>可靠性（具备异常处理和自动内存管理机制）</li><li>安全性（Java 语言本身的设计就提供了多重安全防护机制如访问权限修饰符、限制程序直接访问操作系统资源）</li><li>编译与解释并存</li></ul><h4 id="–Java-SE-vs-Java-EE"><a href="#–Java-SE-vs-Java-EE" class="headerlink" title="–Java SE vs Java EE"></a>–Java SE vs Java EE</h4><p>简单来说，Java SE 是 Java 的基础版本，Java EE 是 Java 的高级版本。Java SE 更适合开发桌面应用程序或简单的服务器应用程序，Java EE 更适合开发复杂的企业级应用程序或 Web 应用程序。</p><p>Java ME 是 Java 的微型版本，主要用于开发嵌入式消费电子设备的应用程序。</p><h4 id="–JVM-vs-JDK-vs-JRE"><a href="#–JVM-vs-JDK-vs-JRE" class="headerlink" title="–JVM vs JDK vs JRE"></a>–JVM vs JDK vs JRE</h4><ul><li><p><strong>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机</strong>。</p><p>JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“<strong>一次编译，随处可以运行</strong>”的关键所在。</p></li><li><p><strong>JRE（Java Runtime Environment） 是 Java 运行时环境。</strong></p><p>它是运行已编译 Java 程序所需的所有内容的集合，主要包括 <strong>Java 虚拟机（JVM）</strong>、<strong>Java 基础类库（Class Library）</strong>。</p></li><li><p><strong>JDK（Java Development Kit），它是功能齐全的 Java SDK，是提供给开发者使用，能够创建和编译 Java 程序的开发套件</strong>。</p><p>它包含了 <strong>JRE</strong>，同时还包含了<strong>编译 java 源码的编译器 javac 以及一些其他工具</strong>比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等。</p></li></ul><h4 id="–什么是字节码-采用字节码的好处是什么"><a href="#–什么是字节码-采用字节码的好处是什么" class="headerlink" title="–什么是字节码?采用字节码的好处是什么?"></a>–什么是字节码?采用字节码的好处是什么?</h4><p><strong>JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），只面向虚拟机。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java 程序从源代码到运行的过程：</span><br><span class="line">.java -&gt; javac 编译 -&gt; .class -&gt; 热点代码？ NO-&gt; 解释器 -&gt; 机器可理解的代码</span><br><span class="line">     YES-&gt; JIT -&gt; 机器可理解的代码</span><br></pre></td></tr></table></figure><p> <strong>JIT</strong>（Just in Time Compilation） <strong>编译器</strong>，而 JIT 属于<strong>运行时编译</strong>。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</p><h4 id="–-为什么说-Java-语言“编译与解释并存”？"><a href="#–-为什么说-Java-语言“编译与解释并存”？" class="headerlink" title="– 为什么说 Java 语言“编译与解释并存”？"></a>– 为什么说 Java 语言“编译与解释并存”？</h4><ul><li><strong>编译型：</strong>编译型语言open in new window 会通过编译器open in new window将源代码<strong>一次性</strong>翻译成可被该平台执行的机器码。一般情况下，编译语言的<strong>执行速度比较快</strong>，开发效率比较低。</li><li><strong>解释型：</strong>解释型语言open in new window会通过解释器open in new window<strong>一句一句</strong>的将代码解释（interpret）为机器代码后再执行。解释型语言<strong>开发效率比较快</strong>，执行速度比较慢。</li><li>因为 Java 程序要经过先编译，后解释两个步骤，<strong>由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</strong></li></ul><h4 id="–-AOT-VS-JIT"><a href="#–-AOT-VS-JIT" class="headerlink" title="– AOT VS JIT ?"></a>– AOT VS JIT ?</h4><ul><li>新的编译模式 <code>AOT</code>(Ahead of Time Compilation) </li><li><code>AOT</code>会在程序被<strong>执行前就将其编译成机器码</strong>，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）</li><li>而 <code>JIT</code> 属于<strong>运行时编译</strong>。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</li><li><code>AOT</code> 的主要优势在于启动时间、内存占用和打包体积。<code>JIT</code> 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。</li><li><code>AOT</code> 更适合当下的云原生场景，对微服务架构的支持也比较友好。无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等。然而，很多框架和库（如 Spring、CGLIB）都用到了这些特性。如果只使用 AOT 编译，那就没办法使用这些框架和库了，或者说需要针对性地去做适配和优化。</li></ul><h4 id="–-Oracle-JDK-vs-OpenJDK"><a href="#–-Oracle-JDK-vs-OpenJDK" class="headerlink" title="– Oracle JDK vs OpenJDK"></a>– Oracle JDK vs OpenJDK</h4><ol><li>是否开源</li><li>是否免费</li><li>功能性：Oracle JDK 在 OpenJDK 的基础上添加了一些特有的功能和工具</li><li>稳定性</li><li>协议</li></ol><h4 id="–-Java-和-C-的区别"><a href="#–-Java-和-C-的区别" class="headerlink" title="– Java 和 C++ 的区别?"></a>– Java 和 C++ 的区别?</h4><ul><li>都是面向对象的语言，都支持封装、继承和多态</li></ul><ol><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li><li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li><li>……</li></ol><h3 id="【基本语法】"><a href="#【基本语法】" class="headerlink" title="【基本语法】"></a>【基本语法】</h3><h4 id="–-注释有哪几种形式？"><a href="#–-注释有哪几种形式？" class="headerlink" title="– 注释有哪几种形式？"></a>– 注释有哪几种形式？</h4><ol><li><strong>单行注释</strong>：通常用于解释方法内某单行代码的作用。</li><li><strong>多行注释</strong>：通常用于解释一段代码的作用。</li><li><strong>文档注释</strong>：通常用于生成 Java 开发文档。</li></ol><h4 id="–-标识符和关键字的区别是什么？"><a href="#–-标识符和关键字的区别是什么？" class="headerlink" title="– 标识符和关键字的区别是什么？"></a>– 标识符和关键字的区别是什么？</h4><ul><li>在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了 <strong>标识符</strong> 。简单来说， <strong>标识符就是一个名字</strong> 。</li><li><strong>关键字是被赋予特殊含义的标识符</strong> 。</li><li>Tips：所有的关键字都是小写的，在 IDE 中会以特殊颜色显示。</li></ul><h4 id="–-自增自减运算符"><a href="#–-自增自减运算符" class="headerlink" title="– 自增自减运算符"></a>– 自增自减运算符</h4><p>自增运算符（++)和自减运算符（–）</p><h4 id="–-移位运算符"><a href="#–-移位运算符" class="headerlink" title="– 移位运算符"></a>– 移位运算符</h4><ul><li><code>&lt;&lt;</code> :左移运算符，向左移若干位，高位丢弃，低位补零。<code>x &lt;&lt; 1</code>,相当于 x 乘以 2(不溢出的情况下)。</li><li><code>&gt;&gt;</code> :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。<code>x &gt;&gt; 1</code>,相当于 x 除以 2。</li><li><code>&gt;&gt;&gt;</code> :无符号右移，忽略符号位，空位都以 0 补齐。</li><li>移位操作符实际上支持的类型只有<code>int</code>和<code>long</code>，编译器在对short、byte、char类型进行移位前，都会将其转换为int类型再操作。</li></ul><h4 id="–-continue、break-和-return-的区别是什么？"><a href="#–-continue、break-和-return-的区别是什么？" class="headerlink" title="– continue、break 和 return 的区别是什么？"></a>– continue、break 和 return 的区别是什么？</h4><ol><li><code>continue</code>：指跳出当前的这一次循环，继续下一次循环。</li><li><code>break</code>：指跳出整个循环体，继续执行循环下面的语句。</li><li><code>return</code> 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：<ul><li><code>return;</code>：直接使用 return 结束方法执行，用于没有返回值函数的方法</li><li><code>return value;</code>：return 一个特定值，用于有返回值函数的方法</li></ul></li></ol><h3 id="【基本数据类型】"><a href="#【基本数据类型】" class="headerlink" title="【基本数据类型】"></a>【基本数据类型】</h3><h4 id="–-Java-中有-8-种基本数据类型"><a href="#–-Java-中有-8-种基本数据类型" class="headerlink" title="– Java 中有 8 种基本数据类型"></a>– Java 中有 8 种基本数据类型</h4><ul><li>6 种数字类型：<ul><li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>2 种浮点型：<code>float</code>、<code>double</code></li></ul></li><li>1 种字符类型：<code>char</code></li><li>1 种布尔型：<code>boolean</code>。</li></ul><h4 id="–-基本类型和包装类型的区别？"><a href="#–-基本类型和包装类型的区别？" class="headerlink" title="– 基本类型和包装类型的区别？"></a>– 基本类型和包装类型的区别？</h4><p>八种基本类型都有对应的包装类分别为：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</p><ul><li><p>除了定义一些常量和局部变量之外，我们在其他地方比如<strong>方法参数、对象属性</strong>中很少会使用基本类型<strong>来定义变量</strong>。并且，<strong>包装类型</strong>可<strong>用于泛型</strong>，而基本类型不可以。</p></li><li><p><strong>基本数据类型</strong>：<strong>局部变量</strong>存放在JVM<strong>栈</strong>的局部变量表中，<strong>成员变量</strong>存放在<strong>堆</strong>中。</p><p><strong>包装类型</strong>属于<strong>对象</strong>类型，我们知道几乎所有对象实例都存在于<strong>堆</strong>中。</p></li><li><p><strong>占用空间</strong>：基本数据类型占用的空间往往非常小。</p></li><li><p><strong>默认值</strong>：成员变量<strong>包装类</strong>型不赋值就是 <strong>null</strong> ，而<strong>基本类型有默认值</strong>且不是 null。</p></li><li><p><strong>比较方式</strong>：基本数据类型 <code>==</code>，整型包装类对象 <code>equals()</code></p></li></ul><h4 id="–-包装类型的缓存机制了解么？"><a href="#–-包装类型的缓存机制了解么？" class="headerlink" title="– 包装类型的缓存机制了解么？"></a>– 包装类型的缓存机制了解么？</h4><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p><h4 id="–-自动装箱与拆箱了解吗？原理是什么？"><a href="#–-自动装箱与拆箱了解吗？原理是什么？" class="headerlink" title="– 自动装箱与拆箱了解吗？原理是什么？"></a>– 自动装箱与拆箱了解吗？原理是什么？</h4><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来； <code>valueOf()</code>方法</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型； <code>xxxValue()</code>方法</li><li><code>Integer i = 10 等价于 Integer i = Integer.valueOf(10)</code><br><code>int n = i 等价于 int n = i.intValue();</code></li><li>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</li></ul><h4 id="–-为什么浮点数运算的时候会有精度丢失的风险？"><a href="#–-为什么浮点数运算的时候会有精度丢失的风险？" class="headerlink" title="– 为什么浮点数运算的时候会有精度丢失的风险？"></a>– 为什么浮点数运算的时候会有精度丢失的风险？</h4><p>计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。</p><h4 id="–-如何解决浮点数运算的精度丢失问题？"><a href="#–-如何解决浮点数运算的精度丢失问题？" class="headerlink" title="– 如何解决浮点数运算的精度丢失问题？"></a>– 如何解决浮点数运算的精度丢失问题？</h4><p><code>BigDecimal</code></p><h4 id="–-超过-long-整型的数据应该如何表示？"><a href="#–-超过-long-整型的数据应该如何表示？" class="headerlink" title="– 超过 long 整型的数据应该如何表示？"></a>– 超过 long 整型的数据应该如何表示？</h4><p><code>BigInteger</code></p><h3 id="【变量】"><a href="#【变量】" class="headerlink" title="【变量】"></a>【变量】</h3><h4 id="–-成员变量与局部变量的区别？"><a href="#–-成员变量与局部变量的区别？" class="headerlink" title="– 成员变量与局部变量的区别？"></a>– 成员变量与局部变量的区别？</h4><ul><li><p><strong>语法形式</strong>：</p><p>成员变量是<strong>属于类</strong>的，而局部变量是<strong>在代码块或方法中定义的变量或是方法的参数</strong>；</p><p>成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</p></li><li><p><strong>存储方式</strong>：</p><p>如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而<strong>对象存在于堆内存，局部变量则存在于栈内存</strong>。</p></li><li><p><strong>生存时间</strong>：</p><p>成员变量是对象的一部分，它<strong>随着对象的创建而存在</strong>，</p><p>而局部变量随着方法的调用而自动生成，<strong>随着方法的调用结束而消亡</strong>。</p></li><li><p><strong>默认值</strong>：</p><p>成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值 (一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值) ；</p><p>而<strong>局部变量则不会自动赋值</strong>；</p></li></ul><h4 id="–-字符型常量和字符串常量的区别"><a href="#–-字符型常量和字符串常量的区别" class="headerlink" title="– 字符型常量和字符串常量的区别?"></a>– 字符型常量和字符串常量的区别?</h4><ul><li><p>形式 : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。</p></li><li><p>含义 : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。</p></li><li><p>占内存大小：字符常量只占 2 个字节; 字符串常量占若干个字节。</p></li><li><p>注意 char 在 Java 中占两个字节。</p></li></ul><h3 id="【方法】"><a href="#【方法】" class="headerlink" title="【方法】"></a>【方法】</h3><h4 id="–-静态方法为什么不能调用非静态成员"><a href="#–-静态方法为什么不能调用非静态成员" class="headerlink" title="– 静态方法为什么不能调用非静态成员?"></a>– 静态方法为什么不能调用非静态成员?</h4><ul><li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li><li>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li></ul><h4 id="–-静态方法和实例方法有何不同？"><a href="#–-静态方法和实例方法有何不同？" class="headerlink" title="– 静态方法和实例方法有何不同？"></a>– 静态方法和实例方法有何不同？</h4><ol><li><strong>调用方式</strong>：在外部调用静态方法时，可以使用 类名.方法名 的方式，也可以使用 对象.方法名 的方式，而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象 。</li><li><strong>访问类成员是否存在限制</strong> ：静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</li></ol><h4 id="–-重载和重写有什么区别？"><a href="#–-重载和重写有什么区别？" class="headerlink" title="– 重载和重写有什么区别？"></a>– 重载和重写有什么区别？</h4><ul><li><p><strong>重载</strong></p><p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p></li><li><p><strong>重写</strong></p><p>发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><ol><li><p>方法名、参数列表必须相同，子类方法<strong>返回值类型</strong>应比父类方法返回值类型<strong>更小或相等</strong>，抛出的<strong>异常范围小于等于</strong>父类，<strong>访问修饰符范围大于等于</strong>父类。</p><p>如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p></li><li><p>如果父类方法访问修饰符为 <strong><code>private/final/static</code></strong> 则子类就<strong>不能重写</strong>该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</p></li><li><p>构造方法无法被重写</p></li></ol><p><strong>方法的重写要遵循“两同两小一大</strong></p></li></ul><h4 id="–-什么是可变长参数？"><a href="#–-什么是可变长参数？" class="headerlink" title="– 什么是可变长参数？"></a>– 什么是可变长参数？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">   <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这样方法就可以接受 0 个或者多个参数</li><li>可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。</li><li>方法重载会优先匹配固定参数</li></ul><h2 id="Java基础常见面试题-中"><a href="#Java基础常见面试题-中" class="headerlink" title="Java基础常见面试题(中)"></a>Java基础常见面试题(中)</h2><h3 id="【面向对象基础】"><a href="#【面向对象基础】" class="headerlink" title="【面向对象基础】"></a>【面向对象基础】</h3><h4 id="–-面向对象和面向过程的区别"><a href="#–-面向对象和面向过程的区别" class="headerlink" title="– 面向对象和面向过程的区别"></a>– 面向对象和面向过程的区别</h4><p>主要区别在于<strong>解决问题的方式</strong>不同：</p><ul><li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li></ul><p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p><h4 id="–-面向过程性能比面向对象高？"><a href="#–-面向过程性能比面向对象高？" class="headerlink" title="– 面向过程性能比面向对象高？"></a>– 面向过程性能比面向对象高？</h4><p><strong>面向过程性能比面向对象高</strong>。</p><p>因为<strong>类调用时需要实例化</strong>，开销较大，<strong>比较消耗资源</strong>，所以当性能是最重要的考量因素的的时候，比如单片机、嵌入式开发、Linux&#x2F;Unix等一般采用面向过程开发。</p><p>但这并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java性能差的主要原因并不是因为它是面向对象语言，而是<strong>Java是半编译语言，最终的执行代码并不是可以直接被CPU执行的二进制机械码</strong>。</p><p>而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其他一些面向过程的脚本语言性能也<strong>并不一定</strong>比Java好。</p><h4 id="–-创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#–-创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="– 创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>– 创建一个对象用什么运算符?对象实体与对象引用有何不同?</h4><p><strong>new</strong> 运算符。</p><p>new 创建对象实例 (对象实例在堆内存中)，<strong>对象引用</strong>指向<strong>对象实例</strong> (对象引用存放在栈内存中)。</p><ul><li>一个对象引用可以指向 0 个或 1 个对象；</li><li>一个对象可以有 n 个引用指向它；</li></ul><h4 id="–-对象的相等和引用相等的区别"><a href="#–-对象的相等和引用相等的区别" class="headerlink" title="– 对象的相等和引用相等的区别"></a>– 对象的相等和引用相等的区别</h4><ul><li><strong>对象的相等</strong>一般比较的是内存中<strong>存放的内容</strong>是否相等。</li><li><strong>引用相等</strong>一般比较的是他们<strong>指向的内存地址</strong>是否相等。</li></ul><h4 id="–-如果一个类没有声明构造方法，该程序能正确执行吗"><a href="#–-如果一个类没有声明构造方法，该程序能正确执行吗" class="headerlink" title="– 如果一个类没有声明构造方法，该程序能正确执行吗?"></a>– 如果一个类没有声明构造方法，该程序能正确执行吗?</h4><p><strong>可以</strong>执行！</p><p><strong>构造方法</strong>是一种特殊的方法，主要作用是完成对象的初始化工作。</p><p>一个类即使没有声明构造方法也会有<strong>默认的不带参数的构造方法</strong>。如果我们自己添加了类的构造方法 (无论是否有参)，Java 就不会添加默认的无参数的构造方法了。</p><p>这也是为什么我们在创建对象的时候后面要加一个括号 (因为要调用无参的构造方法)。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来 (无论是否用到)，因为这可以帮助我们在创建对象的时候少踩坑。</p><h4 id="–-构造方法有哪些特点？是否可被-override"><a href="#–-构造方法有哪些特点？是否可被-override" class="headerlink" title="– 构造方法有哪些特点？是否可被 override?"></a>– 构造方法有哪些特点？是否可被 override?</h4><ul><li>名字与类名相同。</li><li>没有返回值，但不能用 void 声明构造函数。</li><li>生成类的对象时自动执行，无需调用。</li></ul><p>构造方法不能被 override (重写),但是可以 overload (重载)。</p><h3 id="【面向对象三大特征】"><a href="#【面向对象三大特征】" class="headerlink" title="【面向对象三大特征】"></a>【面向对象三大特征】</h3><h4 id="–-封装"><a href="#–-封装" class="headerlink" title="– 封装"></a>– 封装</h4><p><strong>指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。</strong>但是可以提供一些可以被外界访问的方法来操作属性。如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p><h4 id="–-继承"><a href="#–-继承" class="headerlink" title="– 继承"></a>– 继承</h4><p>不同类型的对象，相互之间经常有一定数量的共同点。同时，每一个对象还定义了额外的特性使得他们与众不同。</p><p><strong>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。</strong>通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p><p><strong>注意：</strong></p><ol><li>子类拥有父类对象所有的属性和方法 (包括私有属性和私有方法)，但是<strong>父类中的私有属性和方法子类是无法访问</strong>，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。(以后介绍)。</li></ol><h4 id="–-多态"><a href="#–-多态" class="headerlink" title="– 多态"></a>– 多态</h4><p><strong>表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</strong></p><p><strong>特点:</strong></p><ul><li>对象类型和引用类型之间具有<strong>继承</strong> (类) &#x2F; 实现(接口)的<strong>关系</strong>；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序<strong>运行期间才能确定</strong>；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li></ul><h4 id="–-接口和抽象类有什么共同点和区别？"><a href="#–-接口和抽象类有什么共同点和区别？" class="headerlink" title="– 接口和抽象类有什么共同点和区别？"></a>– 接口和抽象类有什么共同点和区别？</h4><p><strong>共同点</strong>：</p><ul><li>都不能<strong>被实例化</strong>。</li><li>都可以<strong>包含抽象方法</strong>。</li><li>都可以<strong>有默认实现的方法</strong>（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</li></ul><p><strong>区别</strong>：</p><ul><li><strong>接口</strong>主要用于对<strong>类</strong>的<strong>行为</strong>进行<strong>约束</strong>，你实现了某个接口就具有了对应的行为。<strong>抽象类</strong>主要用于<strong>代码复用</strong>，<strong>强调的是所属关系</strong>。</li><li>一个类只能继承一个类，但是可以实现多个接口 (<strong>类的单继承，接口多继承</strong>)。</li><li><strong>接口</strong>中的<strong>成员变量</strong>只能是 <code>public static final</code> 类型的，<strong>不能被修改且必须有初始值</strong>，而<strong>抽象类</strong>的<strong>成员变量</strong>默认 <code>default</code>，<strong>可在子类中被重新定义，也可被重新赋值</strong>。</li></ul><h4 id="–-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><a href="#–-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？" class="headerlink" title="– 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"></a>– 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h4><ul><li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。（父类 <code>Object</code> 的 <code>clone()</code> 方法）</li><li><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。(重写了父类<code>Object</code> 的<code>clone(</code>)方法)</li></ul><p><strong>那什么是引用拷贝呢？</strong> 简单来说，<strong>引用拷贝</strong>就是两个不同的引用指向同一个对象。</p><p><img src="C:\Users\lyl\Desktop\其他\photo\shallow&deep-copy.png"></p><h3 id="【Object】"><a href="#【Object】" class="headerlink" title="【Object】"></a>【Object】</h3><h4 id="–-Object-类的常见方法有哪些？"><a href="#–-Object-类的常见方法有哪些？" class="headerlink" title="– Object 类的常见方法有哪些？"></a>– Object 类的常见方法有哪些？</h4><p>Object 类是一个特殊的类，是<strong>所有类的父类</strong>。它主要提供了以下 11 个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;持续更新。。。&lt;/p&gt;</summary>
    
    
    
    <category term="Java基础" scheme="https://sunrisel135.github.io/blog_lyl/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="面试" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Hexo搭建博客</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/04/Hexo+github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/04/Hexo+github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2024-03-04T12:12:17.000Z</published>
    <updated>2024-03-07T12:06:46.629Z</updated>
    
    <content type="html"><![CDATA[<p>基于 Hexo + GithubPage 搭建博客，我的第一个博客。</p><span id="more"></span><p>参考链接: <a href="https://blog.csdn.net/redrose2100/article/details/121731468">https://blog.csdn.net/redrose2100/article/details/121731468</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;基于 Hexo + GithubPage 搭建博客，我的第一个博客。&lt;/p&gt;</summary>
    
    
    
    <category term="博客相关" scheme="https://sunrisel135.github.io/blog_lyl/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="教程" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
