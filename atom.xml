<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lyl&#39;blog</title>
  
  
  <link href="https://sunrisel135.github.io/blog_lyl/atom.xml" rel="self"/>
  
  <link href="https://sunrisel135.github.io/blog_lyl/"/>
  <updated>2024-03-17T13:18:03.242Z</updated>
  <id>https://sunrisel135.github.io/blog_lyl/</id>
  
  <author>
    <name>lyl_L-</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Minio使用</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/17/Minio%E4%BD%BF%E7%94%A8/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/17/Minio%E4%BD%BF%E7%94%A8/</id>
    <published>2024-03-17T12:35:28.000Z</published>
    <updated>2024-03-17T13:18:03.242Z</updated>
    
    <content type="html"><![CDATA[<p>在项目学习开发时应用了此技术，对此进行部分总结。</p><p>仅个人总结！</p><span id="more"></span><h3 id="1-Minio介绍"><a href="#1-Minio介绍" class="headerlink" title="1. Minio介绍"></a>1. Minio介绍</h3><p>官网：<a href="https://www.minio.org.cn/">https://www.minio.org.cn/</a></p><ul><li>MinIO是一个开源的分布式对象存储服务器，支持S3协议并且可以在多节点上实现数据的高可用和容错。它采用Go语言开发，拥有轻量级、高性能、易部署等特点，并且可以自由选择底层存储介质。它基于Apache License 开源协议，兼容Amazon S3云存储接口。适合存储非结构化数据，如图片，音频，视频，日志等。</li><li>MinIO的主要特点包括：</li></ul><p>1、高性能：MinIO基于GO语言编写，具有高速、轻量级、高并发等性能特点，还支持多线程和缓存等机制进行优化，可以快速地处理大规模数据。</p><p>2、安装部署简单：MinIO只需要执行这几行命令便可轻松搞定，也大大降低了学习和维护成本。</p><p>3、操作简单，自带管理界面：MinIO在服务端安装后就自带了UI界面，可谓开箱即用。</p><p>4、性能优秀，读写速度快：MinIO号称是世界上速度最快的对象存储服务器，读对象的速度能达到183 GB&#x2F;s，写对象的速度能达到171 GB&#x2F;s。</p><p>5、支持云原生容器化部署：MinIO提供了与K8s、ETCD、Docker等容器化技术深度集成方案，可以说MinIO就是为云环境而生的。</p><p>6、提供多语言SDK的支持：MinIO提供了绝大部分主流开发语言的SDK以及文档，比如Java、Python、Golang、JS、.NET等等。</p><p>7、兼容亚马逊S3 API：亚马逊云的 S3 API（接口协议） 是在全球范围内达到共识的对象存储的协议，是全世界认可的对象存储标准。而MinIO是采用S3兼容协议的产品之一。</p><ul><li><strong>S3协议</strong>是Amazon Web Services (AWS) 提供的对象存储服务（Simple Storage Service）的API协议。它是一种 RESTful风格的Web服务接口，使用HTTP&#x2F;HTTPS协议进行通信，支持多种编程语言和操作系统，并实现了数据的可靠存储、高扩展性以及良好的可用性。</li></ul><h3 id="2-Minio安装"><a href="#2-Minio安装" class="headerlink" title="2. Minio安装"></a>2. Minio安装</h3><p>官网地址：<a href="https://www.minio.org.cn/docs/cn/minio/container/index.html">https://www.minio.org.cn/docs/cn/minio/container/index.html</a></p><h4 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h4><p>1、下载Minio安装文件</p><ul><li>地址：<a href="https://dl.min.io/server/minio/release/">https://dl.min.io/server/minio/release/</a></li></ul><p>2、进入到Monio所在目录，启动Minio</p><ul><li><p>启动命令： minio.exe  server  数据文件目录</p><p>例如：minion.exe server E:\minio\data</p></li><li><p>访问控制台</p><p><a href="http://127.0.0.1:9000/login">http://127.0.0.1:9000/login</a> （端口号不一定是）</p><p>默认账户和密码：minioadmin &#x2F; minioadmin</p></li></ul><h4 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h4><p>具体命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拉取镜像</span></span><br><span class="line">docker pull quay.io/minio/minio</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建数据存储目录</span></span><br><span class="line">mkdir -p ~/minio/data</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建minio</span></span><br><span class="line">docker run \</span><br><span class="line">   -p <span class="number">9001</span>:<span class="number">9000</span> \</span><br><span class="line">   -p <span class="number">9090</span>:<span class="number">9090</span> \</span><br><span class="line">   --name minio \</span><br><span class="line">   -v ~/minio/data:/data \</span><br><span class="line">   -e <span class="string">&quot;MINIO_ROOT_USER=admin&quot;</span> \</span><br><span class="line">   -e <span class="string">&quot;MINIO_ROOT_PASSWORD=admin123456&quot;</span> \</span><br><span class="line">   -d \</span><br><span class="line">   quay.io/minio/minio server /data --console-address <span class="string">&quot;:9090&quot;</span></span><br></pre></td></tr></table></figure><h3 id="3-Minio入门"><a href="#3-Minio入门" class="headerlink" title="3. Minio入门"></a>3. Minio入门</h3><p>通过Java客户端操作Minio。</p><p>官网地址：<a href="https://min.io/docs/minio/linux/developers/java/minio-java.html">https://min.io/docs/minio/linux/developers/java/minio-java.html</a></p><p>步骤：</p><p>1、添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 模块中加入该依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.minio<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>minio<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUploadTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用try-catch-finally</span></span><br><span class="line">        <span class="comment">// 创建一个Minio的客户端对象</span></span><br><span class="line">        <span class="type">MinioClient</span> <span class="variable">minioClient</span> <span class="operator">=</span> MinioClient.builder()</span><br><span class="line">                .endpoint(<span class="string">&quot;http://127.0.0.1:9000&quot;</span>)</span><br><span class="line">                .credentials(<span class="string">&quot;minioadmin&quot;</span>, <span class="string">&quot;minioadmin&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断桶是否存在</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> minioClient.bucketExists(BucketExistsArgs.builder().bucket(<span class="string">&quot;yph-bucket&quot;</span>).build());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不存在，那么此时就创建一个新的桶</span></span><br><span class="line">        <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">            minioClient.makeBucket(MakeBucketArgs.builder().bucket(<span class="string">&quot;yph-bucket&quot;</span>).build());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 如果存在打印信息</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Bucket &#x27;yph-bucket&#x27; already exists.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D://01.jpg&quot;</span>) ;</span><br><span class="line">        </span><br><span class="line">        <span class="type">PutObjectArgs</span> <span class="variable">putObjectArgs</span> <span class="operator">=</span> PutObjectArgs.builder()</span><br><span class="line">                .bucket(<span class="string">&quot;yph-bucket&quot;</span>)</span><br><span class="line">                .stream(fis, fis.available(), -<span class="number">1</span>)</span><br><span class="line">                .object(<span class="string">&quot;01.jpg&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        minioClient.putObject(putObjectArgs) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建fileUrl</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileUrl</span> <span class="operator">=</span> <span class="string">&quot;http://127.0.0.1:9000/yph-bucket/01.jpg&quot;</span> ;</span><br><span class="line">        System.out.println(fileUrl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：设置minio的中该桶的访问权限为public</p><p>以上只是基础代码，实践中可以基于此代码进行开发扩展。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在项目学习开发时应用了此技术，对此进行部分总结。&lt;/p&gt;
&lt;p&gt;仅个人总结！&lt;/p&gt;</summary>
    
    
    
    <category term="应用开发" scheme="https://sunrisel135.github.io/blog_lyl/categories/%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Minio" scheme="https://sunrisel135.github.io/blog_lyl/tags/Minio/"/>
    
  </entry>
  
  <entry>
    <title>Java框架面试-MyBatis</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/16/Java%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95-MyBatis/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/16/Java%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95-MyBatis/</id>
    <published>2024-03-16T02:02:04.000Z</published>
    <updated>2024-03-16T02:56:32.400Z</updated>
    
    <content type="html"><![CDATA[<p>持续补充…</p><span id="more"></span><h4 id="–-和-的区别是什么？☆"><a href="#–-和-的区别是什么？☆" class="headerlink" title="– #{} 和 ${} 的区别是什么？☆"></a>– #{} 和 ${} 的区别是什么？☆</h4><ul><li><p>最大的区别就是**#{}方式能够很大程度防止sql注入(安全)，${}方式无法防止Sql注入**。</p></li><li><p><strong>关于#{}</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、#&#123;&#125;表示一个占位符号 相当于 `jdbc`中的 ? 符号</span><br><span class="line">#&#123;&#125;实现的是向prepareStatement中的预处理语句中设置参数值，sql语句中#&#123;&#125;表示一个占位符即?</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、#&#123;&#125;将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、如果sql语句中只有一个参数,此时参数名称可以随意定义。</span><br><span class="line">如果sql语句有多个参数,此时参数名称应该是与当前表关联[实体类的属性名]或则[Map集合关键字]，不能随便写，必须对应！</span><br></pre></td></tr></table></figure><ul><li><strong>关于${}</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ &#123;&#125;将传入的数据直接显示生成在sql中,属于原样文本替换，可以替换任意内容。如：select * from user where id= $ &#123;user_id&#125;，如果传入的值是11,那么解析成sql时的值为where id=11</span><br></pre></td></tr></table></figure><p><strong>什么是SQL注入？</strong></p><p><strong>Sql注入</strong>指的是程序解析时会将你传入的参数作为原来SQL语句的一部分，打乱原来SQL的结构。</p><p>例如，用户在输入密码的时候，输入 ‘’’’ ’ or 1&#x3D;1’’, 这样，后台的程序在解析的时候，拼成的SQL语句，可能是这样的： select count(1) from tab where user&#x3D;userinput and pass&#x3D;’’ or 1&#x3D;1; 看这条语句，可以知道，在解析之后，用户没有输入密码，加了一个恒等的条件 1&#x3D;1，这样，这段SQL执行的时候，返回的 count值肯定大于1的，如果程序的逻辑没加过多的判断，这样就能够使用用户名 userinput登陆，而不需要密码。</p><h4 id="–-xml-映射文件中，除了常见的-select、insert、update、delete-标签之外，还有哪些标签？★"><a href="#–-xml-映射文件中，除了常见的-select、insert、update、delete-标签之外，还有哪些标签？★" class="headerlink" title="– xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签？★"></a>– xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签？★</h4><p><code>&lt;resultMap&gt;</code>、 <code>&lt;parameterMap&gt;</code>、 <code>&lt;sql&gt;</code>、 <code>&lt;include&gt;</code>、 <code>&lt;selectKey&gt;</code> ，加上动态 sql 的 9 个标签， <code>trim|where|set|foreach|if|choose|when|otherwise|bind</code> 等，其中 <code>&lt;sql&gt;</code> 为 sql 片段标签，通过 <code>&lt;include&gt;</code> 标签引入 sql 片段， <code>&lt;selectKey&gt;</code> 为不支持自增的主键生成策略标签。</p><h4 id="–-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？"><a href="#–-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="– Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？?"></a>– Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？?</h4><ul><li><p><strong>Dao 接口里的方法可以重载，但是 Mybatis 的 xml 里面的 ID 不允许重复。</strong></p></li><li><p><strong>Mybatis 的 Dao 接口可以有多个重载方法，但是多个接口对应的映射必须只有一个，否则启动会报错。</strong></p><p><strong>补充</strong>：</p><p>Dao 接口方法可以重载，但是需要满足以下条件：</p><ol><li>仅有一个无参方法和一个有参方法</li><li>多个有参方法时，参数数量必须一致。且使用相同的 <code>@Param</code> ，或者使用 <code>param1</code> 这种</li></ol></li><li><p>Dao 接口的<strong>工作原理</strong>是 JDK 动态代理，MyBatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行 <code>MappedStatement</code> 所代表的 sql，然后将 sql 执行结果返回。</p></li></ul><p>通常一个 xml 映射文件，都会写一个 Dao 接口与之对应。Dao 接口就是人们常说的 <code>Mapper</code> 接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中 <code>MappedStatement</code> 的 id 值，接口方法内的参数，就是传递给 sql 的参数。 <code>Mapper</code> 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个 <code>MappedStatement</code> ，举例：<code>com.mybatis3.mappers. StudentDao.findStudentById</code> ，可以唯一找到 namespace 为 <code>com.mybatis3.mappers. StudentDao</code> 下面 <code>id = findStudentById</code> 的 <code>MappedStatement</code> 。在 MyBatis 中，每一个 <code>&lt;select&gt;</code>、 <code>&lt;insert&gt;</code>、 <code>&lt;update&gt;</code>、 <code>&lt;delete&gt;</code> 标签，都会被解析为一个 <code>MappedStatement</code> 对象。</p><h4 id="–-MyBatis-是如何进行分页的？分页插件的原理是什么？★"><a href="#–-MyBatis-是如何进行分页的？分页插件的原理是什么？★" class="headerlink" title="– MyBatis 是如何进行分页的？分页插件的原理是什么？★"></a>– MyBatis 是如何进行分页的？分页插件的原理是什么？★</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1) MyBatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页；</span><br><span class="line">(2) 可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能</span><br><span class="line">(3) 也可以使用分页插件来完成物理分页。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</span><br><span class="line"></span><br><span class="line">举例：`select _ from student` ，拦截 sql 后重写为：`select t._ from （select \* from student）t limit 0，10</span><br></pre></td></tr></table></figure><h4 id="–-简述-MyBatis-的插件运行原理，以及如何编写一个插件"><a href="#–-简述-MyBatis-的插件运行原理，以及如何编写一个插件" class="headerlink" title="– 简述 MyBatis 的插件运行原理，以及如何编写一个插件"></a>– 简述 MyBatis 的插件运行原理，以及如何编写一个插件</h4><p>MyBatis 仅可以编写针对 <code>ParameterHandler</code>、 <code>ResultSetHandler</code>、 <code>StatementHandler</code>、 <code>Executor</code> 这 4 种接口的插件，MyBatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 <code>InvocationHandler</code> 的 <code>invoke()</code> 方法，当然，只会拦截那些你指定需要拦截的方法。</p><p>实现 MyBatis 的 <code>Interceptor</code> 接口并复写 <code>intercept()</code> 方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p><h4 id="–-MyBatis-执行批量插入，能返回数据库主键列表吗？"><a href="#–-MyBatis-执行批量插入，能返回数据库主键列表吗？" class="headerlink" title="– MyBatis 执行批量插入，能返回数据库主键列表吗？"></a>– MyBatis 执行批量插入，能返回数据库主键列表吗？</h4><p>能，JDBC 都能，MyBatis 当然也能。</p><h4 id="–-MyBatis-动态-sql-是做什么的？都有哪些动态-sql？简述一下动态-sql-的执行原理？☆"><a href="#–-MyBatis-动态-sql-是做什么的？都有哪些动态-sql？简述一下动态-sql-的执行原理？☆" class="headerlink" title="– MyBatis 动态 sql 是做什么的？都有哪些动态 sql？简述一下动态 sql 的执行原理？☆"></a>– MyBatis 动态 sql 是做什么的？都有哪些动态 sql？简述一下动态 sql 的执行原理？☆</h4><p>MyBatis 动态 sql 可以让我们在 xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能。</p><p>其执行原理为，使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。</p><p>MyBatis 提供了 9 种动态 sql 标签:</p><ul><li><code>&lt;if&gt;&lt;/if&gt;</code></li><li><code>&lt;where&gt;&lt;/where&gt;(trim,set)</code></li><li><code>&lt;choose&gt;&lt;/choose&gt;（when, otherwise）</code></li><li><code>&lt;foreach&gt;&lt;/foreach&gt;</code></li><li><code>&lt;bind/&gt;</code></li></ul><h4 id="–-MyBatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？？"><a href="#–-MyBatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？？" class="headerlink" title="– MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？？"></a>– MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？？</h4><p>第一种是使用 <code>&lt;resultMap&gt;</code> 标签，逐一定义列名和对象属性名之间的映射关系。</p><p>第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，MyBatis 会忽略列名大小写，智能找到与之对应对象属性名。</p><p>有了列名与属性名的映射关系后，MyBatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p><h4 id="–-MyBatis-能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？？"><a href="#–-MyBatis-能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？？" class="headerlink" title="– MyBatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？？"></a>– MyBatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？？</h4><p>能，MyBatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把 <code>selectOne()</code> 修改为 <code>selectList()</code> 即可；多对多查询，其实就是一对多查询，只需要把 <code>selectOne()</code> 修改为 <code>selectList()</code> 即可。</p><p>关联对象查询，有两种实现方式，一种是单独发送一个 sql 去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用 join 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值，好处是只发一个 sql 查询，就可以把主对象和其关联对象查出来。</p><p>那么问题来了，join 查询出来 100 条记录，如何确定主对象是 5 个，而不是 100 个？其去重复的原理是 <code>&lt;resultMap&gt;</code> 标签内的 <code>&lt;id&gt;</code> 子标签，指定了唯一确定一条记录的 id 列，MyBatis 根据 <code>&lt;id&gt;</code> 列值来完成 100 条记录的去重复功能， <code>&lt;id&gt;</code> 可以有多个，代表了联合主键的语意。</p><p>同样主对象的关联对象，也是根据这个原理去重复的，尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。</p><h4 id="–-MyBatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#–-MyBatis-是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="– MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？"></a>– MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h4><p>MyBatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，<strong>association 指的就是一对一，collection 指的就是一对多查询</strong>。在 MyBatis 配置文件中，可以配置是否启用延迟加载 <code>lazyLoadingEnabled=true|false</code>。</p><p><strong>原理</strong>是，使用 <code>CGLIB</code> 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 <code>a.getB().getName()</code> ，拦截器 <code>invoke()</code> 方法发现 <code>a.getB()</code> 是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 <code>a.getB().getName()</code> 方法的调用。这就是延迟加载的基本原理。</p><p>当然了，不光是 MyBatis，几乎所有的包括 Hibernate，支持延迟加载的原理都是一样的。</p><h4 id="–-MyBatis-的-xml-映射文件中，不同的-xml-映射文件，id-是否可以重复？"><a href="#–-MyBatis-的-xml-映射文件中，不同的-xml-映射文件，id-是否可以重复？" class="headerlink" title="– MyBatis 的 xml 映射文件中，不同的 xml 映射文件，id 是否可以重复？"></a>– MyBatis 的 xml 映射文件中，不同的 xml 映射文件，id 是否可以重复？</h4><p>不同的 xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配置 namespace，那么 id 不能重复；毕竟 namespace 不是必须的，只是最佳实践而已。</p><p>原因就是 namespace+id 是作为 <code>Map&lt;String, MappedStatement&gt;</code> 的 key 使用的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然也就不同。</p><h4 id="–-MyBatis-中如何执行批处理？？"><a href="#–-MyBatis-中如何执行批处理？？" class="headerlink" title="– MyBatis 中如何执行批处理？？"></a>– MyBatis 中如何执行批处理？？</h4><p>使用 <code>BatchExecutor</code> 完成批处理。</p><h4 id="–-MyBatis-都有哪些-Executor-执行器？它们之间的区别是什么？？"><a href="#–-MyBatis-都有哪些-Executor-执行器？它们之间的区别是什么？？" class="headerlink" title="– MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？？"></a>– MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？？</h4><p>MyBatis 有三种基本的 <code>Executor</code> 执行器：</p><ul><li><strong><code>SimpleExecutor</code>：</strong> 每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。</li><li><strong><code>ReuseExecutor</code>：</strong> 执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用 Statement 对象。</li><li>**<code>BatchExecutor</code>**：执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理。与 JDBC 批处理相同。</li></ul><p>作用范围：<code>Executor</code> 的这些特点，都严格限制在 SqlSession 生命周期范围内。</p><p><strong>如何指定使用哪一种 Executor 执行器？</strong></p><p>在 MyBatis 配置文件中，可以指定默认的 <code>ExecutorType</code> 执行器类型，也可以手动给 <code>DefaultSqlSessionFactory</code> 的创建 SqlSession 的方法传递 <code>ExecutorType</code> 类型参数。</p><h4 id="–-MyBatis-是否可以映射-Enum-枚举类？"><a href="#–-MyBatis-是否可以映射-Enum-枚举类？" class="headerlink" title="– MyBatis 是否可以映射 Enum 枚举类？"></a>– MyBatis 是否可以映射 Enum 枚举类？</h4><p>MyBatis 可以映射枚举类，不单可以映射枚举类，<strong>MyBatis 可以映射任何对象到表的一列上</strong>。映射方式为自定义一个 <code>TypeHandler</code> ，实现 <code>TypeHandler</code> 的 <code>setParameter()</code> 和 <code>getResult()</code> 接口方法。 <code>TypeHandler</code> 有两个作用：</p><ul><li>一是完成从 javaType 至 jdbcType 的转换；</li><li>二是完成 jdbcType 至 javaType 的转换，体现为 <code>setParameter()</code> 和 <code>getResult()</code> 两个方法，分别代表设置 sql 问号占位符参数和获取列查询结果。</li></ul><h4 id="–-MyBatis-映射文件中，如果-A-标签通过-include-引用了-B-标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在-A-标签的前面？？"><a href="#–-MyBatis-映射文件中，如果-A-标签通过-include-引用了-B-标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在-A-标签的前面？？" class="headerlink" title="– MyBatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？？"></a>– MyBatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？？</h4><p>虽然 MyBatis 解析 xml 映射文件是按照顺序解析的，但是，被引用的 B 标签依然<strong>可以</strong>定义在任何地方，MyBatis 都可以正确识别。</p><p>原理是，MyBatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，MyBatis 会将 A 标签标记为未解析状态，然后继续解析余下的标签，包含 B 标签，待所有标签解析完毕，MyBatis 会重新解析那些被标记为未解析的标签，此时再解析 A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。</p><h4 id="–-简述-MyBatis-的-xml-映射文件和-MyBatis-内部数据结构之间的映射关系？？"><a href="#–-简述-MyBatis-的-xml-映射文件和-MyBatis-内部数据结构之间的映射关系？？" class="headerlink" title="– 简述 MyBatis 的 xml 映射文件和 MyBatis 内部数据结构之间的映射关系？？"></a>– 简述 MyBatis 的 xml 映射文件和 MyBatis 内部数据结构之间的映射关系？？</h4><p>MyBatis 将所有 xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内部。在 xml 映射文件中， <code>&lt;parameterMap&gt;</code> 标签会被解析为 <code>ParameterMap</code> 对象，其每个子元素会被解析为 ParameterMapping 对象。 <code>&lt;resultMap&gt;</code> 标签会被解析为 <code>ResultMap</code> 对象，其每个子元素会被解析为 <code>ResultMapping</code> 对象。每一个 <code>&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;</code> 标签均会被解析为 <code>MappedStatement</code> 对象，标签内的 sql 会被解析为 BoundSql 对象。</p><h4 id="–-为什么说-MyBatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？☆"><a href="#–-为什么说-MyBatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？☆" class="headerlink" title="– 为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？☆"></a>– 为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？☆</h4><p>Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 MyBatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;持续补充…&lt;/p&gt;</summary>
    
    
    
    <category term="MyBatis" scheme="https://sunrisel135.github.io/blog_lyl/categories/MyBatis/"/>
    
    
    <category term="面试" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java框架面试-SpringBoot自动装配原理</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/15/Java%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95-SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/15/Java%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95-SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/</id>
    <published>2024-03-15T08:26:30.000Z</published>
    <updated>2024-03-16T01:59:03.349Z</updated>
    
    <content type="html"><![CDATA[<p>可以从以下几个方面回答：</p><ol><li>什么是 SpringBoot 自动装配？</li><li>SpringBoot 是如何实现自动装配的？如何实现按需加载？</li><li>如何实现一个 Starter？</li></ol><p>参考：[浅谈SpringBoot自动装配 - 知乎 (zhihu.com)](<a href="https://zhuanlan.zhihu.com/p/619813073#:~:text=%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D">https://zhuanlan.zhihu.com/p/619813073#:~:text=什么是自动装配</a> 自动装配是指在不需要显式配置的情况下，Spring,Boot能够自动完成组件之间的依赖注入。 这种方式通过分析应用程序中的类路径，找到可以提供所需服务的Bean，并将它们自动地注入到目标Bean中，从而消除了手动配置的麻烦。)</p><span id="more"></span><h4 id="–-什么是-SpringBoot-自动装配？"><a href="#–-什么是-SpringBoot-自动装配？" class="headerlink" title="– 什么是 SpringBoot 自动装配？"></a>– 什么是 SpringBoot 自动装配？</h4><p>指<strong>在不需要显式配置的情况下，Spring Boot能够自动完成组件之间的依赖注入</strong>。这种方式通过分析应用程序中的类路径，找到可以提供所需服务的Bean，并将它们自动地注入到目标Bean中，从而消除了手动配置的麻烦。</p><ul><li>早在Spring Framework 就实现了这个功能。Spring Boot 只是在其基础上，通过 SPI 的方式，做了进一步优化。</li><li>没有 Spring Boot 的情况下，如果我们需要引入第三方依赖，需要手动配置，非常麻烦。但是，Spring Boot 中，我们直接引入一个 starter 即可。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpringBoot 定义了一套接口规范，这套规范规定：SpringBoot 在启动时会扫描外部引用 jar 包中的META-INF/spring.factories文件，将文件中配置的类型信息加载到 Spring 容器（此处涉及到 JVM 类加载机制与 Spring 的容器知识），并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。</span><br></pre></td></tr></table></figure><h4 id="–-SpringBoot-是如何实现自动装配的？★"><a href="#–-SpringBoot-是如何实现自动装配的？★" class="headerlink" title="– SpringBoot 是如何实现自动装配的？★"></a>– SpringBoot 是如何实现自动装配的？★</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">总结：</span><br><span class="line">Spring Boot 通过 @EnableAutoConfiguration 开启自动装配，通过 SpringFactoriesLoader 最终加载 META-INF/spring.factories 中的自动配置类实现自动装配，自动配置类其实就是通过@Conditional按需加载的配置类，想要其生效必须引入spring-boot-starter-xxx包实现起步依赖。</span><br></pre></td></tr></table></figure><p>SpringBoot 的核心注解 <strong><code>SpringBootApplication</code></strong></p><p>可以把 <code>@SpringBootApplication</code>看作是 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合。</p><ul><li><code>@EnableAutoConfiguration</code>：<strong>启用 SpringBoot 的自动配置</strong>机制</li><li><code>@Configuration</code>：<strong>允许在上下文中注册额外的 bean 或导入其他配置</strong>类</li><li><code>@ComponentScan</code>：<strong>扫描</strong>被<code>@Component</code> (<code>@Service</code>,<code>@Controller</code>)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean。</li></ul><h5 id="EnableAutoConfiguration-实现自动装配的核心注解"><a href="#EnableAutoConfiguration-实现自动装配的核心注解" class="headerlink" title="@EnableAutoConfiguration:实现自动装配的核心注解"></a><code>@EnableAutoConfiguration</code>:实现自动装配的核心注解</h5><p>自动装配核心功能的实现实际是通过 <code>AutoConfigurationImportSelector</code>类。</p><h5 id="AutoConfigurationImportSelector-加载自动装配类"><a href="#AutoConfigurationImportSelector-加载自动装配类" class="headerlink" title="AutoConfigurationImportSelector:加载自动装配类"></a><code>AutoConfigurationImportSelector</code>:加载自动装配类</h5><p>根据此类的继承关系可以看出，<code>AutoConfigurationImportSelector</code> 类实现了 <code>ImportSelector</code>接口，也就实现了这个接口中的 <strong><code>selectImports</code>方法</strong>，该方法主要用于<strong>获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中</strong>。</p><p>重点关注其方法中的**<code>getAutoConfigurationEntry()</code>方法**，这个方法主要负责加载自动配置类：</p><p><strong>第 1 步</strong>:</p><p>判断自动装配开关是否打开。默认<code>spring.boot.enableautoconfiguration=true</code>，可在 <code>application.properties</code> 或 <code>application.yml</code> 中设置</p><p><strong>第 2 步</strong>：</p><p>用于获取<code>EnableAutoConfiguration</code>注解中的 <code>exclude</code> 和 <code>excludeName</code>。</p><p><strong>第 3 步</strong></p><p>获取需要自动装配的所有配置类，读取<code>META-INF/spring.factories</code>。</p><p><code>XXXAutoConfiguration</code>的作用就是按需加载组件。</p><p>不光是这个依赖下的<code>META-INF/spring.factories</code>被读取到，所有 Spring Boot Starter 下的<code>META-INF/spring.factories</code>都会被读取到。</p><p>所以，你可以清楚滴看到， druid 数据库连接池的 Spring Boot Starter 就创建了<code>META-INF/spring.factories</code>文件。</p><p>如果，我们自己要创建一个 Spring Boot Starter，这一步是必不可少的。</p><p><strong>第 4 步</strong>：</p><p>筛选，<code>@ConditionalOnXXX</code> 中的所有条件都满足，该类才会生效。</p><h4 id="–-如何实现一个-Starter"><a href="#–-如何实现一个-Starter" class="headerlink" title="– 如何实现一个 Starter"></a>– 如何实现一个 Starter</h4><p>举例：实现自定义线程池</p><p>第一步，创建<code>threadpool-spring-boot-starter</code>工程</p><p>第二步，引入 Spring Boot 相关依赖</p><p>第三步，<strong>创建<code>ThreadPoolAutoConfiguration</code></strong></p><p>第四步，<strong>在<code>threadpool-spring-boot-starter</code>工程的 resources 包下创建<code>META-INF/spring.factories</code>文件</strong></p><p>最后新建工程引入<code>threadpool-spring-boot-starter</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;可以从以下几个方面回答：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;什么是 SpringBoot 自动装配？&lt;/li&gt;
&lt;li&gt;SpringBoot 是如何实现自动装配的？如何实现按需加载？&lt;/li&gt;
&lt;li&gt;如何实现一个 Starter？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考：[浅谈SpringBoot自动装配 - 知乎 (zhihu.com)](&lt;a href=&quot;https://zhuanlan.zhihu.com/p/619813073#:~:text=%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D&quot;&gt;https://zhuanlan.zhihu.com/p/619813073#:~:text=什么是自动装配&lt;/a&gt; 自动装配是指在不需要显式配置的情况下，Spring,Boot能够自动完成组件之间的依赖注入。 这种方式通过分析应用程序中的类路径，找到可以提供所需服务的Bean，并将它们自动地注入到目标Bean中，从而消除了手动配置的麻烦。)&lt;/p&gt;</summary>
    
    
    
    <category term="SpringBoot" scheme="https://sunrisel135.github.io/blog_lyl/categories/SpringBoot/"/>
    
    
    <category term="面试" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Spring&amp;SpringBoot常用注解总结</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/15/Spring-SpringBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%80%BB%E7%BB%93/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/15/Spring-SpringBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%80%BB%E7%BB%93/</id>
    <published>2024-03-15T06:49:25.000Z</published>
    <updated>2024-03-15T08:22:27.666Z</updated>
    
    <content type="html"><![CDATA[<p>Spring&amp;SpringBoot常用注解总结</p><span id="more"></span><h4 id="1-SpringBootApplication"><a href="#1-SpringBootApplication" class="headerlink" title="1. @SpringBootApplication"></a>1. @SpringBootApplication</h4><ul><li><strong>是 Spring Boot 项目的基石，创建 SpringBoot 项目之后会默认在主类加上</strong></li><li>可以把 <code>@SpringBootApplication</code>看作是 <strong><code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合</strong></li><li>这三个注解的作用分别是：<ul><li><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的<strong>自动配置机制</strong></li><li><code>@ComponentScan</code>：扫描被<code>@Component</code> (<code>@Repository</code>,<code>@Service</code>,<code>@Controller</code>)注解的 bean，注解默认会<strong>扫描该类所在的包下所有的类</strong>。</li><li><code>@Configuration</code>：允许在 Spring 上下文中注册额外的 bean 或导入其他配置类</li></ul></li></ul><h4 id="2-Spring-Bean-相关"><a href="#2-Spring-Bean-相关" class="headerlink" title="2. Spring Bean 相关"></a>2. Spring Bean 相关</h4><ul><li><code>@Autowired</code><ul><li><strong>自动导入对象到类中，被注入进的类同样要被 Spring 容器管理</strong>。比如：Service 类注入到 Controller 类中。</li></ul></li><li><code>@Component</code>,<code>@Repository</code>,<code>@Service</code>, <code>@Controller</code><ul><li>使用 <code>@Autowired</code> 注解让 Spring 容器帮我们自动装配 bean。这四个注解作用就是把类标识成可以自动装配的bean的类。</li><li><code>@Component</code>：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li><li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li><li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li><li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。</li></ul></li><li><code>@RestController</code><ul><li><code>@Controller</code>和<code>@ResponseBody</code>的合集，表示<strong>这是个控制器 bean</strong>,并且是<strong>将函数的返回值直接填入 HTTP 响应体中</strong>，是 REST 风格的控制器。</li><li>单独使用 <code>@Controller</code> 不加 <code>@ResponseBody</code>的话一般是用在要<strong>返回一个视图的情况</strong>，这种情况属于比较传统的 Spring MVC 的应用，对应于前后端不分离的情况。<code>@Controller</code> +<code>@ResponseBody</code> <strong>返回 JSON 或 XML 形式数据</strong>。</li></ul></li><li><code>@Scope</code><ul><li>声明 Spring Bean 的<strong>作用域</strong> <code>@Scope(&quot;singleton&quot;)</code></li><li><strong>四种常见的 Spring Bean 的作用域：</strong><ul><li><strong>singleton</strong> : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li><li>prototype : 每次请求都会创建一个新的 bean 实例。</li><li>request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li><li>session : 每一个 HTTP Session 会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li></ul></li></ul></li><li><code>@Configuration</code><ul><li>用来声<strong>明配置类</strong>，可以使用 <code>@Component</code>注解替代，不过使用<code>@Configuration</code>注解声明配置类更加语义化。</li></ul></li></ul><h4 id="3-处理常见的-HTTP-请求类型"><a href="#3-处理常见的-HTTP-请求类型" class="headerlink" title="3.  处理常见的 HTTP 请求类型"></a>3.  处理常见的 HTTP 请求类型</h4><p><strong>5 种常见的请求类型:</strong></p><ul><li><p><strong>GET</strong>：请求从服务器<strong>获取</strong>特定资源。举个例子：<code>GET /users</code>（获取所有学生）</p><p><code>@GetMapping(&quot;users&quot;)</code> 等价于<code>@RequestMapping(value=&quot;/users&quot;,method=RequestMethod.GET)</code></p></li><li><p><strong>POST</strong>：在服务器上<strong>创建</strong>一个新的资源。举个例子：<code>POST /users</code>（创建学生）</p></li><li><p><strong>PUT</strong>：<strong>更新</strong>服务器上的资源（客户端提供更新后的整个资源）。举个例子：<code>PUT /users/12</code>（更新编号为 12 的学生）</p></li><li><p><strong>DELETE</strong>：从服务器<strong>删除</strong>特定的资源。举个例子：<code>DELETE /users/12</code>（删除编号为 12 的学生）</p></li><li><p><strong>PATCH</strong>：更新服务器上的资源（客户端提供更改的属性，可以看做作是部分更新），使用的比较少，这里就不举例子了。</p></li></ul><h4 id="4-前后端传值"><a href="#4-前后端传值" class="headerlink" title="4. 前后端传值"></a>4. 前后端传值</h4><ul><li><p><code>@PathVariable</code> 和 <code>@RequestParam</code></p><ul><li><code>@PathVariable</code>用于获取<strong>路径参数</strong>，<code>@RequestParam</code>用于获取<strong>查询参数</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/klasses/&#123;klassId&#125;/teachers&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Teacher&gt; <span class="title function_">getKlassRelatedTeachers</span><span class="params">(</span></span><br><span class="line"><span class="params">         <span class="meta">@PathVariable(&quot;klassId&quot;)</span> Long klassId,</span></span><br><span class="line"><span class="params">         <span class="meta">@RequestParam(value = &quot;type&quot;, required = false)</span> String type )</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果我们请求的 url 是：/klasses/<span class="number">123456</span>/teachers?type=web</span><br><span class="line">那么我们服务获取到的数据就是：klassId=<span class="number">123456</span>,type=web</span><br></pre></td></tr></table></figure></li><li><p><code>@RequestBody</code></p><ul><li>用于读取 Request 请求（可能是 POST,PUT,DELETE,GET 请求）的 <strong>body</strong> 部分并且<strong>Content-Type 为 application&#x2F;json</strong> 格式的数据，<strong>接收到数据之后会自动将数据绑定到 Java 对象</strong>上去。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/sign-up&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity <span class="title function_">signUp</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Valid</span> UserRegisterRequest userRegisterRequest)</span> &#123;</span><br><span class="line">  userService.save(userRegisterRequest);</span><br><span class="line">  <span class="keyword">return</span> ResponseEntity.ok().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>**一个请求方法只可以有一个<code>@RequestBody</code>，但是可以有多个<code>@RequestParam</code>和<code>@PathVariable</code>**。</li></ul></li></ul><h4 id="5-读取配置信息"><a href="#5-读取配置信息" class="headerlink" title="5. 读取配置信息"></a>5. 读取配置信息</h4><p><strong>很多时候需要将一些常用的配置信息比如阿里云 oss、发送短信、微信认证的相关配置信息等放到配置文件中。</strong></p><p>Spring 提供了哪些方式帮助我们<strong>从配置文件中读取这些配置信息</strong>。<code>application.yml</code></p><ul><li><p><code>@Value</code>(常用)</p></li><li><p>使用 <code>@Value(&quot;$&#123;property&#125;&quot;)</code> <strong>读取比较简单的配置信息</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;wuhan2020&#125;&quot;)</span></span><br><span class="line">String wuhan2020;</span><br></pre></td></tr></table></figure></li><li><p>@<code>ConfigurationProperties</code>(常用)</p><ul><li><p>通过<code>@ConfigurationProperties</code><strong>读取配置信息并与 bean 绑定</strong>。可以像使用普通的 Spring bean 一样，将其注入到类中使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;library&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LibraryProperties</span> &#123;</span><br><span class="line">    <span class="meta">@NotEmpty</span></span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Book&gt; books;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@ToString</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">        String name;</span><br><span class="line">        String description;</span><br><span class="line">    &#125;</span><br><span class="line">  省略getter/setter</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>@PropertySource</code>（不常用）</p><ul><li><p><code>@PropertySource</code>读取指定 properties 文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:website.properties&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebSite</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">  省略getter/setter</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="6-参数校验"><a href="#6-参数校验" class="headerlink" title="6. 参数校验"></a>6. 参数校验</h4><ul><li>即使在前端对数据进行校验的情况下，我们还是要对传入后端的数据再进行一遍校验，<strong>避免用户绕过浏览器直接通过一些 HTTP 工具直接向后端请求一些违法数据。</strong></li><li><strong>JSR(Java Specification Requests）</strong> 是一套 JavaBean 参数校验的标准，它定义了很多常用的校验注解，我们可以直接将这些注解加在我们 JavaBean 的属性上面，这样就可以在需要校验的时候进行校验了。</li><li>校验的时候我们实际用的是 <strong>Hibernate Validator</strong> 框架。</li><li>SpringBoot 项目的 <code>spring-boot-starter-web</code> 依赖中已经有 hibernate-validator 包，不需要引用相关依赖。</li><li><strong>所有的注解，推荐使用 JSR 注解，即<code>javax.validation.constraints</code>，而不是<code>org.hibernate.validator.constraints</code></strong></li></ul><h5 id="6-1-常用的字段验证的注解"><a href="#6-1-常用的字段验证的注解" class="headerlink" title="6.1 常用的字段验证的注解"></a>6.1 常用的字段验证的注解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotEmpty</span> 被注释的字符串的不能为 <span class="literal">null</span> 也不能为空</span><br><span class="line"><span class="meta">@NotBlank</span> 被注释的字符串非 <span class="literal">null</span>，并且必须包含一个非空白字符</span><br><span class="line"><span class="meta">@Null</span> 被注释的元素必须为 <span class="literal">null</span></span><br><span class="line"><span class="meta">@NotNull</span> 被注释的元素必须不为 <span class="literal">null</span></span><br><span class="line"><span class="meta">@AssertTrue</span> 被注释的元素必须为 <span class="literal">true</span><span class="meta">@AssertFalse</span> 被注释的元素必须为 <span class="literal">false</span></span><br><span class="line"><span class="meta">@Pattern(regex=,flag=)</span>被注释的元素必须符合指定的正则表达式</span><br><span class="line"><span class="meta">@Email</span> 被注释的元素必须是 Email 格式。</span><br><span class="line"><span class="meta">@Min(value)</span>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</span><br><span class="line"><span class="meta">@DecimalMax(value)</span> 被注释的元素必须是一个数字，其值必须小于等于指定的最大值<span class="meta">@Size(max=, min=)</span>被注释的元素的大小必须在指定的范围内<span class="meta">@Digits(integer, fraction)</span>被注释的元素必须是一个数字，其值必须在可接受的范围内</span><br><span class="line"><span class="meta">@Past</span>被注释的元素必须是一个过去的日期<span class="meta">@Future</span> 被注释的元素必须是一个将来的日期</span><br></pre></td></tr></table></figure><h5 id="6-2-验证请求体-RequestBody"><a href="#6-2-验证请求体-RequestBody" class="headerlink" title="6.2 验证请求体(RequestBody)"></a>6.2 验证请求体(RequestBody)</h5><ul><li>我们在需要验证的参数上加上了**<code>@Valid</code>**注解，如果验证失败，它将抛出<code>MethodArgumentNotValidException</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;classId 不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String classId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Size(max = 33)</span></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;name 不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pattern(regexp = &quot;((^Man$|^Woman$|^UGM$))&quot;, message = &quot;sex 值不在可选范围&quot;)</span></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;sex 不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Email(message = &quot;email 格式不正确&quot;)</span></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;email 不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/person&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Person&gt; <span class="title function_">getPerson</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Valid</span> Person person)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok().body(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-3-验证请求参数-Path-Variables-和-Request-Parameters"><a href="#6-3-验证请求参数-Path-Variables-和-Request-Parameters" class="headerlink" title="6.3 验证请求参数(Path Variables 和 Request Parameters)"></a>6.3 验证请求参数(Path Variables 和 Request Parameters)</h5><ul><li><strong>一定不要忘记在类上加上 <code>@Validated</code> 注解，这个参数可以告诉 Spring 去校验方法参数！</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/person/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Integer&gt; <span class="title function_">getPersonByID</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="meta">@Max(value = 5,message = &quot;超过 id 的范围了&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok().body(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-全局处理-Controller-层异常"><a href="#7-全局处理-Controller-层异常" class="headerlink" title="7. 全局处理 Controller 层异常"></a>7. 全局处理 Controller 层异常</h4><p> Spring 项目必备的全局处理 Controller 层异常。</p><p><strong>相关注解：</strong></p><ol><li><code>@ControllerAdvice</code> :注解<strong>定义全局异常处理类</strong></li><li><code>@ExceptionHandler</code> :注解<strong>声明异常处理方法</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求参数异常处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; handleMethodArgumentNotValidException(MethodArgumentNotValidException ex, HttpServletRequest request) &#123;</span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-JPA-相关-？"><a href="#8-JPA-相关-？" class="headerlink" title="8. JPA 相关 ？"></a>8. JPA 相关 ？</h4><h5 id="8-1-创建表"><a href="#8-1-创建表" class="headerlink" title="8.1 创建表"></a>8.1 创建表</h5><ul><li><code>@Entity</code>声明一个类对应一个数据库实体。</li><li><code>@Table</code> 设置表名</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;role&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Role</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    省略getter/setter......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8-2-创建主键"><a href="#8-2-创建主键" class="headerlink" title="8.2 创建主键"></a>8.2 创建主键</h5><ul><li><code>@Id</code>：声明一个字段为主键。</li><li>使用<code>@Id</code>声明之后，我们还需要定义主键的生成策略。我们可以使用 <code>@GeneratedValue</code> 指定主键生成策略。？？<code>@GeneratedValue</code>注解默认使用的策略是<code>GenerationType.AUTO</code></li><li>JPA 使用枚举定义了 4 种常见的主键生成策略，</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">GenerationType</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用一个特定的数据库表格来保存主键</span></span><br><span class="line"><span class="comment">     * 持久化引擎通过关系数据库的一张特定的表格来生成主键,</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *在某些数据库中,不支持主键自增长,比如Oracle、PostgreSQL其提供了一种叫做&quot;序列(sequence)&quot;的机制生成主键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SEQUENCE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主键自增长</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IDENTITY,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *把主键生成策略交给持久化引擎(persistence engine),</span></span><br><span class="line"><span class="comment">     *持久化引擎会根据数据库在以上三种主键生成 策略中选择其中一种</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AUTO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 MySQL 数据库的话，一般使用<code>GenerationType.IDENTITY</code>策略比较普遍一点（分布式系统的话需要另外考虑使用分布式 ID）。</li></ul><h5 id="8-3-设置字段类型"><a href="#8-3-设置字段类型" class="headerlink" title="8.3 设置字段类型"></a>8.3 设置字段类型</h5><ul><li><code>@Column</code> 声明字段。</li></ul><p><strong>示例：</strong></p><p>设置属性 userName 对应的数据库字段名为 user_name，长度为 32，非空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Column(name = &quot;user_name&quot;, nullable = false, length=32)</span></span><br><span class="line"><span class="keyword">private</span> String userName;</span><br></pre></td></tr></table></figure><p>设置字段类型并且加默认值，这个还是挺常用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Column(columnDefinition = &quot;tinyint(1) default 1&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Boolean enabled;</span><br></pre></td></tr></table></figure><h5 id="8-4-指定不持久化特定字段"><a href="#8-4-指定不持久化特定字段" class="headerlink" title="8.4 指定不持久化特定字段"></a>8.4 指定不持久化特定字段</h5><ul><li><code>@Transient</code>：声明不需要与数据库映射的字段，在保存的时候不需要保存进数据库 。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity(name=&quot;USER&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">private</span> String secrect; <span class="comment">// not persistent because of @Transient</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其他方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String secrect; </span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">secrect</span> <span class="operator">=</span> <span class="string">&quot;Satish&quot;</span>; </span><br><span class="line"><span class="keyword">transient</span> String secrect;</span><br></pre></td></tr></table></figure><h5 id="8-5-声明大字段"><a href="#8-5-声明大字段" class="headerlink" title="8.5 声明大字段"></a>8.5 声明大字段</h5><ul><li><code>@Lob</code>:声明某个字段为大字段。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Lob</span></span><br><span class="line"><span class="comment">//指定 Lob 类型数据的获取策略， FetchType.EAGER 表示非延迟加载，而 FetchType.LAZY 表示延迟加载 ；</span></span><br><span class="line"><span class="meta">@Basic(fetch = FetchType.EAGER)</span></span><br><span class="line"><span class="comment">//columnDefinition 属性指定数据表对应的 Lob 字段类型</span></span><br><span class="line"><span class="meta">@Column(name = &quot;content&quot;, columnDefinition = &quot;LONGTEXT NOT NULL&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String content;</span><br></pre></td></tr></table></figure><h5 id="8-6-创建枚举类型的字段"><a href="#8-6-创建枚举类型的字段" class="headerlink" title="8.6 创建枚举类型的字段"></a>8.6 创建枚举类型的字段</h5><p>可以使用枚举类型的字段，不过枚举字段要用<code>@Enumerated</code>注解修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Gender</span> &#123;</span><br><span class="line">    MALE(<span class="string">&quot;男性&quot;</span>),</span><br><span class="line">    FEMALE(<span class="string">&quot;女性&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    Gender(String str)&#123;</span><br><span class="line">        value=str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;role&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Role</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="meta">@Enumerated(EnumType.STRING)</span></span><br><span class="line">    <span class="keyword">private</span> Gender gender;</span><br><span class="line">    省略getter/setter......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据库里面对应存储的是 MALE&#x2F;FEMALE。</p><h5 id="8-7-增加审计功能？"><a href="#8-7-增加审计功能？" class="headerlink" title="8.7 增加审计功能？"></a>8.7 增加审计功能？</h5><ul><li><p>只要继承了 <code>AbstractAuditBase</code>的类都会默认加上下面四个字段。</p></li><li><p>简单介绍一下上面涉及到的一些注解：</p></li><li><ol><li><p><code>@CreatedDate</code>: 表示该字段为创建时间字段，在这个实体被 insert 的时候，会设置值</p></li><li><p><code>@CreatedBy</code> :表示该字段为创建人，在这个实体被 insert 的时候，会设置值</p><p><code>@LastModifiedDate</code>、<code>@LastModifiedBy</code>同理。</p></li></ol></li><li><p><code>@EnableJpaAuditing</code>：开启 JPA 审计功能。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@MappedSuperclass</span></span><br><span class="line"><span class="meta">@EntityListeners(value = AuditingEntityListener.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAuditBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CreatedDate</span></span><br><span class="line">    <span class="meta">@Column(updatable = false)</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> Instant createdAt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LastModifiedDate</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> Instant updatedAt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CreatedBy</span></span><br><span class="line">    <span class="meta">@Column(updatable = false)</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> String createdBy;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LastModifiedBy</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> String updatedBy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对应的审计功能对应地配置类可能是下面这样的（Spring Security 项目）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJpaAuditing</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuditSecurityConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    AuditorAware&lt;String&gt; <span class="title function_">auditorAware</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> () -&gt; Optional.ofNullable(SecurityContextHolder.getContext())</span><br><span class="line">                .map(SecurityContext::getAuthentication)</span><br><span class="line">                .filter(Authentication::isAuthenticated)</span><br><span class="line">                .map(Authentication::getName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8-8-删除-修改数据"><a href="#8-8-删除-修改数据" class="headerlink" title="8.8 删除&#x2F;修改数据"></a>8.8 删除&#x2F;修改数据</h5><p><code>@Modifying</code> 注解提示 JPA 该操作是修改操作,注意还要配合<code>@Transactional</code>注解使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Modifying</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteByUserName</span><span class="params">(String userName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8-9-关联关系"><a href="#8-9-关联关系" class="headerlink" title="8.9 关联关系"></a>8.9 关联关系</h5><ul><li><code>@OneToOne</code> 声明一对一关系</li><li><code>@OneToMany</code> 声明一对多关系</li><li><code>@ManyToOne</code> 声明多对一关系</li><li><code>@ManyToMany</code> 声明多对多关系</li></ul><h4 id="9-事务-Transactional"><a href="#9-事务-Transactional" class="headerlink" title="9. 事务 @Transactional"></a>9. 事务 @Transactional</h4><ul><li>在要开启事务的方法上使用<code>@Transactional</code>注解即可!</li><li>Exception 分为运行时异常 RuntimeException 和非运行时异常。在<code>@Transactional</code>注解中如果不配置<code>rollbackFor</code>属性,那么事务只会在遇到<code>RuntimeException</code>的时候才会回滚,加上<code>rollbackFor=Exception.class</code>,可以让事务在遇到非运行时异常时也回滚。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Transactional</code> 注解一般可以作用在<code>类</code>或者<code>方法</code>上。</p><ul><li><strong>作用于类</strong>：当把<code>@Transactional</code> 注解放在类上时，表示所有该类的 public 方法都配置相同的事务属性信息。</li><li><strong>作用于方法</strong>：当类配置了<code>@Transactional</code>，方法也配置了<code>@Transactional</code>，方法的事务会覆盖类的事务配置信息。</li></ul><h4 id="10-json-数据处理"><a href="#10-json-数据处理" class="headerlink" title="10. json 数据处理"></a>10. json 数据处理</h4><h5 id="10-1-过滤-json-数据"><a href="#10-1-过滤-json-数据" class="headerlink" title="10.1 过滤 json 数据"></a>10.1 过滤 json 数据</h5><p><strong><code>@JsonIgnoreProperties</code> 作用在类上用于过滤掉特定字段不返回或者不解析。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成json时将userRoles属性过滤</span></span><br><span class="line"><span class="meta">@JsonIgnoreProperties(&#123;&quot;userRoles&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String fullName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> List&lt;UserRole&gt; userRoles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>@JsonIgnore</code>一般用于类的属性上，作用和上面的<code>@JsonIgnoreProperties</code> 一样。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String fullName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">   <span class="comment">//生成json时将userRoles属性过滤</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;UserRole&gt; userRoles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="10-2-格式化-json-数据"><a href="#10-2-格式化-json-数据" class="headerlink" title="10.2 格式化 json 数据"></a>10.2 格式化 json 数据</h5><p><code>@JsonFormat</code>一般用来格式化 json 数据。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonFormat(shape=JsonFormat.Shape.STRING, pattern=&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSS&#x27;Z&#x27;&quot;, timezone=&quot;GMT&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Date date;</span><br></pre></td></tr></table></figure><h5 id="10-3-扁平化对象"><a href="#10-3-扁平化对象" class="headerlink" title="10.3 扁平化对象"></a>10.3 扁平化对象</h5><h4 id="11-测试相关"><a href="#11-测试相关" class="headerlink" title="11. 测试相关"></a>11. 测试相关</h4><ul><li><strong><code>@ActiveProfiles</code>一般作用于测试类上， 用于声明生效的 Spring 配置文件。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(webEnvironment = RANDOM_PORT)</span></span><br><span class="line"><span class="meta">@ActiveProfiles(&quot;test&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TestBase</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>@Test</code>声明一个方法为测试方法</strong></li><li><strong><code>@Transactional</code>被声明的测试方法的数据会回滚，避免污染测试数据。</strong></li><li><strong><code>@WithMockUser</code> Spring Security 提供的，用来模拟一个真实用户，并且可以赋予权限。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@WithMockUser(username = &quot;user-id-18163138155&quot;, authorities = &quot;ROLE_TEACHER&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">should_import_student_success</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Spring&amp;amp;SpringBoot常用注解总结&lt;/p&gt;</summary>
    
    
    
    <category term="Java框架" scheme="https://sunrisel135.github.io/blog_lyl/categories/Java%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="知识点" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Java框架面试-Spring</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/15/Java%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95-Spring/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/15/Java%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95-Spring/</id>
    <published>2024-03-15T01:25:22.000Z</published>
    <updated>2024-03-15T03:23:05.174Z</updated>
    
    <content type="html"><![CDATA[<p>持续补充！</p><span id="more"></span><h3 id="【Spring-基础】"><a href="#【Spring-基础】" class="headerlink" title="【Spring 基础】"></a>【Spring 基础】</h3><h4 id="–-什么是-Spring-框架"><a href="#–-什么是-Spring-框架" class="headerlink" title="– 什么是 Spring 框架?"></a>– 什么是 Spring 框架?</h4><p>开源的<strong>轻量级 Java 开发框架</strong>，旨在提高开发人员的开发效率以及系统的可维护性。一般指的都是 Spring Framework。</p><p>支持 IoC（Inversion of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮件，任务，调度，缓存等等）、对单元测试支持比较好、支持 RESTful Java 应用程序的开发.</p><h4 id="–-Spring-包含的模块有哪些？"><a href="#–-Spring-包含的模块有哪些？" class="headerlink" title="– Spring 包含的模块有哪些？"></a>– Spring 包含的模块有哪些？</h4><ol><li><strong>Core Container</strong><ul><li>核心模块，提供 IoC 依赖注入功能的支持。</li><li><strong>spring-core</strong>：Spring 框架基本的核心工具类。</li><li><strong>spring-beans</strong>：提供对 bean 的创建、配置和管理等功能的支持。</li><li><strong>spring-context</strong>：提供对国际化、事件传播、资源加载等功能的支持。</li><li><strong>spring-expression</strong>：提供对表达式语言（Spring Expression Language） SpEL 的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用。</li></ul></li><li><strong>AOP</strong><ul><li><strong>spring-aspects</strong>：该模块为与 AspectJ 的集成提供支持。</li><li><strong>spring-aop</strong>：提供了面向切面的编程实现。</li><li><strong>spring-instrument</strong>：提供了为 JVM 添加代理（agent）的功能。</li></ul></li><li><strong>Data Access&#x2F;Integration</strong><ul><li><strong>spring-jdbc</strong>：提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。</li><li><strong>spring-tx</strong>：提供对事务的支持。</li><li><strong>spring-orm</strong>：提供对 Hibernate、JPA、iBatis 等 ORM 框架的支持。</li><li><strong>spring-oxm</strong>：提供一个抽象层支撑 OXM(Object-to-XML-Mapping)，例如：JAXB、Castor、XMLBeans、JiBX 和 XStream 等。</li><li><strong>spring-jms</strong> : 消息服务。自 Spring Framework 4.1 以后，它还提供了对 spring-messaging 模块的继承。</li></ul></li><li><strong>Spring Web</strong><ul><li><strong>spring-web</strong>：对 Web 功能的实现提供一些最基础的支持。</li><li><strong>spring-webmvc</strong>：提供对 Spring MVC 的实现。</li><li><strong>spring-websocket</strong>：提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。</li><li><strong>spring-webflux</strong>：提供对 WebFlux 的支持。</li></ul></li><li><strong>Messaging</strong><ul><li><strong>spring-messaging</strong> 是从 Spring4.0 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用。</li></ul></li><li><strong>Spring Test</strong></li></ol><h4 id="–-Spring-Spring-MVC-Spring-Boot-之间什么关系"><a href="#–-Spring-Spring-MVC-Spring-Boot-之间什么关系" class="headerlink" title="– Spring,Spring MVC,Spring Boot 之间什么关系?"></a>– Spring,Spring MVC,Spring Boot 之间什么关系?</h4><ul><li><p><strong>Spring</strong> 包含了多个功能模块，其中最重要的是 Spring-Core（主要提供 IoC 依赖注入功能的支持） 模块， Spring 中的其他模块（比如 Spring MVC）的功能实现基本都需要依赖于该模块。</p></li><li><p><strong>Spring MVC</strong> 是 Spring 中的一个很重要的模块，主要赋予 <strong>Spring 快速构建 MVC 架构的 Web 程序</strong>的能力。</p><p>MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p></li><li><p><strong>Spring Boot</strong> 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架。</p></li><li><p><strong>Spring 旨在简化 J2EE 企业应用程序开发。Spring Boot 旨在简化 Spring 开发</strong>（减少配置文件，开箱即用！）。</p></li></ul><h3 id="【Spring-IoC-★】"><a href="#【Spring-IoC-★】" class="headerlink" title="【Spring IoC ★】"></a>【Spring IoC ★】</h3><h4 id="–-对于-Spring-IoC-的了解"><a href="#–-对于-Spring-IoC-的了解" class="headerlink" title="– 对于 Spring IoC 的了解"></a>– 对于 Spring IoC 的了解</h4><p><strong>IoC（Inversion of Control:控制反转）</strong> 是一种设计思想，就是将<strong>原本在程序中手动创建对象的控制权，交由 Spring 框架来管理</strong>。</p><ul><li><strong>控制</strong>：指的是对象创建（实例化、管理）的权力</li><li><strong>反转</strong>：控制权交给外部环境（Spring 框架、IoC 容器）</li></ul><p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。</p><h4 id="–-什么是-Spring-Bean？☆"><a href="#–-什么是-Spring-Bean？☆" class="headerlink" title="– 什么是 Spring Bean？☆"></a>– 什么是 Spring Bean？☆</h4><p><strong>Bean</strong> 代指的就是那些被 IoC 容器所管理的<strong>对象</strong>。</p><p>我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。</p><h4 id="–-将一个类声明为-Bean-的注解有哪些-★"><a href="#–-将一个类声明为-Bean-的注解有哪些-★" class="headerlink" title="– 将一个类声明为 Bean 的注解有哪些?★"></a>– 将一个类声明为 Bean 的注解有哪些?★</h4><ul><li><code>@Component</code>：<strong>通用</strong>的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li><li><code>@Repository</code> : 对应持久层即 <strong>Dao 层</strong>，主要用于数据库相关操作。</li><li><code>@Service</code> : 对应<strong>服务层</strong>，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li><li><code>@Controller</code> : 对应 <strong>Spring MVC 控制层</strong>，主要用于接受用户请求并调用 <code>Service</code> 层返回数据给前端页面。</li></ul><h4 id="–-Component-和-Bean-的区别是什么？"><a href="#–-Component-和-Bean-的区别是什么？" class="headerlink" title="– @Component 和 @Bean 的区别是什么？"></a>– @Component 和 @Bean 的区别是什么？</h4><ul><li><p><code>@Component</code> 注解<strong>作用于类</strong>，而<code>@Bean</code>注解<strong>作用于方法</strong>。</p></li><li><p><code>@Component</code>通常是<strong>通过类路径扫描来自动侦测</strong>以及<strong>自动装配</strong>到 Spring 容器中（我们可以使用 <code>@ComponentScan</code> 注解<strong>定义要扫描的路径</strong>从中找出标识了<strong>需要装配的类自动装配到 Spring 的 bean 容器中</strong>）。</p><p><code>@Bean</code> 注解通常是我们<strong>在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了 Spring 这是某个类的实例</strong>，当我需要用它的时候还给我。</p></li><li><p><code>@Bean</code> 注解比 <code>@Component</code> 注解的<strong>自定义性更强</strong>，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean。比如当我们<strong>引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</strong></p></li></ul><h4 id="–-注入-Bean-的注解有哪些？"><a href="#–-注入-Bean-的注解有哪些？" class="headerlink" title="– 注入 Bean 的注解有哪些？"></a>– 注入 Bean 的注解有哪些？</h4><p>Spring 内置的 <strong>@Autowired</strong> 以及 JDK 内置的 <strong>@Resource</strong> 和 <strong>@Inject</strong> 都可以用于注入 Bean。</p><h4 id="–-Autowired-和-Resource-的区别是什么？"><a href="#–-Autowired-和-Resource-的区别是什么？" class="headerlink" title="– @Autowired 和 @Resource 的区别是什么？"></a>– @Autowired 和 @Resource 的区别是什么？</h4><ul><li><p><code>Autowired</code> 是 Spring 内置的注解，<strong>默认的注入方式为<code>byType</code><strong>（</strong>根据类型进行匹配</strong>），也就是说会优先<strong>根据接口类型去匹配并注入 Bean （接口的实现类）</strong>。</p><p><strong>产生的问题？</strong></p><p>一个接口存在多个实现类，这个时候 Spring 会同时找到多个满足条件的选择，它自己也不知道选哪一个。</p><p><strong>解决:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错，byName 和 byType 都无法匹配到 bean</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br><span class="line"><span class="comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsServiceImpl1;</span><br><span class="line"><span class="comment">// 正确注入  SmsServiceImpl1 对象对应的 bean</span></span><br><span class="line"><span class="comment">// smsServiceImpl1 就是我们上面所说的名称</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;smsServiceImpl1&quot;)</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br></pre></td></tr></table></figure></li><li><p><code>@Resource</code>属于 JDK 提供的注解，**默认注入方式为 <code>byName</code>**。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为<code>byType</code>。</p></li><li><p>当一个接口存在多个实现类的情况下，<code>@Autowired</code> 和<code>@Resource</code>都需要通过名称才能正确匹配到对应的 Bean。<code>Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显式指定名称，<code>@Resource</code>可以通过 <code>name</code> 属性来显式指定名称。</p></li><li><p><code>@Autowired</code> 支持在构造函数、方法、字段和参数上使用。<code>@Resource</code> 主要用于字段和方法上的注入，不支持在构造函数或参数上使用。</p></li></ul><h4 id="–-Bean-的作用域有哪些"><a href="#–-Bean-的作用域有哪些" class="headerlink" title="– Bean 的作用域有哪些?"></a>– Bean 的作用域有哪些?</h4><ul><li><strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。<strong>Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</strong></li><li><strong>prototype</strong> : 每次获取都会创建一个新的 bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li><li><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li><li><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li><li><strong>application&#x2F;global-session</strong> （仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li><li><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</li></ul><p><strong>如何配置 bean 的作用域呢？</strong></p><p>xml 方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注解方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">personPrototype</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="–-Bean-是线程安全的吗？"><a href="#–-Bean-是线程安全的吗？" class="headerlink" title="– Bean 是线程安全的吗？"></a>– Bean 是线程安全的吗？</h4><p>取决于bean的<strong>作用域</strong>和<strong>状态</strong>。</p><p>prototype 作用域下，每次获取都会创建一个新的 bean 实例，不存在资源竞争问题，所以不存在线程安全问题。</p><p><strong>singleton</strong> 作用域下，<strong>IoC 容器中只有唯一的 bean 实例</strong>，可能<strong>会存在资源竞争问题</strong>（取决于 Bean 是否有状态）。如果<strong>这个 bean 是有状态的</strong>话，那就<strong>存在线程安全问题</strong>（<strong>有状态 Bean</strong> 是指<strong>包含可变的成员变量的对象</strong>）。</p><p>不过，<strong>大部分 Bean 实际都是无状态</strong>（没有定义可变的成员变量）的（比如 Dao、Service），这种情况下， Bean 是线程安全的。</p><p><strong>有状态单例 Bean 的线程安全问题</strong>，<strong>解决办法</strong>：</p><ol><li>在 Bean 中尽量避免定义可变的成员变量。</li><li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（<strong>推荐</strong>的一种方式）。</li></ol><h4 id="–-Bean-的生命周期了解么-★"><a href="#–-Bean-的生命周期了解么-★" class="headerlink" title="– Bean 的生命周期了解么?★"></a>– Bean 的生命周期了解么?★</h4><ul><li>Bean 容器<strong>找</strong>到配置文件中 Spring Bean 的定义。</li><li>Bean 容器利用 Java Reflection API <strong>创建</strong>一个 Bean 的<strong>实例</strong>。</li><li>如果涉及到一些属性值 利用 <code>set()</code>方法<strong>设置</strong>一些<strong>属性值</strong>。</li><li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，<strong>传入 Bean 的名字</strong>。</li><li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，<strong>传入 <code>ClassLoader</code>对象的实例</strong>。</li><li>如果 Bean 实现了 <code>BeanFactoryAware</code> 接口，调用 <code>setBeanFactory()</code>方法，<strong>传入 <code>BeanFactory</code>对象的实例</strong>。</li><li>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li><li>如果 Bean 实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li><li>如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法</li><li>当要<strong>销毁 Bean</strong> 的时候，如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li><li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li></ul><h3 id="【Spring-AoP】"><a href="#【Spring-AoP】" class="headerlink" title="【Spring AoP】"></a>【Spring AoP】</h3><h4 id="–-对于-AOP-的了解☆"><a href="#–-对于-AOP-的了解☆" class="headerlink" title="– 对于 AOP 的了解☆"></a>– 对于 AOP 的了解☆</h4><ul><li>AOP(Aspect-Oriented Programming:<strong>面向切面编程</strong>)能够将那些<strong>与业务无关，却为业务模块所共同调用的逻辑或责任</strong>（例如事务处理、日志管理、权限控制等）<strong>封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性</strong>。</li><li>基于<strong>动态代理</strong>的，如果要代理的对象，<strong>实现了某个接口</strong>，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于<strong>没有实现接口的对象</strong>，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理</li><li>也可以使用 <strong>AspectJ</strong> ！</li></ul><h4 id="–-Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#–-Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="– Spring AOP 和 AspectJ AOP 有什么区别？"></a>– Spring AOP 和 AspectJ AOP 有什么区别？</h4><ul><li><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong></li><li>Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</li><li>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</li><li>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。</li></ul><h4 id="–-AspectJ-定义的通知类型有哪些？☆"><a href="#–-AspectJ-定义的通知类型有哪些？☆" class="headerlink" title="– AspectJ 定义的通知类型有哪些？☆"></a>– AspectJ 定义的通知类型有哪些？☆</h4><ul><li><strong>Before</strong>（前置通知）：目标对象的方法调用之前触发</li><li><strong>After</strong> （后置通知）：目标对象的方法调用之后触发</li><li><strong>AfterReturning</strong>（返回通知）：目标对象的方法调用完成，在返回结果值之后触发</li><li><strong>AfterThrowing</strong>（异常通知）：目标对象的方法运行中抛出 &#x2F; 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。</li><li><strong>Around</strong> （环绕通知）：编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法</li></ul><h4 id="–-多个切面的执行顺序如何控制？"><a href="#–-多个切面的执行顺序如何控制？" class="headerlink" title="– 多个切面的执行顺序如何控制？"></a>– 多个切面的执行顺序如何控制？</h4><ol><li>通常使用<code>@Order</code> 注解直接定义切面顺序（值越小优先级越高）</li><li><strong>实现<code>Ordered</code> 接口重写 <code>getOrder</code> 方法</strong></li></ol><h3 id="【Spring-MVC】"><a href="#【Spring-MVC】" class="headerlink" title="【Spring MVC】"></a>【Spring MVC】</h3><h4 id="–-对于-Spring-MVC-了解"><a href="#–-对于-Spring-MVC-了解" class="headerlink" title="– 对于 Spring MVC 了解?"></a>– 对于 Spring MVC 了解?</h4><p>MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过<strong>将业务逻辑、数据、显示分离来组织代码</strong>。</p><p>天生与 Spring 框架集成，Spring MVC 下一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)。</p><h4 id="–-Spring-MVC-的核心组件有哪些？★"><a href="#–-Spring-MVC-的核心组件有哪些？★" class="headerlink" title="– Spring MVC 的核心组件有哪些？★"></a>– Spring MVC 的核心组件有哪些？★</h4><ul><li><strong><code>DispatcherServlet</code><strong>：</strong>核心的中央处理器</strong>，负责接收请求、分发，并给予客户端响应。</li><li><strong><code>HandlerMapping</code><strong>：</strong>处理器映射器</strong>，根据 URL 去匹配查找能处理的 <code>Handler</code> ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li><li><strong><code>HandlerAdapter</code><strong>：</strong>处理器适配器</strong>，根据 <code>HandlerMapping</code> 找到的 <code>Handler</code> ，适配执行对应的 <code>Handler</code>；</li><li><strong><code>Handler</code><strong>：</strong>请求处理器</strong>，处理实际请求的处理器。</li><li><strong><code>ViewResolver</code><strong>：</strong>视图解析器</strong>，根据 <code>Handler</code> 返回的逻辑视图 &#x2F; 视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code> 响应客户端</li></ul><h4 id="–-SpringMVC-工作原理-★"><a href="#–-SpringMVC-工作原理-★" class="headerlink" title="– SpringMVC 工作原理?★"></a>– SpringMVC 工作原理?★</h4><p><strong>流程说明（重要）：</strong></p><ol><li>客户端（浏览器）发送请求， <code>DispatcherServlet</code>拦截请求。</li><li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code> 。<code>HandlerMapping</code> 根据 URL 去匹配查找能处理的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器） ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li><li><code>DispatcherServlet</code> 调用 <code>HandlerAdapter</code>适配器执行 <code>Handler</code> 。</li><li><code>Handler</code> 完成对用户请求的处理后，会返回一个 <code>ModelAndView</code> 对象给<code>DispatcherServlet</code>，<code>ModelAndView</code> 顾名思义，包含了数据模型以及相应的视图的信息。<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li><li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li><li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li><li>把 <code>View</code> 返回给请求者（浏览器）</li></ol><h4 id="–-统一异常处理怎么做？☆"><a href="#–-统一异常处理怎么做？☆" class="headerlink" title="– 统一异常处理怎么做？☆"></a>– 统一异常处理怎么做？☆</h4><p>使用<strong>注解</strong>的方式统一异常处理，具体会使用到 <code>@ControllerAdvice</code> + <code>@ExceptionHandler</code> 这两个注解 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(BaseException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; handleAppException(BaseException ex, HttpServletRequest request) &#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = ResourceNotFoundException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;ErrorReponse&gt; <span class="title function_">handleResourceNotFoundException</span><span class="params">(ResourceNotFoundException ex, HttpServletRequest request)</span> &#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种异常处理方式下，会给所有或者指定的 <code>Controller</code> 织入异常处理的逻辑（AOP），当 <strong><code>Controller</code> 中的方法抛出异常</strong>的时候，由被<code>@ExceptionHandler</code> 注解修饰的方法进行处理。</p><p><code>ExceptionHandlerMethodResolver</code> 中 <code>getMappedMethod</code> 方法决定了异常具体被哪个被 <code>@ExceptionHandler</code> 注解修饰的方法处理异常。</p><p>源代码看出：**<code>getMappedMethod()</code>会首先找到可以匹配处理异常的所有方法信息，然后对其进行从小到大的排序，最后取最小的那一个匹配的方法(即匹配度最高的那个)。**</p><h3 id="【Spring-框架中用到了哪些设计模式？】"><a href="#【Spring-框架中用到了哪些设计模式？】" class="headerlink" title="【Spring 框架中用到了哪些设计模式？】"></a>【Spring 框架中用到了哪些设计模式？】</h3><ul><li><strong>工厂设计模式</strong> : Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li><li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li><li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li><li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li><li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li><li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li><li><strong>适配器模式</strong> : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li><li>……</li></ul><h3 id="【Spring-事务】"><a href="#【Spring-事务】" class="headerlink" title="【Spring 事务】"></a>【Spring 事务】</h3><h4 id="–-Spring-管理事务的方式有几种？"><a href="#–-Spring-管理事务的方式有几种？" class="headerlink" title="– Spring 管理事务的方式有几种？"></a>– Spring 管理事务的方式有几种？</h4><p><strong>编程式事务</strong>：在代码中硬编码(在分布式系统中推荐使用) : 通过 <code>TransactionTemplate</code>或者 <code>TransactionManager</code> 手动管理事务，事务范围过大会出现事务未提交导致超时，因此事务要比锁的粒度更小。</p><p><strong>声明式事务</strong>：在 XML 配置文件中配置或者直接基于注解（单体应用或者简单业务系统推荐使用） : 实际是通过 AOP 实现（基于**<code>@Transactional</code>** 的全注解方式使用最多）</p><h4 id="–-Spring-事务中哪几种事务传播行为-？"><a href="#–-Spring-事务中哪几种事务传播行为-？" class="headerlink" title="– Spring 事务中哪几种事务传播行为?？"></a>– Spring 事务中哪几种事务传播行为?？</h4><p><strong>事务传播行为是为了解决业务层方法之间互相调用的事务问题</strong>。</p><p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p><ul><li><p><strong>1.<code>TransactionDefinition.PROPAGATION_REQUIRED</code></strong></p><p><strong><code>@Transactional</code>注解默认使用</strong>就是这个事务传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</p></li><li><p><strong><code>2.TransactionDefinition.PROPAGATION_REQUIRES_NEW</code></strong></p><p>创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</p></li><li><p><strong>3.<code>TransactionDefinition.PROPAGATION_NESTED</code></strong></p><p>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED</code>。</p></li><li><p><strong>4.<code>TransactionDefinition.PROPAGATION_MANDATORY</code></strong></p><p>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</p></li></ul><p>若是错误的配置以下 3 种事务传播行为，事务将不会发生回滚：</p><ul><li><strong><code>TransactionDefinition.PROPAGATION_SUPPORTS</code></strong>: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li><strong><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code></strong>: 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li><strong><code>TransactionDefinition.PROPAGATION_NEVER</code></strong>: 以非事务方式运行，如果当前存在事务，则抛出异常。</li></ul><h4 id="–-Spring-事务中的隔离级别有哪几种"><a href="#–-Spring-事务中的隔离级别有哪几种" class="headerlink" title="– Spring 事务中的隔离级别有哪几种?"></a>– Spring 事务中的隔离级别有哪几种?</h4><p>和事务传播行为这块一样，为了方便使用，Spring 也相应地定义了一个<strong>枚举类</strong>：<strong>Isolation</strong></p><ul><li><strong><code>TransactionDefinition.ISOLATION_DEFAULT</code></strong> :<strong>使用后端数据库默认的隔离级别</strong>，MySQL 默认采用的 <code>REPEATABLE_READ</code> 隔离级别 Oracle 默认采用的 <code>READ_COMMITTED</code> 隔离级别.</li><li><strong><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code></strong> :最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li><li><strong><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code></strong> : 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li><li><strong><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code></strong> : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li><li><strong><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code></strong> : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul><h4 id="–-Transactional-rollbackFor-Exception-class-注解？"><a href="#–-Transactional-rollbackFor-Exception-class-注解？" class="headerlink" title="– @Transactional(rollbackFor &#x3D; Exception.class)注解？"></a>– @Transactional(rollbackFor &#x3D; Exception.class)注解？</h4><ul><li><p>当 <code>@Transactional</code> 注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。</p></li><li><p><code>@Transactional</code> 注解<strong>默认回滚策略是只有在遇到<code>RuntimeException</code>(运行时异常) 或者 <code>Error</code> 时才会回滚事务，而不会回滚 <code>Checked Exception</code>（受检查异常）</strong>。这是因为 Spring 认为<code>RuntimeException</code>和 Error 是不可预期的错误，而受检异常是可预期的错误，可以通过业务逻辑来处理。</p></li><li><p><strong>修改默认的回滚策略，可以使用 <code>@Transactional</code> 注解的 <code>rollbackFor</code> 和 <code>noRollbackFor</code> 属性来指定哪些异常需要回滚，哪些异常不需要回滚。</strong></p></li></ul><h3 id="【Spring-Data-JPA】？"><a href="#【Spring-Data-JPA】？" class="headerlink" title="【Spring Data JPA】？"></a>【Spring Data JPA】？</h3><p><strong>JPA 重要的是实战！</strong></p><h4 id="–-如何使用-JPA-在数据库中非持久化一个字段？"><a href="#–-如何使用-JPA-在数据库中非持久化一个字段？" class="headerlink" title="– 如何使用 JPA 在数据库中非持久化一个字段？"></a>– 如何使用 JPA 在数据库中非持久化一个字段？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Transient</span><br><span class="line">String transient4; //类中的一个属性</span><br></pre></td></tr></table></figure><h4 id="–-JPA-的审计功能是做什么的？有什么用？"><a href="#–-JPA-的审计功能是做什么的？有什么用？" class="headerlink" title="– JPA 的审计功能是做什么的？有什么用？"></a>– JPA 的审计功能是做什么的？有什么用？</h4><p>主要是帮助我们记录数据库操作的具体行为比如某条记录是谁创建的、什么时间创建的、最后修改人是谁、最后修改时间是什么时候。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@MappedSuperclass</span></span><br><span class="line"><span class="meta">@EntityListeners(value = AuditingEntityListener.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAuditBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CreatedDate</span></span><br><span class="line">    <span class="meta">@Column(updatable = false)</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> Instant createdAt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LastModifiedDate</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> Instant updatedAt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CreatedBy</span></span><br><span class="line">    <span class="meta">@Column(updatable = false)</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> String createdBy;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LastModifiedBy</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> String updatedBy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="–-实体之间的关联关系注解有哪些？"><a href="#–-实体之间的关联关系注解有哪些？" class="headerlink" title="– 实体之间的关联关系注解有哪些？"></a>– 实体之间的关联关系注解有哪些？</h4><ul><li><code>@OneToOne</code> : 一对一。</li><li><code>@ManyToMany</code>：多对多。</li><li><code>@OneToMany</code> : 一对多。</li><li><code>@ManyToOne</code>：多对一。</li></ul><p>利用 <code>@ManyToOne</code> 和 <code>@OneToMany</code> 也可以表达多对多的关联关系。</p><h3 id="【Spring-Security】？"><a href="#【Spring-Security】？" class="headerlink" title="【Spring Security】？"></a>【Spring Security】？</h3><h4 id="–-有哪些控制请求访问权限的方法？"><a href="#–-有哪些控制请求访问权限的方法？" class="headerlink" title="– 有哪些控制请求访问权限的方法？"></a>– 有哪些控制请求访问权限的方法？</h4><ul><li><code>permitAll()</code>：无条件允许任何形式访问，不管你登录还是没有登录。</li><li><code>anonymous()</code>：允许匿名访问，也就是没有登录才可以访问。</li><li><code>denyAll()</code>：无条件决绝任何形式的访问。</li><li><code>authenticated()</code>：只允许已认证的用户访问。</li><li><code>fullyAuthenticated()</code>：只允许已经登录或者通过 remember-me 登录的用户访问。</li><li><code>hasRole(String)</code> : 只允许指定的角色访问。</li><li><code>hasAnyRole(String)</code> : 指定一个或者多个角色，满足其一的用户即可访问。</li><li><code>hasAuthority(String)</code>：只允许具有指定权限的用户访问</li><li><code>hasAnyAuthority(String)</code>：指定一个或者多个权限，满足其一的用户即可访问。</li><li><code>hasIpAddress(String)</code> : 只允许指定 ip 的用户访问。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;持续补充！&lt;/p&gt;</summary>
    
    
    
    <category term="Spring框架" scheme="https://sunrisel135.github.io/blog_lyl/categories/Spring%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="面试" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>数据库面试-Redis</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95-Redis/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95-Redis/</id>
    <published>2024-03-14T01:28:11.000Z</published>
    <updated>2024-03-14T08:47:18.844Z</updated>
    
    <content type="html"><![CDATA[<p>持续补充…</p><span id="more"></span><h3 id="【Redis-基础】"><a href="#【Redis-基础】" class="headerlink" title="【Redis 基础】"></a>【Redis 基础】</h3><h4 id="–-什么是-Redis？"><a href="#–-什么是-Redis？" class="headerlink" title="– 什么是 Redis？"></a>– 什么是 Redis？</h4><p>Redis（REmote DIctionary Server）是一个<strong>基于 C 语言</strong>开发的<strong>开源 NoSQL</strong> 数据库（BSD 许可）。数据保存在内存中的（<strong>内存数据库，支持持久化</strong>），因此读写速度非常快，被广泛应用于分布式缓存方向。并且，Redis 存储的是 <strong>KV 键值对数据</strong>。</p><p>Redis 内置了<strong>多种数据类型</strong>实现（比如 String、Hash、Sorted Set、Bitmap、HyperLogLog、GEO）。并且，Redis 还支持事务、持久化、Lua 脚本、多种开箱即用的集群方案（Redis Sentinel、Redis Cluster）。</p><h4 id="–-Redis-为什么这么快？"><a href="#–-Redis-为什么这么快？" class="headerlink" title="– Redis 为什么这么快？"></a>– Redis 为什么这么快？</h4><p>Redis 基于内存，内存的访问速度是磁盘的上千倍；</p><p>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用（Redis 线程模式后面会详细介绍到）；</p><p>Redis 内置了多种优化过后的数据类型&#x2F;结构实现，性能非常高。</p><h4 id="–-说一下-Redis-和-Memcached-的区别和共同点"><a href="#–-说一下-Redis-和-Memcached-的区别和共同点" class="headerlink" title="– 说一下 Redis 和 Memcached 的区别和共同点"></a>– 说一下 Redis 和 Memcached 的区别和共同点</h4><p><strong>共同点</strong>：</p><ol><li>都是基于内存的数据库，一般都用来当做缓存使用。</li><li>都有过期策略。</li><li>两者的性能都非常高。</li></ol><p><strong>区别</strong>：</p><ol><li><strong>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</strong>。Redis 不仅仅支持简单的 k&#x2F;v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k&#x2F;v 数据类型。</li><li><strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memcached 把数据全部存在内存之中。</strong></li><li><strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</li><li><strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></li><li><strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。</strong></li><li><strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</strong> （Redis 6.0 针对网络数据的读写引入了多线程）</li><li><strong>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</strong></li><li>**Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</li></ol><h4 id="–-为什么要用-Redis-为什么要用缓存？"><a href="#–-为什么要用-Redis-为什么要用缓存？" class="headerlink" title="– 为什么要用 Redis&#x2F;为什么要用缓存？"></a>– 为什么要用 Redis&#x2F;为什么要用缓存？</h4><ul><li>高性能：高频数据且不会经常改变，那么就可以将该数据存在缓存中。操作缓存就是直接操作内存，所以速度相当快。</li><li>高并发：直接操作缓存能够承受的数据库请求数量远远大于直接访问数据库，所以可以考虑把数据库中的部分数据转移到缓存中去，这样一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。</li></ul><h4 id="–-常见的缓存读写策略有哪些？"><a href="#–-常见的缓存读写策略有哪些？" class="headerlink" title="– 常见的缓存读写策略有哪些？"></a>– 常见的缓存读写策略有哪些？</h4><h4 id="–-什么是-Redis-Module？有什么用？"><a href="#–-什么是-Redis-Module？有什么用？" class="headerlink" title="– 什么是 Redis Module？有什么用？"></a>– 什么是 Redis Module？有什么用？</h4><p> 4.0 版本开始，支持通过 Module 来扩展其功能以满足特殊的需求。这些 Module 以动态链接库（so 文件）的形式被加载到 Redis 中，这是一种非常灵活的动态扩展功能的实现方式。</p><h3 id="【Redis-应用】"><a href="#【Redis-应用】" class="headerlink" title="【Redis 应用】"></a>【Redis 应用】</h3><h4 id="–-Redis-除了做缓存，还能做什么？★"><a href="#–-Redis-除了做缓存，还能做什么？★" class="headerlink" title="– Redis 除了做缓存，还能做什么？★"></a>– Redis 除了做缓存，还能做什么？★</h4><ul><li><strong>分布式锁</strong>：通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，都是基于 Redisson 来实现分布式锁。<a href="https://javaguide.cn/distributed-system/distributed-lock.html">分布式锁详解</a></li><li><strong>限流</strong>：一般是通过 Redis + Lua 脚本的方式来实现限流。</li><li><strong>消息队列</strong>：Redis 自带的 List 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</li><li><strong>延时队列</strong>：Redisson 内置了延时队列（基于 Sorted Set 实现的）。</li><li><strong>分布式 Session</strong> ：利用 String 或者 Hash 数据类型保存 Session 数据，所有的服务器都可以访问。</li><li><strong>复杂业务场景</strong>：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 Bitmap 统计活跃用户、通过 Sorted Set 维护排行榜。</li><li>……</li></ul><h4 id="–-如何基于-Redis-实现分布式锁？"><a href="#–-如何基于-Redis-实现分布式锁？" class="headerlink" title="– 如何基于 Redis 实现分布式锁？"></a>– 如何基于 Redis 实现分布式锁？</h4><h4 id="–-Redis-可以做消息队列么？"><a href="#–-Redis-可以做消息队列么？" class="headerlink" title="– Redis 可以做消息队列么？"></a>– Redis 可以做消息队列么？</h4><p>可以是可以，但不建议使用 Redis 来做消息队列。和专业的消息队列相比，还是有很多欠缺的地方。</p><h4 id="–-Redis-可以做搜索引擎么？"><a href="#–-Redis-可以做搜索引擎么？" class="headerlink" title="– Redis 可以做搜索引擎么？"></a>– Redis 可以做搜索引擎么？</h4><p>可以实现全文搜索引擎功能的，需要借助 RediSearch ，这是一个基于 Redis 的搜索引擎模块。</p><p>RediSearch 支持中文分词、聚合统计、停用词、同义词、拼写检查、标签查询、向量相似度查询、多关键词搜索、分页搜索等功能，算是一个功能比较完善的全文搜索引擎了。</p><p>对于小型项目的简单搜索场景来说，使用 RediSearch 来作为搜索引擎还是没有问题的（搭配 RedisJSON 使用）。</p><h4 id="【Redis-数据类型】"><a href="#【Redis-数据类型】" class="headerlink" title="【Redis 数据类型】"></a>【Redis 数据类型】</h4><h4 id="–-Redis-常用的数据类型有哪些？"><a href="#–-Redis-常用的数据类型有哪些？" class="headerlink" title="– Redis 常用的数据类型有哪些？"></a>– Redis 常用的数据类型有哪些？</h4><p>Redis 中比较常见的数据类型有下面这些：</p><ul><li><strong>5 种基础数据类型</strong>：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</li><li><strong>3 种特殊数据类型</strong>：HyperLogLog（基数统计）、Bitmap （位图）、Geospatial (地理位置)。</li></ul><p>除了上面提到的之外，还有一些其他的比如 <a href="https://javaguide.cn/cs-basics/data-structure/bloom-filter.html">Bloom filter（布隆过滤器）open in new window</a>、Bitfield（位域）。</p><h4 id="–-String-的应用场景有哪些？"><a href="#–-String-的应用场景有哪些？" class="headerlink" title="– String 的应用场景有哪些？"></a>– String 的应用场景有哪些？</h4><p>是一种二进制安全的数据类型，可以用来存储<strong>任何类型</strong>的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。</p><p>String 的常见应用场景如下：</p><ul><li>常规数据（比如 <strong>Session、Token、序列化后的对象、图片的路径</strong>）的缓存；</li><li>计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；</li><li>分布式锁(利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁)；</li><li>……</li></ul><h4 id="–-String-还是-Hash-存储对象数据更好呢？"><a href="#–-String-还是-Hash-存储对象数据更好呢？" class="headerlink" title="– String 还是 Hash 存储对象数据更好呢？"></a>– String 还是 Hash 存储对象数据更好呢？</h4><ul><li><strong>String</strong> 存储的是序列化后的对象数据，<strong>存放的是整个对象</strong>。<strong>Hash 是对对象的每个字段单独存储</strong>，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。</li><li><strong>String</strong> 存储相对来说<strong>更加节省内存</strong>，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，String 就非常适合。</li></ul><p>绝大部分情况，建议使用 String 来存储对象数据！</p><h4 id="–-购物车信息用-String-还是-Hash-存储更好呢"><a href="#–-购物车信息用-String-还是-Hash-存储更好呢" class="headerlink" title="– 购物车信息用 String 还是 Hash 存储更好呢?"></a>– 购物车信息用 String 还是 Hash 存储更好呢?</h4><p>由于购物车中的商品频繁修改和变动，购物车信息建议使用 Hash 存储：</p><ul><li>用户 id 为 key</li><li>商品 id 为 field，商品数量为 value</li></ul><p>那用户购物车信息的维护具体应该怎么操作呢？</p><ul><li>用户添加商品就是往 Hash 里面增加新的 field 与 value；</li><li>查询购物车信息就是遍历对应的 Hash；</li><li>更改商品数量直接修改对应的 value 值（直接 set 或者做运算皆可）；</li><li>删除商品就是删除 Hash 中对应的 field；</li><li>清空购物车直接删除对应的 key 即可。</li></ul><p>这里只是以业务比较简单的购物车场景举例，实际电商场景下，field 只保存一个商品 id 是没办法满足需求的。</p><h4 id="–-使用-Redis-实现一个排行榜怎么做？"><a href="#–-使用-Redis-实现一个排行榜怎么做？" class="headerlink" title="– 使用 Redis 实现一个排行榜怎么做？"></a>– 使用 Redis 实现一个排行榜怎么做？</h4><p>Redis 中 <code>Sorted Set</code> （有序集合）的数据类型被用在各种排行榜的场景。</p><p>相关的一些 Redis 命令: <code>ZRANGE</code> (从小到大排序zrange)、 <code>ZREVRANGE</code> （从大到小排序zrevrange）、<code>ZREVRANK</code> (zrevrank指定元素排名)。</p><h4 id="–-Redis-的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者-B-树？"><a href="#–-Redis-的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者-B-树？" class="headerlink" title="– Redis 的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者 B+树？"></a>– Redis 的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者 B+树？</h4><ul><li>跳表诞生的初衷就是为了克服平衡树的一些缺点。跳表使用概率平衡而不是严格强制的平衡，因此，跳表中的插入和删除算法比平衡树的等效算法简单得多，速度也快得多。</li><li>相比较于红黑树来说，跳表的实现也更简单一些，不需要通过旋转和染色（红黑变换）来保证黑平衡。并且，按照区间来查找数据这个操作，红黑树的效率没有跳表高。</li><li>Redis 作为内存数据库它不可能存储大量的数据，所以对于索引不需要通过 B+树这种方式进行维护，只需按照概率进行随机维护即可，节约内存。</li></ul><h4 id="–-Set-的应用场景是什么？"><a href="#–-Set-的应用场景是什么？" class="headerlink" title="–  Set 的应用场景是什么？"></a>–  Set 的应用场景是什么？</h4><p>Redis 中 <code>Set</code> 是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 <code>HashSet</code> 。</p><p><code>Set</code> 的常见应用场景如下：</p><ul><li>存放的<strong>数据不能重复</strong>的场景：网站 UV 统计（数据量巨大的场景还是 <code>HyperLogLog</code>更适合一些）、文章点赞、动态点赞等等。</li><li>需要<strong>获取多个数据源交集、并集和差集</strong>的场景：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集） 等等。</li><li>需要<strong>随机</strong>获取数据源中的元素的场景：抽奖系统、随机点名等等。</li></ul><h4 id="–-使用-Set-实现抽奖系统怎么做？"><a href="#–-使用-Set-实现抽奖系统怎么做？" class="headerlink" title="– 使用 Set 实现抽奖系统怎么做？"></a>– 使用 Set 实现抽奖系统怎么做？</h4><p>如果想要使用 <code>Set</code> 实现一个简单的抽奖系统的话，直接使用下面这几个命令就可以了：</p><ul><li><code>SADD key member1 member2 ...</code>：向指定集合添加一个或多个元素。</li><li><code>SPOP key count</code>：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。</li><li><code>SRANDMEMBER key count</code> : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。</li></ul><h4 id="【Redis-持久化机制（重要）】"><a href="#【Redis-持久化机制（重要）】" class="headerlink" title="【Redis 持久化机制（重要）】"></a>【Redis 持久化机制（重要）】</h4><p><a href="https://zhuanlan.zhihu.com/p/100885432">Redis两种持久化机制RDB和AOF详解（面试常问，工作常用） - 知乎 (zhihu.com)</a></p><p>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式:</p><ul><li>快照（snapshotting，RDB）</li><li>只追加文件（append-only file, AOF）</li><li><strong>RDB 和 AOF 的混合持久化(Redis 4.0 新增)</strong></li></ul><h4 id="–-RDB-持久化"><a href="#–-RDB-持久化" class="headerlink" title="– RDB 持久化"></a>– RDB 持久化</h4><ul><li>通过创建快照来获得存储在内存里面的数据在 <strong>某个时间点</strong> 上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</li><li><strong>快照持久化</strong>是 <strong>Redis 默认采用</strong>的持久化方式</li></ul><p><strong>RDB 创建快照时会阻塞主线程吗？</strong></p><p>Redis 提供了两个命令来生成 RDB 快照文件：</p><ul><li>save : 同步保存操作，会阻塞 Redis 主线程；</li><li>bgsave : fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。</li></ul><h4 id="–-AOF-持久化"><a href="#–-AOF-持久化" class="headerlink" title="– AOF 持久化"></a>– AOF 持久化</h4><p>AOF 持久化的<strong>实时性更好</strong>。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化（<strong>Redis 6.0 之后</strong>已经<strong>默认</strong>是<strong>开启</strong>了），可以通过 <code>appendonly</code> 参数开启。</p><h3 id="【Redis-线程模型（重要）】"><a href="#【Redis-线程模型（重要）】" class="headerlink" title="【Redis 线程模型（重要）】"></a>【Redis 线程模型（重要）】</h3><p>对于读写命令来说，Redis 一直是单线程模型。不过，在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作， Redis 6.0 版本之后引入了多线程来处理网络请求（提高网络 IO 读写性能）。</p><h4 id="–-Redis-单线程模型了解吗？"><a href="#–-Redis-单线程模型了解吗？" class="headerlink" title="– Redis 单线程模型了解吗？"></a>– Redis 单线程模型了解吗？</h4><p>Redis <strong>基于 Reactor 模式</strong>开发了自己的<strong>网络事件处理器</strong>：这个处理器被称为<strong>文件事件处理器</strong>（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 <strong>Redis 是单线程模型</strong>。</p><p><strong>既然是单线程，那怎么监听大量的客户端连接呢？</strong></p><p>Redis 通过 <strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。</p><p>这样的好处：<strong>I&#x2F;O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>。</p><p>文件事件处理器（file event handler）主要是包含 4 个部分：</p><ul><li>多个 socket（客户端连接）</li><li>IO 多路复用程序（支持多个客户端连接的关键）</li><li>文件事件分派器（将 socket 关联到相应的事件处理器）</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><h4 id="–-Redis6-0-之前为什么不使用多线程？"><a href="#–-Redis6-0-之前为什么不使用多线程？" class="headerlink" title="– Redis6.0 之前为什么不使用多线程？"></a>– Redis6.0 之前为什么不使用多线程？</h4><p><strong>Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。</strong>不过，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主线程之外的其他线程来“异步处理”。</p><ul><li>单线程编程容易并且更容易维护；</li><li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li><li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li></ul><h4 id="–-Redis6-0-之后为何引入了多线程？"><a href="#–-Redis6-0-之后为何引入了多线程？" class="headerlink" title="– Redis6.0 之后为何引入了多线程？"></a>– Redis6.0 之后为何引入了多线程？</h4><p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。</p><p>虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。</p><p><strong>Redis6.0</strong> 的多线程<strong>默认是禁用</strong>的，只使用主线程。</p><h4 id="–-Redis-后台线程了解吗？"><a href="#–-Redis-后台线程了解吗？" class="headerlink" title="– Redis 后台线程了解吗？"></a>– Redis 后台线程了解吗？</h4><p> Redis 是单线程模型（主要逻辑是单线程完成的），但实际还有一些后台线程用于执行一些比较耗时的操作：</p><ul><li>通过 <code>bio_close_file</code> 后台线程来释放 AOF &#x2F; RDB 等过程中产生的临时文件资源。</li><li>通过 <code>bio_aof_fsync</code> 后台线程调用 <code>fsync</code> 函数将系统内核缓冲区还未同步到到磁盘的数据强制刷到磁盘（ AOF 文件）。</li><li>通过 <code>bio_lazy_free</code>后台线程释放大对象（已删除）占用的内存空间.</li></ul><h3 id="【Redis-内存管理】"><a href="#【Redis-内存管理】" class="headerlink" title="【Redis 内存管理】"></a>【Redis 内存管理】</h3><h4 id="–-Redis-给缓存数据设置过期时间有啥用？"><a href="#–-Redis-给缓存数据设置过期时间有啥用？" class="headerlink" title="– Redis 给缓存数据设置过期时间有啥用？"></a>– Redis 给缓存数据设置过期时间有啥用？</h4><p>因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。</p><p><strong>Redis 中除了字符串类型有自己独有设置过期时间的命令 <code>setex</code> 外，其他方法都需要依靠 <code>expire</code> 命令来设置过期时间 。另外， <code>persist</code> 命令可以移除一个键的过期时间。</strong></p><h5 id="过期时间除了有助于缓解内存的消耗，还有什么其他用么？"><a href="#过期时间除了有助于缓解内存的消耗，还有什么其他用么？" class="headerlink" title="过期时间除了有助于缓解内存的消耗，还有什么其他用么？"></a>过期时间除了有助于缓解内存的消耗，还有什么其他用么？</h5><p>有些业务场景就是需要<strong>某个数据只在某一时间段内存在</strong>，比如我们的<strong>短信验证码</strong>可能只在 1 分钟内有效，<strong>用户登录的 Token</strong> 可能只在 1 天内有效。</p><p>如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。</p><h4 id="–-Redis-是如何判断数据是否过期的呢？"><a href="#–-Redis-是如何判断数据是否过期的呢？" class="headerlink" title="– Redis 是如何判断数据是否过期的呢？"></a>– Redis 是如何判断数据是否过期的呢？</h4><p>Redis 通过一个叫做<strong>过期字典</strong>（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p><p>键：数据库中的某个key，值：对应的该key的过期时间</p><h4 id="–-过期的数据的删除策略了解么？☆"><a href="#–-过期的数据的删除策略了解么？☆" class="headerlink" title="– 过期的数据的删除策略了解么？☆"></a>– 过期的数据的删除策略了解么？☆</h4><ol><li><strong>惰性删除</strong>：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li><li><strong>定期删除</strong>：每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li></ol><p><strong>定期删除对内存更加友好，惰性删除对 CPU 更加友好</strong>。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性&#x2F;懒汉式删除</strong> 。</p><h4 id="–-Redis-内存淘汰机制了解么？"><a href="#–-Redis-内存淘汰机制了解么？" class="headerlink" title="– Redis 内存淘汰机制了解么？"></a>– Redis 内存淘汰机制了解么？</h4><p>可能存在<strong>定期删除和惰性删除漏掉</strong>了很多<strong>过期 key</strong> 的情况，解决方法就是Redis 内存淘汰机制。</p><p>Redis 提供 6 种数据淘汰策略：</p><ol><li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最近最少使用的数据淘汰。</li><li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选将要过期的数据淘汰。</li><li><strong>volatile-random</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中任意选择数据淘汰。</li><li><strong>allkeys-lru（least recently used）</strong>：<strong>当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</strong>。</li><li><strong>allkeys-random</strong>：从数据集（<code>server.db[i].dict</code>）中任意选择数据淘汰。</li><li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li></ol><p>4.0 版本后增加以下两种：</p><ol><li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最不经常使用的数据淘汰。</li><li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key。</li></ol><h3 id="【Redis-事务】"><a href="#【Redis-事务】" class="headerlink" title="【Redis 事务】"></a>【Redis 事务】</h3><h4 id="–-什么是-Redis-事务？"><a href="#–-什么是-Redis-事务？" class="headerlink" title="– 什么是 Redis 事务？"></a>– 什么是 Redis 事务？</h4><p><strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></p><p>实际开发中使用的非常少，功能比较鸡肋。</p><h4 id="–-Redis-事务支持原子性吗？"><a href="#–-Redis-事务支持原子性吗？" class="headerlink" title="– Redis 事务支持原子性吗？"></a>– Redis 事务支持原子性吗？</h4><p>事务具有四大特性：<strong>1. 原子性</strong>，<strong>2. 隔离性</strong>，<strong>3. 持久性</strong>，<strong>4. 一致性</strong>。</p><p>Redis 事务在运行错误的情况下，<strong>除了执行过程中出现错误的命令外，其他命令都能正常执行。并且，Redis 事务是不支持回滚（roll back）操作的</strong>。因此，Redis 事务其实是<strong>不满足原子性</strong>的。</p><p>为了简单便捷，性能。</p><h4 id="–-Redis-事务支持持久性吗？"><a href="#–-Redis-事务支持持久性吗？" class="headerlink" title="– Redis 事务支持持久性吗？"></a>– Redis 事务支持持久性吗？</h4><p>Redis 不同于 Memcached 的很重要一点就是，<strong>Redis 支持持久化</strong>，而且支持 3 种持久化方式:</p><ul><li>快照（snapshotting，RDB）</li><li>只追加文件（append-only file, AOF）：实时性更好</li><li>RDB 和 AOF 的混合持久化(Redis 4.0 新增)</li></ul><p>三种不同的 AOF 持久化方式：AOF 持久化的<code>fsync</code>策略为 no、everysec 时都会存在数据丢失的情况 。always 下可以基本是可以满足持久性要求的，但性能太差，实际开发过程中不会使用。</p><p>因此，<strong>Redis 事务的持久性也是没办法保证的</strong>。</p><h3 id="【Redis-性能优化（重要）】"><a href="#【Redis-性能优化（重要）】" class="headerlink" title="【Redis 性能优化（重要）】"></a>【Redis 性能优化（重要）】</h3><h4 id="–-使用批量操作减少网络传输"><a href="#–-使用批量操作减少网络传输" class="headerlink" title="– 使用批量操作减少网络传输"></a>– 使用批量操作减少网络传输</h4><p>Redis 命令的执行可以简化为以下 4 步：</p><ol><li>发送命令</li><li>命令排队</li><li>命令执行</li><li>返回结果</li></ol><p>其中，第 1 步和第 4 步耗费时间之和称为 <strong>Round Trip Time (RTT,往返时间)</strong> ，也就是数据在网络上传输的时间</p><h4 id="–-原生批量操作命令"><a href="#–-原生批量操作命令" class="headerlink" title="– 原生批量操作命令"></a>– 原生批量操作命令</h4><h4 id="–-Lua-脚本"><a href="#–-Lua-脚本" class="headerlink" title="– Lua 脚本"></a>– Lua 脚本</h4><h4 id="–-大量-key-集中过期问题"><a href="#–-大量-key-集中过期问题" class="headerlink" title="– 大量 key 集中过期问题"></a>– 大量 key 集中过期问题</h4><ol><li><strong>给 key 设置随机过期时间</strong>。</li><li>开启 lazy-free（惰性删除&#x2F;延迟释放） 。lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</li></ol><p>尽量给 key 设置随机过期时间。</p><h4 id="–-Redis-bigkey（大-Key）"><a href="#–-Redis-bigkey（大-Key）" class="headerlink" title="– Redis bigkey（大 Key）"></a>– Redis bigkey（大 Key）</h4><h5 id="什么是-bigkey？"><a href="#什么是-bigkey？" class="headerlink" title="什么是 bigkey？"></a>什么是 bigkey？</h5><p>一个 key 对应的 <strong>value 所占用的内存</strong>比较大，那这个 key 就可以看作是 bigkey。</p><p>参考标准：</p><ul><li>String 类型的 value 超过 1MB</li><li>复合类型（List、Hash、Set、Sorted Set 等）的 value 包含的元素超过 5000 个（不过，对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）</li></ul><h4 id="–-Redis-hotkey（热-Key）"><a href="#–-Redis-hotkey（热-Key）" class="headerlink" title="– Redis hotkey（热 Key）"></a>– Redis hotkey（热 Key）</h4><h5 id="什么是-hotkey？"><a href="#什么是-hotkey？" class="headerlink" title="什么是 hotkey？"></a>什么是 hotkey？</h5><p>一个 <strong>key 的访问次数</strong>比较多且明显多于其他 key 的话，那这个 key 就可以看作是 <strong>hotkey（热 Key）</strong>。</p><p>如果突然访问 hotkey 的请求超出了 Redis 的处理能力，Redis 就会直接宕机。这种情况下，大量请求将落到后面的数据库上，可能会导致数据库崩溃。</p><p>因此，hotkey 很可能成为系统性能的瓶颈点，需要单独对其进行优化，以确保系统的高可用性和稳定性。</p><h5 id="如何发现-hotkey？"><a href="#如何发现-hotkey？" class="headerlink" title="如何发现 hotkey？"></a>如何发现 hotkey？</h5><h5 id="如何解决-hotkey？"><a href="#如何解决-hotkey？" class="headerlink" title="如何解决 hotkey？"></a>如何解决 hotkey？</h5><p><strong>读写分离</strong>：主节点处理写请求，从节点处理读请求。</p><p><strong>使用 Redis Cluster</strong>：将热点数据分散存储在多个 Redis 节点上。</p><p><strong>二级缓存</strong>：hotkey 采用二级缓存的方式进行处理，将 hotkey 存放一份到 JVM 本地内存中（可以用 Caffeine）。</p><h4 id="–-慢查询命令？"><a href="#–-慢查询命令？" class="headerlink" title="– 慢查询命令？"></a>– 慢查询命令？</h4><ul><li>Redis 慢查询统计的是命令执行这一步骤的耗时，慢查询命令也就是那些命令执行时间较长的命令。</li><li>慢查询，顾名思义，执行很慢的查询。有多慢？超过 long_query_time 参数设定的时间阈值（默认10s），就被认为是慢的，是需要优化的。慢查询被记录在慢查询日志里。</li><li>由于慢查询日志会占用一定内存空间，如果设置最大记录条数过大，可能会导致内存占用过高的问题。</li></ul><h4 id="–-Redis-内存碎片"><a href="#–-Redis-内存碎片" class="headerlink" title="– Redis 内存碎片"></a>– Redis 内存碎片</h4><h5 id="什么是内存碎片-为什么会有-Redis-内存碎片"><a href="#什么是内存碎片-为什么会有-Redis-内存碎片" class="headerlink" title="什么是内存碎片?为什么会有 Redis 内存碎片?"></a>什么是内存碎片?为什么会有 Redis 内存碎片?</h5><p>简单地理解为那些<strong>不可用的空闲内存</strong>。Redis 内存碎片虽然不会影响 Redis 性能，但是会<strong>增加内存消耗</strong>。</p><p>例子：操作系统为你分配了 32 字节的连续内存空间，而你存储数据实际只需要使用 24 字节内存空间，那这多余出来的 8 字节内存空间如果后续没办法再被分配存储其他数据的话，就可以被称为内存碎片。</p><h5 id="为什么会有-Redis-内存碎片"><a href="#为什么会有-Redis-内存碎片" class="headerlink" title="为什么会有 Redis 内存碎片?"></a>为什么会有 Redis 内存碎片?</h5><ul><li>Redis 存储存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。</li><li>频繁修改 Redis 中的数据也会产生内存碎片。（当 Redis 中的某个数据删除时，Redis 通常不会轻易释放内存给操作系统。）</li></ul><h5 id="如何查看-Redis-内存碎片的信息？"><a href="#如何查看-Redis-内存碎片的信息？" class="headerlink" title="如何查看 Redis 内存碎片的信息？"></a>如何查看 Redis 内存碎片的信息？</h5><p><code>info memory</code> 命令</p><h5 id="如何清理-Redis-内存碎片？"><a href="#如何清理-Redis-内存碎片？" class="headerlink" title="如何清理 Redis 内存碎片？"></a>如何清理 Redis 内存碎片？</h5><p>Redis4.0-RC3 版本以后自带了内存整理，可以避免内存碎片率过大的问题。</p><p>直接通过 <code>config set</code> 命令将 <code>activedefrag</code> 配置项设置为 <code>yes</code> 即可。</p><h3 id="【Redis-生产问题（重要）】"><a href="#【Redis-生产问题（重要）】" class="headerlink" title="【Redis 生产问题（重要）】"></a>【Redis 生产问题（重要）】</h3><h4 id="–-缓存穿透"><a href="#–-缓存穿透" class="headerlink" title="– 缓存穿透"></a>– 缓存穿透</h4><p>大量请求的 key 是不合理的，<strong>根本不存在于缓存中，也不存在于数据库中</strong> 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p><p><strong>例子</strong>：某个黑客故意制造一些非法的 key 发起大量请求，导致大量请求落到数据库，结果数据库上也没有查到对应的数据。也就是说这些请求最终都落到了数据库上，对数据库造成了巨大的压力。</p><h5 id="解决办法？"><a href="#解决办法？" class="headerlink" title="解决办法？"></a>解决办法？</h5><p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。</p><ol><li><p><strong>缓存无效 key</strong></p><p>缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下：<code>SET key value EX 10086</code> 。尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p></li><li><p><strong>布隆过滤器</strong>☆</p><p>通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。</p></li><li><p><strong>接口限流</strong>☆</p><p>根据用户或者 IP 对接口进行限流，对于异常频繁的访问行为，还可以采取黑名单机制，例如将异常 IP 列入黑名单。</p></li></ol><h4 id="–-缓存击穿"><a href="#–-缓存击穿" class="headerlink" title="– 缓存击穿"></a>– 缓存击穿</h4><p>请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p><p><strong>例子</strong>：秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。</p><h5 id="解决办法？-1"><a href="#解决办法？-1" class="headerlink" title="解决办法？"></a>解决办法？</h5><ol><li>设置热点数据永不过期或者过期时间比较长。</li><li>针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li><li>请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求会落到数据库上，减少数据库的压力。</li></ol><h4 id="–-缓存穿透和缓存击穿区别？"><a href="#–-缓存穿透和缓存击穿区别？" class="headerlink" title="– 缓存穿透和缓存击穿区别？"></a>– 缓存穿透和缓存击穿区别？</h4><p>缓存穿透：key不存在于缓存或数据库中。</p><p>缓存击穿：请求的 key 对应的是 <strong>热点数据</strong>，数据在缓存中已过期，只存在于数据库中</p><h4 id="–-缓存雪崩"><a href="#–-缓存雪崩" class="headerlink" title="– 缓存雪崩"></a>– 缓存雪崩</h4><p><strong>缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。</strong> </p><p>缓存服务宕机也会导致缓存雪崩现象，导致所有的请求都落到了数据库上。</p><h5 id="缓存预热如何实现？"><a href="#缓存预热如何实现？" class="headerlink" title="缓存预热如何实现？"></a><strong>缓存预热如何实现？</strong></h5><p>常见的缓存预热方式有两种：</p><ol><li>使用定时任务，比如 xxl-job，来定时触发缓存预热的逻辑，将数据库中的热点数据查询出来并存入缓存中。</li><li>使用消息队列，比如 Kafka，来异步地进行缓存预热，将数据库中的热点数据的主键或者 ID 发送到消息队列中，然后由缓存服务消费消息队列中的数据，根据主键或者 ID 查询数据库并更新缓存。</li></ol><h4 id="–-缓存雪崩和缓存击穿有什么区别？"><a href="#–-缓存雪崩和缓存击穿有什么区别？" class="headerlink" title="– 缓存雪崩和缓存击穿有什么区别？"></a>– 缓存雪崩和缓存击穿有什么区别？</h4><p>比较像，但缓存雪崩导致的原因是缓存中的<strong>大量或者所有数据失效</strong>，缓存击穿导致的原因主要是<strong>某个热点数据不存在与缓存中</strong>（通常是因为缓存中的那份数据已经过期）</p><h4 id="–-如何保证缓存和数据库数据的一致性？"><a href="#–-如何保证缓存和数据库数据的一致性？" class="headerlink" title="– 如何保证缓存和数据库数据的一致性？"></a>– 如何保证缓存和数据库数据的一致性？</h4><ol><li><p>缓存失效时间变短（不推荐，治标不治本）</p></li><li><p><strong>增加 cache 更新重试机制（常用）</strong>？</p></li></ol><h4 id="–-哪些情况可能会导致-Redis-阻塞？"><a href="#–-哪些情况可能会导致-Redis-阻塞？" class="headerlink" title="– 哪些情况可能会导致 Redis 阻塞？"></a>– 哪些情况可能会导致 Redis 阻塞？</h4><h3 id="【重要知识点】"><a href="#【重要知识点】" class="headerlink" title="【重要知识点】"></a>【重要知识点】</h3><h4 id="–-3种常用的缓存读写策略详解"><a href="#–-3种常用的缓存读写策略详解" class="headerlink" title="– 3种常用的缓存读写策略详解"></a>– 3种常用的缓存读写策略详解</h4><p><strong>缓存常用的 3 种读写策略</strong></p><ul><li><strong>1. Cache Aside Pattern（旁路缓存模式）</strong><ul><li>Cache Aside Pattern 是我们平时<strong>使用比较多</strong>的一个缓存读写模式，比较适合读请求比较多的场景。</li><li>Cache Aside Pattern 中服务端需要同时维系 <strong>db</strong> 和 <strong>cache</strong>，并且是以 db 的结果为准。</li><li><strong>写</strong>：先更新 db，然后直接删除 cache </li><li><strong>读</strong> ：<ul><li>从 cache 中读取数据，读取到就直接返回</li><li>cache 中读取不到的话，就从 db 中读取数据返回，再把数据放到 cache 中。</li></ul></li></ul></li></ul><h5 id="–在写数据的过程中，可以先删除-cache-，后更新-db-么？"><a href="#–在写数据的过程中，可以先删除-cache-，后更新-db-么？" class="headerlink" title="–在写数据的过程中，可以先删除 cache ，后更新 db 么？"></a>–在写数据的过程中，可以先删除 cache ，后更新 db 么？</h5><p>那肯定是不行的！因为这样可能会造成 <strong>数据库（db）和缓存（Cache）数据不一致</strong>。</p><h5 id="–在写数据的过程中，先更新-db，后删除-cache-就没有问题了么？"><a href="#–在写数据的过程中，先更新-db，后删除-cache-就没有问题了么？" class="headerlink" title="–在写数据的过程中，先更新 db，后删除 cache 就没有问题了么？"></a>–在写数据的过程中，先更新 db，后删除 cache 就没有问题了么？</h5><p>概率非常小，因为缓存的写入速度是比数据库的写入速度快很多。</p><ul><li><p><strong>2. Read&#x2F;Write Through Pattern（读写穿透）</strong></p><ul><li>服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。</li><li><strong>写（Write Through）：</strong><ul><li>先查 cache，cache 中不存在，直接更新 db。</li><li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 db（<strong>同步更新 cache 和 db</strong>）</li></ul></li><li><strong>读(Read Through)：</strong><ul><li>从 cache 中读取数据，读取到就直接返回 。</li><li>读取不到的话，先从 db 加载，写入到 cache 后返回响应。</li></ul></li></ul></li><li><p><strong>3. Write Behind Pattern（异步缓存写入）</strong></p><ul><li><p>Write Behind Pattern 和 Read&#x2F;Write Through Pattern 都是由 cache 服务来负责 cache 和 db 的读写。</p></li><li><p>不同：<strong>Read&#x2F;Write Through 是同步更新 cache 和 db，而 Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。</strong></p></li><li><p>对数据一致性带来了更大的挑战。</p></li><li><p>消息队列中消息的异步写入磁盘、MySQL 的 Innodb Buffer Pool 机制都用到了这种策略。Write Behind Pattern 下 db 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。</p></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;持续补充…&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://sunrisel135.github.io/blog_lyl/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="面试" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>数据库面试-数据库基础</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</id>
    <published>2024-03-13T02:13:28.000Z</published>
    <updated>2024-03-13T02:14:28.815Z</updated>
    
    <content type="html"><![CDATA[<p>基础概念</p><span id="more"></span><h3 id="【数据库基础】"><a href="#【数据库基础】" class="headerlink" title="【数据库基础】"></a>【数据库基础】</h3><h4 id="–-什么是数据库-数据库管理系统-数据库系统-数据库管理员"><a href="#–-什么是数据库-数据库管理系统-数据库系统-数据库管理员" class="headerlink" title="– 什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?"></a>– 什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?</h4><ul><li><strong>数据库</strong> : 数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。</li><li><strong>数据库管理系统</strong> : 数据库管理系统(Database Management System 简称 DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。</li><li><strong>数据库系统</strong> : 数据库系统(Data Base System，简称 DBS)通常由软件、数据库和数据管理员(DBA)组成。</li><li><strong>数据库管理员</strong> : 数据库管理员(Database Administrator, 简称 DBA)负责全面管理和控制数据库系统。</li></ul><h4 id="–-什么是元组-码-候选码-主码-外码-主属性-非主属性？"><a href="#–-什么是元组-码-候选码-主码-外码-主属性-非主属性？" class="headerlink" title="– 什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？"></a>– 什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？</h4><p><strong>元组</strong>：元组（tuple），<strong>表中的每行</strong>（即数据库中的每条记录）就是一个元组，<strong>每列就是一个属性</strong>。 在二维表里，元组也称为<strong>行</strong>。</p><p><strong>码</strong>：码就是能唯一标识实体的属性，对应表中的<strong>列</strong>。</p><p><strong>候选码</strong>：若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性组为候选码。</p><p><strong>主码</strong> : 主码也叫<strong>主键</strong>。主码是从<strong>候选码中</strong>选出来的。 一<strong>个实体集中只能有一个主码，但可以有多个候选码。</strong></p><p><strong>外码</strong> : 外码也叫<strong>外键</strong>。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。</p><p><strong>主属性</strong>：<strong>候选码中出现过的属性称为主属性</strong>。如果主码是一个属性组，那么属性组中的属性都是主属性。</p><p><strong>非主属性：</strong> <strong>不包含在任何一个候选码中的属性称为非主属性。</strong></p><h4 id="–-什么是-ER-图？"><a href="#–-什么是-ER-图？" class="headerlink" title="– 什么是 ER 图？"></a>– 什么是 ER 图？</h4><p> Entity Relationship Diagram（实体联系图），提供了表示<strong>实体</strong>类型、<strong>属性</strong>和<strong>联系</strong>的方法。</p><h4 id="–-数据库范式了解吗"><a href="#–-数据库范式了解吗" class="headerlink" title="– 数据库范式了解吗?"></a>– 数据库范式了解吗?</h4><ul><li>1NF(第一范式)：属性不可再分。</li><li>2NF(第二范式)：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。</li><li>3NF(第三范式)：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。</li></ul><h4 id="–-主键和外键有什么区别"><a href="#–-主键和外键有什么区别" class="headerlink" title="– 主键和外键有什么区别?"></a>– 主键和外键有什么区别?</h4><ul><li>**主键(主码)**：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。</li><li>**外键(外码)**：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</li></ul><h4 id="–-drop、delete-与-truncate-区别？"><a href="#–-drop、delete-与-truncate-区别？" class="headerlink" title="– drop、delete 与 truncate 区别？"></a>– drop、delete 与 truncate 区别？</h4><p><code>truncate</code> 和 <code>drop</code> 属于 <strong>DDL</strong>(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。</p><p> <code>delete</code> 语句是 <strong>DML</strong> (数据库操作语言)语句，这个操作会放到 rollback segment 中，事务提交之后才生效。</p><ul><li><code>drop</code>(丢弃数据): <code>drop table 表名</code> ，直接将表都删除掉，在<strong>删除表</strong>的时候使用。</li><li><code>truncate</code> (清空数据) : <code>truncate table 表名</code> ，只<strong>删除表中的数据</strong>，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。</li><li><code>delete</code>（删除数据） : <code>delete from 表名 where 列名=值</code>，<strong>删除某一行的数据</strong>，如果不加 <code>where</code> 子句和<code>truncate table 表名</code>作用类似。</li></ul><h3 id="【NoSQL基础知识】"><a href="#【NoSQL基础知识】" class="headerlink" title="【NoSQL基础知识】"></a>【NoSQL基础知识】</h3><h4 id="–-NoSQL-是什么？"><a href="#–-NoSQL-是什么？" class="headerlink" title="– NoSQL 是什么？"></a>– NoSQL 是什么？</h4><p>NoSQL（Not Only SQL 的缩写）泛指<strong>非关系型的数据库</strong>，主要针对的是<strong>键值</strong>、<strong>文档</strong>以及<strong>图形类型数据</strong>存储。并且，NoSQL 数据库天生<strong>支持分布式</strong>，<strong>数据冗余</strong>和<strong>数据分片</strong>等特性，旨在提供可扩展的高可用高性能数据存储解决方案。</p><p>NoSQL 数据库可以存储关系型数据—它们与关系型数据库的存储方式不同。</p><h4 id="–-NoSQL-数据库有什么优势？"><a href="#–-NoSQL-数据库有什么优势？" class="headerlink" title="– NoSQL 数据库有什么优势？"></a>– NoSQL 数据库有什么优势？</h4><p>NoSQL 数据库非常适合许多现代应用程序，例如移动、Web 和游戏等应用程序，它们需要<strong>灵活</strong>、<strong>可扩展</strong>、<strong>高性能</strong>和<strong>功能强大</strong>的数据库以提供卓越的用户体验。</p><h4 id="–-NoSQL-数据库有哪些类型？"><a href="#–-NoSQL-数据库有哪些类型？" class="headerlink" title="– NoSQL 数据库有哪些类型？"></a>– NoSQL 数据库有哪些类型？</h4><p><strong>键值</strong>：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。</p><p><strong>文档</strong>：文档数据库中的数据被存储在类似于 JSON（JavaScript 对象表示法）对象的文档中，非常清晰直观。</p><p><strong>图形</strong>：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。</p><p><strong>宽列</strong>：宽列存储数据库非常适合需要存储大量的数据。</p><h3 id="【MySQL-字符集】"><a href="#【MySQL-字符集】" class="headerlink" title="【MySQL 字符集】"></a>【MySQL 字符集】</h3><p>MySQL 支持很多种字符集的方式，比如 GB2312、GBK、BIG5、多种 Unicode 字符集（UTF-8 编码、UTF-16 编码、UCS-2 编码、UTF-32 编码等等）。</p><h4 id="–-默认字符集"><a href="#–-默认字符集" class="headerlink" title="– 默认字符集"></a>– 默认字符集</h4><p>在 MySQL5.7 中，默认字符集是 <code>latin1</code> ；在 MySQL8.0 中，默认字符集是 <strong><code>utf8mb4</code></strong></p><h4 id="–-字符集的层次级别"><a href="#–-字符集的层次级别" class="headerlink" title="– 字符集的层次级别"></a>– 字符集的层次级别</h4><p>MySQL 中的字符集有以下的层次级别：</p><ul><li><code>server</code>（MySQL 实例级别）</li><li><code>database</code>（库级别）</li><li><code>table</code>（表级别）</li><li><code>column</code>（字段级别）</li></ul><h4 id="–-UTF-8-使用"><a href="#–-UTF-8-使用" class="headerlink" title="– UTF-8 使用"></a>– UTF-8 使用</h4><p>MySQL 字符编码集中有两套 UTF-8 编码实现：</p><ul><li>**<code>utf8</code>**：<code>utf8</code>编码只支持<code>1-3</code>个字节 。 在 <code>utf8</code> 编码中，中文是占 3 个字节，其他数字、英文、符号占一个字节。但 emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节。</li><li>**<code>utf8mb4</code>**：UTF-8 的完整实现，正版！最多支持使用 4 个字节表示字符，因此，可以用来存储 emoji 符号。</li></ul><p>如果你需要存储<code>emoji</code>类型的数据或者一些比较复杂的文字、繁体字到 MySQL 数据库的话，数据库的编码一定要指定为<code>utf8mb4</code> 而不是<code>utf8</code> ，要不然存储的时候就会报错了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;基础概念&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://sunrisel135.github.io/blog_lyl/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="面试" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>数据库面试-MySQL</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95-MySQL/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95-MySQL/</id>
    <published>2024-03-13T02:11:29.000Z</published>
    <updated>2024-03-14T01:20:37.725Z</updated>
    
    <content type="html"><![CDATA[<p>持续补充…</p><span id="more"></span><h3 id="【MySQL-基础】"><a href="#【MySQL-基础】" class="headerlink" title="【MySQL 基础】"></a>【MySQL 基础】</h3><h4 id="–-什么是关系型数据库？"><a href="#–-什么是关系型数据库？" class="headerlink" title="– 什么是关系型数据库？"></a>– 什么是关系型数据库？</h4><p>关系型数据库（RDB，Relational Database）就是一种<strong>建立在关系模型的基础上的数据库</strong>。<strong>关系模型表明了数据库中所存储的数据之间的联系</strong>（一对一、一对多、多对多）。大部分关系型数据库都支持事务的四大特性(<strong>ACID</strong>)。</p><h4 id="–-什么是-SQL？"><a href="#–-什么是-SQL？" class="headerlink" title="– 什么是 SQL？"></a>– 什么是 SQL？</h4><p>一种结构化查询语言(Structured Query Language)，专门用来与数据库打交道，目的是提供一种从数据库中读写数据的简单有效的方法。</p><p>几乎所有的主流关系数据库都支持 SQL ，适用性非常强。并且，一些非关系型数据库也兼容 SQL 或者使用的是类似于 SQL 的查询语言。</p><h4 id="–-什么是-MySQL？"><a href="#–-什么是-MySQL？" class="headerlink" title="– 什么是 MySQL？"></a>– 什么是 MySQL？</h4><p><strong>MySQL 是一种关系型数据库，主要用于持久化存储我们的系统中的一些数据比如用户信息。</strong></p><p>由于 MySQL 是开源免费并且比较成熟的数据库，因此，MySQL 被大量使用在各种系统中。任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是<strong>3306</strong>。</p><h4 id="–-MySQL-有什么优点？"><a href="#–-MySQL-有什么优点？" class="headerlink" title="– MySQL 有什么优点？"></a>– MySQL 有什么优点？</h4><ol><li>成熟稳定，功能完善。</li><li>开源免费。</li><li>文档丰富，既有详细的官方文档，又有非常多优质文章可供参考学习。</li><li>开箱即用，操作简单，维护成本低。</li><li>兼容性好，支持常见的操作系统，支持多种开发语言。</li><li>社区活跃，生态完善。</li><li>事务支持优秀， InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失，并且，InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的。</li><li>支持分库分表、读写分离、高可用。</li></ol><h4 id="–-MySQL-字段类型"><a href="#–-MySQL-字段类型" class="headerlink" title="– MySQL 字段类型"></a>– MySQL 字段类型</h4><ul><li><strong>数值类型</strong>：整型（TINYINT、SMALLINT、MEDIUMINT、INT 和 BIGINT）、浮点型（FLOAT 和 DOUBLE）、定点型（DECIMAL）</li><li><strong>字符串类型</strong>：CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB 等，最常用的是 CHAR 和 VARCHAR。</li><li><strong>日期时间类型</strong>：YEAR、TIME、DATE、DATETIME 和 TIMESTAMP 等。</li></ul><h4 id="–-整数类型的-UNSIGNED-属性有什么用？unsigned"><a href="#–-整数类型的-UNSIGNED-属性有什么用？unsigned" class="headerlink" title="– 整数类型的 UNSIGNED 属性有什么用？unsigned"></a>– 整数类型的 UNSIGNED 属性有什么用？unsigned</h4><p>MySQL 中的整数类型可以使用可选的 UNSIGNED 属性来<strong>表示不允许负值的无符号整数</strong>。使用 UNSIGNED 属性可以将正整数的上限提高一倍，因为它不需要存储负数值。</p><h4 id="–-CHAR-和-VARCHAR-的区别是什么？★"><a href="#–-CHAR-和-VARCHAR-的区别是什么？★" class="headerlink" title="– CHAR 和 VARCHAR 的区别是什么？★"></a>– CHAR 和 VARCHAR 的区别是什么？★</h4><p>主要区别在于：<strong>CHAR 是定长字符串，VARCHAR 是变长字符串。</strong></p><ul><li><p><strong>CHAR</strong> 在<strong>存储时</strong>会<strong>在右边填充空格</strong>以达到指定的长度，<strong>检索时</strong>会<strong>去掉空格</strong>；</p><p><strong>VARCHAR</strong> 在<strong>存储时</strong>需要使用 1 或 2 个<strong>额外字节记录</strong>字符串的<strong>长度</strong>，<strong>检索时不</strong>需要<strong>处理</strong>。</p></li><li><p><strong>CHAR</strong> 更适合存储<strong>长度较短或者长度都差不多的字符串</strong>，例如 <em>Bcrypt 算法、MD5 算法加密后的密码、身份证号码</em>。</p><p><strong>VARCHAR</strong> 类型适合存储<strong>长度不确定或者差异较大的字符串</strong>，例如<em>用户昵称、文章标题</em>等。</p></li><li><p>CHAR(M) 和 VARCHAR(M) 的 M 都代表能够保存的字符数的最大值，无论是字母、数字还是中文，每个都只占用一个字符。</p></li></ul><h4 id="–-VARCHAR-100-和-VARCHAR-10-的区别是什么？"><a href="#–-VARCHAR-100-和-VARCHAR-10-的区别是什么？" class="headerlink" title="– VARCHAR(100)和 VARCHAR(10)的区别是什么？"></a>– VARCHAR(100)和 VARCHAR(10)的区别是什么？</h4><p> <strong>VARCHAR(100)和 VARCHAR(10)能存储的字符范围不同，但二者存储相同的字符串，所占用磁盘的存储空间其实是一样的。</strong></p><ul><li>VARCHAR (100) <strong>可以满足更大范围的字符存储需求，有更好的业务拓展性</strong>。而 VARCHAR(10)存储<strong>超过 10 个字符时，就需要修改表结构才可以</strong>。</li><li>VARCHAR(100) 会消耗更多的内存。这是因为 VARCHAR 类型在内存中操作时，通常会分配固定大小的内存块来保存值，即使用字符类型中定义的长度。</li></ul><h4 id="–-DECIMAL-和-FLOAT-DOUBLE-的区别是什么？"><a href="#–-DECIMAL-和-FLOAT-DOUBLE-的区别是什么？" class="headerlink" title="– DECIMAL 和 FLOAT&#x2F;DOUBLE 的区别是什么？"></a>– DECIMAL 和 FLOAT&#x2F;DOUBLE 的区别是什么？</h4><p>DECIMAL 和 FLOAT 的区别是：<strong>DECIMAL 是定点数，FLOAT&#x2F;DOUBLE 是浮点数。DECIMAL 可以存储精确的小数值，FLOAT&#x2F;DOUBLE 只能存储近似的小数值。</strong></p><h4 id="–-为什么不推荐使用-TEXT-和-BLOB？"><a href="#–-为什么不推荐使用-TEXT-和-BLOB？" class="headerlink" title="– 为什么不推荐使用 TEXT 和 BLOB？"></a>– 为什么不推荐使用 TEXT 和 BLOB？</h4><p>TEXT 类型类似于 CHAR（0-255 字节）和 VARCHAR（0-65,535 字节），但可以存储更长的字符串，即长文本数据，例如博客内容。</p><p>数据库规范通常不推荐使用 BLOB 和 TEXT 类型，这两种类型具有一些缺点和限制，例如：</p><ul><li>不能有默认值。</li><li>在使用临时表时无法使用内存临时表，只能在磁盘上创建临时表（《高性能 MySQL》书中有提到）。</li><li>检索效率较低。</li><li>不能直接创建索引，需要指定前缀长度。</li><li>可能会消耗大量的网络和 IO 带宽。</li><li>可能导致表上的 DML 操作变慢。</li></ul><h4 id="–-DATETIME-和-TIMESTAMP-的区别是什么？"><a href="#–-DATETIME-和-TIMESTAMP-的区别是什么？" class="headerlink" title="– DATETIME 和 TIMESTAMP 的区别是什么？"></a>– DATETIME 和 TIMESTAMP 的区别是什么？</h4><p>DATETIME 类型没有时区信息，TIMESTAMP 和<strong>时区有关</strong>。</p><p>TIMESTAMP 只需要使用 4 个字节的存储空间，但是 DATETIME 需要耗费 8 个字节的存储空间。但是，这样同样造成了一个问题，Timestamp 表示的时间范围更小。</p><h4 id="–-NULL-和-‘’-的区别是什么？"><a href="#–-NULL-和-‘’-的区别是什么？" class="headerlink" title="– NULL 和 ‘’ 的区别是什么？"></a>– NULL 和 ‘’ 的区别是什么？</h4><p><code>NULL</code> 跟 <code>&#39;&#39;</code>(空字符串)是两个完全不一样的值，区别如下：</p><ul><li><code>NULL</code> 代表一个<strong>不确定的值</strong>,就算是两个 <code>NULL</code>,它俩也不一定相等。例如，<code>SELECT NULL=NULL</code>的结果为 false，但是在我们使用<code>DISTINCT</code>,<code>GROUP BY</code>,<code>ORDER BY</code>时,<code>NULL</code>又被认为是相等的。</li><li><code>&#39;&#39;</code>的<strong>长度是 0，是不占用空间的</strong>，而<code>NULL</code> 是需要占用空间的。</li><li><code>NULL</code> 会<strong>影响聚合函数的结果</strong>。例如，<code>SUM</code>、<code>AVG</code>、<code>MIN</code>、<code>MAX</code> 等聚合函数会忽略 <code>NULL</code> 值。 <code>COUNT</code> 的处理方式取决于参数的类型。如果参数是 <code>*</code>(<code>COUNT(*)</code>)，则会统计所有的记录数，包括 <code>NULL</code> 值；如果参数是某个字段名(<code>COUNT(列名)</code>)，则会忽略 <code>NULL</code> 值，只统计非空值的个数。</li><li>查询 <code>NULL</code> 值时，必须<strong>使用 <code>IS NULL</code> 或 <code>IS NOT NULLl</code> 来判断</strong>，而不能使用 &#x3D;、!&#x3D;、 &lt;、&gt; 之类的比较运算符。而<code>&#39;&#39;</code>是可以使用这些比较运算符的。</li></ul><p>看了上面的介绍之后，相信你对另外一个高频面试题：“<strong>为什么 MySQL 不建议使用 <code>NULL</code> 作为列默认值？</strong>”也有了答案。</p><h4 id="–-Boolean-类型如何表示？tinyint-1"><a href="#–-Boolean-类型如何表示？tinyint-1" class="headerlink" title="– Boolean 类型如何表示？tinyint(1)"></a>– Boolean 类型如何表示？tinyint(1)</h4><p>MySQL 中没有专门的布尔类型，而是用 <strong>TINYINT(1)</strong> 类型来表示布尔值。<strong>TINYINT(1) 类型可以存储 0 或 1，分别对应 false 或 true。</strong></p><h3 id="【MySQL-基础架构】"><a href="#【MySQL-基础架构】" class="headerlink" title="【MySQL 基础架构】"></a>【MySQL 基础架构】</h3><h4 id="–-SQL-语句在-MySQL-中的执行过程-★"><a href="#–-SQL-语句在-MySQL-中的执行过程-★" class="headerlink" title="– SQL 语句在 MySQL 中的执行过程 ★"></a>– <a href="https://javaguide.cn/database/mysql/how-sql-executed-in-mysql.html">SQL 语句在 MySQL 中的执行过程</a> ★</h4><ul><li>MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用，redolog 只有 InnoDB 有。</li><li>引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。</li><li>查询语句的执行流程如下：权限校验（如果命中缓存）—&gt;查询缓存—&gt;分析器—&gt;优化器—&gt;权限校验—&gt;执行器—&gt;引擎</li><li>更新语句执行流程如下：分析器—-&gt;权限校验—-&gt;执行器—&gt;引擎—redo log(prepare 状态)—&gt;binlog—&gt;redo log(commit 状态)</li></ul><h4 id="–-基础架构"><a href="#–-基础架构" class="headerlink" title="– 基础架构"></a>– 基础架构</h4><ol><li><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li><li><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li><li><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li><li><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</li><li><strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。</li><li><strong>插件式存储引擎</strong>：主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。</li></ol><h3 id="【MySQL-存储引擎】"><a href="#【MySQL-存储引擎】" class="headerlink" title="【MySQL 存储引擎】"></a>【MySQL 存储引擎】</h3><h4 id="–-MySQL-支持哪些存储引擎？默认使用哪个？"><a href="#–-MySQL-支持哪些存储引擎？默认使用哪个？" class="headerlink" title="– MySQL 支持哪些存储引擎？默认使用哪个？"></a>– MySQL 支持哪些存储引擎？默认使用哪个？</h4><p> <code>SHOW ENGINES</code> 命令来查看 MySQL 支持的所有存储引擎。</p><p> <code>SELECT VERSION()</code> 命令查看你的 MySQL 版本。</p><p><code>SHOW VARIABLES LIKE &#39;%storage_engine%&#39;</code> 命令直接查看 MySQL 当前默认的存储引擎。</p><ul><li>MySQL 5.5.5 之前，<strong>MyISAM</strong> 是 MySQL 的默认存储引擎。</li><li><strong>5.5.5 版本</strong>之后，<strong>InnoDB</strong> 是 MySQL 的默认存储引擎。</li></ul><h4 id="–-MySQL-存储引擎架构了解吗？"><a href="#–-MySQL-存储引擎架构了解吗？" class="headerlink" title="– MySQL 存储引擎架构了解吗？"></a>– MySQL 存储引擎架构了解吗？</h4><p>MySQL 存储引擎采用的是 <strong>插件式架构</strong> ，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。<strong>存储引擎是基于表的，而不是数据库。</strong></p><p>还可以根据 MySQL 定义的存储引擎实现标准接口来编写一个属于自己的存储引擎。</p><h4 id="–-MyISAM-和-InnoDB-有什么区别？☆"><a href="#–-MyISAM-和-InnoDB-有什么区别？☆" class="headerlink" title="– MyISAM 和 InnoDB 有什么区别？☆"></a>– MyISAM 和 InnoDB 有什么区别？☆</h4><p>MyISAM <strong>不支持事务和行级锁</strong>，而且最大的缺陷就是<strong>崩溃后无法安全恢复</strong>。</p><p><strong>总结</strong>：</p><ul><li>InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度。</li><li>MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。</li><li>MyISAM 不支持外键，而 InnoDB 支持。</li><li>MyISAM 不支持 MVCC，而 InnoDB 支持。</li><li>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</li><li>MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。</li><li>InnoDB 的性能比 MyISAM 更强大。</li></ul><ol><li><p><strong>是否支持行级锁</strong></p><ul><li><strong>MyISAM 只有表级锁</strong>(table-level locking)，而 <strong>InnoDB 支持行级锁</strong>(row-level locking)和<strong>表级锁</strong>，默认行级锁。</li><li>也就说，MyISAM 一锁就是锁住了整张表，这在并发写的情况下是多么滴憨憨啊！这也是为什么 InnoDB 在并发写的时候，性能更牛皮了！</li></ul></li><li><p><strong>是否支持事务</strong></p><p><strong>MyISAM 不提供事务支持。</strong></p><p>InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有<strong>提交(commit)和回滚(rollback)事务</strong>的能力。并且，InnoDB 默认使用的 <strong>REPEATABLE-READ（可重读）隔离级别</strong>是可以<strong>解决幻读</strong>问题发生的（基于 MVCC 和 Next-Key Lock）。</p></li><li><p><strong>是否支持外键</strong></p><p><strong>MyISAM 不支持，而 InnoDB 支持。</strong></p><ul><li>外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗。</li><li>一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据你的项目来决定。</li></ul></li><li><p><strong>是否支持数据库异常崩溃后的安全恢复</strong></p><p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code> 。</p></li><li><p><strong>是否支持 MVCC</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><ul><li>MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。</li></ul></li><li><p><strong>索引实现不一样</strong></p><p>MyISAM 引擎和 InnoDB 引擎都是使用 <strong>B+Tree 作为索引结构</strong>，但是两者的实现方式不一样。</p><p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。</p></li><li><p><strong>性能有差别</strong></p><p>InnoDB 的性能比 MyISAM 更强大</p></li></ol><h4 id="–-MyISAM-和-InnoDB-如何选择？"><a href="#–-MyISAM-和-InnoDB-如何选择？" class="headerlink" title="– MyISAM 和 InnoDB 如何选择？"></a>– MyISAM 和 InnoDB 如何选择？</h4><p>大多数时候使用的都是 InnoDB 存储引擎，在某些<strong>读密集的情况</strong>下，使用 MyISAM 也是合适的。不过，前提是不介意 MyISAM 不支持事务、崩溃恢复等缺点（可是~我们一般都会介意！）。</p><h3 id="【MySQL-索引】"><a href="#【MySQL-索引】" class="headerlink" title="【MySQL 索引】"></a>【MySQL 索引】</h3><h4 id="–-索引介绍"><a href="#–-索引介绍" class="headerlink" title="– 索引介绍"></a>– 索引介绍</h4><p><strong>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</strong></p><p>索引的作用就相当于书的目录。</p><p>索引底层数据结构存在很多种类型，常见的索引结构有: <strong>B 树， B+树 和 Hash、红黑树</strong>。在 MySQL 中，无论是 <strong>Innodb</strong> 还是 <strong>MyIsam</strong>，都使用了 <strong>【B+树】</strong>作为索引结构，但是，两者的实现方式不太一样。</p><h4 id="–-索引的优缺点"><a href="#–-索引的优缺点" class="headerlink" title="– 索引的优缺点"></a>– 索引的优缺点</h4><p><strong>优点</strong>：</p><ul><li>使用索引可以大大<strong>加快数据的检索速度</strong>（大大<strong>减少检索的数据量</strong>）, 这也是创建索引的最主要的原因。</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>创建索引和维护索引</strong>需要<strong>耗费</strong>许多<strong>时间</strong>。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li><li>索引需要使用物理文件存储，也会耗费一定空间。</li></ul><p><strong>使用索引一定能提高查询性能吗?</strong></p><p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p><h4 id="–-索引底层数据结构选型"><a href="#–-索引底层数据结构选型" class="headerlink" title="– 索引底层数据结构选型"></a>– 索引底层数据结构选型</h4><h5 id="Hash-表"><a href="#Hash-表" class="headerlink" title="Hash 表"></a>Hash 表</h5><p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。</p><ul><li><p><strong>为何能够通过 key 快速取出 value 呢？</strong> </p><p>原因在于 <strong>哈希算法</strong>（也叫散列算法）。通过哈希算法，我们可以快速找到 key 对应的 index，找到了 index 也就找到了对应的 value。</p><p>出现<strong>Hash 冲突</strong> ，常用的解决办法是 <strong>链地址法</strong>。</p></li><li><p><strong>为什么 MySQL 没有使用其作为索引的数据结构呢？</strong></p><p>主要是因为 Hash 索引不支持顺序和范围查询。</p></li></ul><h5 id="二叉查找树-BST"><a href="#二叉查找树-BST" class="headerlink" title="二叉查找树(BST)"></a>二叉查找树(BST)</h5><p>二叉查找树（Binary Search Tree）是一种基于二叉树的数据结构，它具有以下特点：</p><ol><li>左子树所有节点的值均小于根节点的值。</li><li>右子树所有节点的值均大于根节点的值。</li><li>左右子树也分别为二叉查找树。</li></ol><p><strong>二叉查找树的性能非常依赖于它的平衡程度，这就导致其不适合作为 MySQL 底层索引的数据结构。</strong></p><h5 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h5><p>AVL 树是最早被发明的<strong>自平衡二叉查找树</strong>，特点是保证<strong>任何节点的左右子树高度之差不超过 1</strong>，因此也被称为高度平衡二叉树，它的查找、插入和删除在平均和最坏情况下的时间复杂度都是 O(logn)。</p><p>由于 AVL 树需要频繁地进行<strong>旋转操作</strong>来保持平衡，因此会有较大的计算开销进而降低了查询性能。并且， 在使用 AVL 树时，每个树节点仅存储一个数据，而每次进行磁盘 IO 时只能读取一个节点的数据，如果需要查询的数据分布在多个节点上，那么就需要进行多次磁盘 IO。 <strong>磁盘 IO 是一项耗时的操作，在设计数据库索引时，我们需要优先考虑如何最大限度地减少磁盘 IO 操作的次数。</strong></p><p>实际应用中，AVL 树使用的并不多。</p><h5 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h5><p>红黑树是一种<strong>自平衡二叉查找树</strong>，通过在插入和删除节点时进行<strong>颜色变换</strong>和<strong>旋转操作</strong>，使得树始终保持平衡状态，它具有以下特点：</p><ol><li>每个节点非红即黑；</li><li><strong>根节点总是黑色的</strong>；</li><li>每个<strong>叶子节点都是黑色的空节点</strong>（NIL 节点）；</li><li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</li><li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</li></ol><p><strong>红黑树的应用还是比较广泛的，TreeMap、TreeSet 以及 JDK1.8 的 HashMap 底层都用到了红黑树。对于数据在内存中的这种情况来说，红黑树的表现是非常优异的。</strong></p><h5 id="B-树-B-树"><a href="#B-树-B-树" class="headerlink" title="B 树&amp; B+树"></a>B 树&amp; B+树</h5><p>B 树也称 B-树,全称为 <strong>多路平衡查找树</strong> ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 Balanced （平衡）的意思。<strong>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。</strong></p><p><strong>B 树&amp; B+树两者有何异同呢？</strong></p><ul><li><strong>B 树的所有节点既存放键(key) 也存放数据(data)<strong>，而 <strong>B+树只有叶子节点存放 key 和 data</strong>，其他</strong>内节点只存放 key</strong>。</li><li>B 树的叶子节点都是独立的;<strong>B+树的叶子节点有一条引用链指向与它相邻的叶子节点</strong>。</li><li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li><li>在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。</li></ul><p>综上，B+树与 B 树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。</p><h4 id="–-索引类型总结"><a href="#–-索引类型总结" class="headerlink" title="– 索引类型总结"></a>– 索引类型总结</h4><p>按照<strong>数据结构维度</strong>划分：</p><ul><li><strong>BTree 索引</strong>：<strong>MySQL</strong> 里<strong>默认</strong>和最常用的索引类型。只有叶子节点存储 value，非叶子节点只有指针和 key。存储引擎 MyISAM 和 InnoDB 实现 BTree 索引都是使用 <strong>B+Tree</strong>。</li><li>哈希索引：类似键值对的形式，一次即可定位。</li><li>RTree 索引：一般不会使用，仅支持 geometry 数据类型，优势在于范围查找，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li><li>全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li></ul><p>按照<strong>底层存储方式</strong>角度划分：</p><ul><li><p><strong>聚簇索引（聚集索引）</strong>：<strong>索引结构和数据一起存放的索引</strong>，InnoDB 中的<strong>主键索引</strong>就属于聚簇索引。</p><p><strong>优点</strong>：</p><ul><li><strong>查询速度非常快</strong>：定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作。</li><li><strong>对排序查找和范围查找优化</strong>：聚簇索引对于主键的排序查找和范围查找速度非常快。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>依赖于有序的数据</strong>：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li><li><strong>更新代价大</strong>：如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。</li></ul></li><li><p><strong>非聚簇索引（非聚集索引）</strong>：<strong>索引结构和数据分开存放的索引</strong>，<strong>二级索引</strong>(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。</p><p><strong>优点</strong>：</p><p>更新代价比聚簇索引要小 。非聚簇索引的叶子节点是不存放数据的</p><p><strong>缺点</strong>：</p><ul><li><strong>依赖于有序的数据</strong>:跟聚簇索引一样，非聚簇索引也依赖于有序的数据</li><li><strong>可能会二次查询(回表)</strong>:这应该是非聚簇索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li></ul></li></ul><p>按照<strong>应用维度</strong>划分：</p><ul><li><p>主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。</p></li><li><p>普通索引：仅加速查询。</p></li><li><p>唯一索引：加速查询 + 列值唯一（可以有 NULL）。</p></li><li><p>覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。</p><p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</strong></p></li><li><p>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。</p></li><li><p>全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</p></li></ul><p>MySQL 8.x 中实现的索引新特性：</p><ul><li>隐藏索引：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置）。</li><li>降序索引：之前的版本就支持通过 desc 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引。另外，在 MySQL 8.x 版本中，不再对 GROUP BY 语句进行隐式排序。</li><li>函数索引：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。</li></ul><h4 id="–-非聚簇索引一定回表查询吗-覆盖索引"><a href="#–-非聚簇索引一定回表查询吗-覆盖索引" class="headerlink" title="– 非聚簇索引一定回表查询吗(覆盖索引)?"></a>– 非聚簇索引一定回表查询吗(覆盖索引)?</h4><p><strong>非聚簇索引不一定回表查询。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">试想一种情况，用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引。</span><br><span class="line">那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。</span><br><span class="line">即使是 MYISAM 也是这样，虽然 MYISAM 的主键索引确实需要回表，因为它的主键索引的叶子节点存放的是指针。但是！如果 SQL 查的就是主键呢?</span><br><span class="line">主键索引本身的 key 就是主键，查到返回就行了。这种情况就称之为覆盖索引了。</span><br></pre></td></tr></table></figure><h4 id="–-最左前缀匹配原则-☆"><a href="#–-最左前缀匹配原则-☆" class="headerlink" title="– 最左前缀匹配原则 ☆"></a>– 最左前缀匹配原则 ☆</h4><p>在使用联合索引时，<strong>MySQL</strong> 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 <strong><code>&gt;</code><strong>、</strong><code>&lt;</code></strong> ）才会停止匹配。对于 <strong><code>&gt;=</code><strong>、</strong><code>&lt;=</code><strong>、</strong><code>BETWEEN</code><strong>、</strong><code>like</code></strong> 前缀匹配的范围查询，并不会停止匹配。所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。</p><h4 id="–-索引下推"><a href="#–-索引下推" class="headerlink" title="– 索引下推"></a>– 索引下推</h4><p>MySQL 5.6 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。</p><h4 id="–-正确使用索引"><a href="#–-正确使用索引" class="headerlink" title="– 正确使用索引"></a>– 正确使用索引</h4><h4 id="–-什么是慢查询？如何优化？"><a href="#–-什么是慢查询？如何优化？" class="headerlink" title="– 什么是慢查询？如何优化？"></a>– 什么是慢查询？如何优化？</h4><h3 id="【MySQL-查询缓存（不实用）】"><a href="#【MySQL-查询缓存（不实用）】" class="headerlink" title="【MySQL 查询缓存（不实用）】"></a>【MySQL 查询缓存（不实用）】</h3><p>执行查询语句的时候，会先查询缓存。不过，MySQL 8.0 版本后移除，因为这个功能不太实用。</p><p>开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果。</p><p>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。 </p><h3 id="【MySQL-日志】"><a href="#【MySQL-日志】" class="headerlink" title="【MySQL 日志】"></a>【MySQL 日志】</h3><ul><li>MySQL 中常见的日志有哪些？</li><li>慢查询日志有什么用？</li><li>binlog 主要记录了什么？</li><li>redo log 如何保证事务的持久性？</li><li>页修改之后为什么不直接刷盘呢？</li><li>binlog 和 redolog 有什么区别？</li><li>undo log 如何保证事务的原子性？</li></ul><h3 id="【MySQL-事务】"><a href="#【MySQL-事务】" class="headerlink" title="【MySQL 事务】"></a>【MySQL 事务】</h3><h4 id="–-何谓事务？"><a href="#–-何谓事务？" class="headerlink" title="– 何谓事务？"></a>– 何谓事务？</h4><ul><li><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></li></ul><h4 id="–-何谓数据库事务？"><a href="#–-何谓数据库事务？" class="headerlink" title="– 何谓数据库事务？"></a>– 何谓数据库事务？</h4><ul><li>如果没有特指分布式事务，往往指的就是数据库事务。</li></ul><h5 id="那数据库事务有什么作用呢？"><a href="#那数据库事务有什么作用呢？" class="headerlink" title="那数据库事务有什么作用呢？"></a>那数据库事务有什么作用呢？</h5><ul><li><p>可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。</p></li><li><p>数据库操作遵循：<strong>要么全部执行成功,要么全部不执行</strong> 。</p></li><li><p>另外，关系型数据库（例如：MySQL、SQL Server、Oracle 等）事务都有 <strong>ACID 特性</strong>：</p><ul><li><strong>原子性</strong>（<code>Atomicity</code>）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性</strong>（<code>Consistency</code>）：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li><strong>隔离性</strong>（<code>Isolation</code>）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性</strong>（<code>Durability</code>）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ul></li><li><p><strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</strong></p></li></ul><h4 id="–-并发事务带来了哪些问题-☆"><a href="#–-并发事务带来了哪些问题-☆" class="headerlink" title="– 并发事务带来了哪些问题?☆"></a>– 并发事务带来了哪些问题?☆</h4><p>多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。</p><ul><li><p><strong>脏读（Dirty read）</strong></p><p>读未提交。一个事务读取数据并进行了修改，<strong>还未提交，其他事务就能读到</strong>，读到的就是脏数据。</p></li><li><p><strong>丢失修改（Lost to modify）</strong></p><p>一个事务读取一个数据时，另外一个事务也访问了该数据，那么在<strong>第一个事务修改了这个数据后，第二个事务也修改了这个数据。第一个事务内的修改结果就被丢失</strong>，因此称为丢失修改。</p></li><li><p><strong>不可重复读（Unrepeatable read）</strong></p><p>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于<strong>第二个事务的修改导致第一个事务两次读取的数据可能不太一样</strong>。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p></li><li><p><strong>幻读（Phantom read）</strong></p><p>一个事务读取了几行数据，接着<strong>另一个并发事务插入了一些数据</strong>时。在随后的查询中，<strong>第一个事务就会发现多了一些原本不存在的记录</strong>，就好像发生了幻觉一样，所以称为幻读。</p></li></ul><h4 id="–-不可重复读和幻读有什么区别？"><a href="#–-不可重复读和幻读有什么区别？" class="headerlink" title="– 不可重复读和幻读有什么区别？"></a>– 不可重复读和幻读有什么区别？</h4><p>幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。</p><ul><li><strong>不可重复读</strong>的重点是<strong>内容修改或者记录减少</strong>比如多次读取一条记录发现其中某些记录的值被修改；</li><li><strong>幻读</strong>的重点在于<strong>记录新增</strong>比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</li></ul><h4 id="–并发事务的控制方式有哪些？★"><a href="#–并发事务的控制方式有哪些？★" class="headerlink" title="–并发事务的控制方式有哪些？★"></a>–并发事务的控制方式有哪些？★</h4><p>两种：<strong>锁</strong> 和 <strong>MVCC</strong></p><ol><li><p><strong>锁</strong> 控制方式下会通过锁来<strong>显示控制共享资源</strong>而不是通过调度手段，MySQL 中主要是通过 <strong>读写锁</strong> 来实现并发控制。</p><ul><li><strong>共享锁（S 锁）</strong>：又称<strong>读锁</strong>，事务在读取记录的时候获取共享锁，<strong>允许多个事务同时获取</strong>（锁兼容）。</li><li><strong>排他锁（X 锁）</strong>：又称<strong>写锁&#x2F;独占锁</strong>，事务在修改记录的时候获取排他锁，<strong>不允许多个事务同时获取</strong>。如果一个记录已经被加了排他锁，那<strong>其他事务不能再对这条记录加任何类型的锁</strong>（锁不兼容）。</li><li>读写锁可以做到读读并行，但是无法做到写读、写写并行。另外，根据根据锁粒度的不同，又被分为 <strong>表级锁(table-level locking)</strong> 和 <strong>行级锁(row-level locking)</strong> 。</li><li>InnoDB 不光支持表级锁，还支持行级锁，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类。</li></ul></li><li><p><strong>MVCC</strong> 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。</p><p>[乐观锁和 MVCC 的区别？-CSDN博客](<a href="https://blog.csdn.net/dekejiao5921/article/details/102430442#:~:text=MVCC%EF%BC%88Multi-Version">https://blog.csdn.net/dekejiao5921/article/details/102430442#:~:text=MVCC（Multi-Version</a> Concurrent,Control），基于快照隔离机制 (Snapshot Isolations)进行多版本并发控制，是一种以乐观锁为理论基础的，用来解决读-写冲突的无锁并发控制。)</p><p>MVCC 在 MySQL 中实现所依赖的手段主要是: <strong>隐藏字段、read view、undo log</strong>。</p><ul><li>undo log : undo log 用于记录某行数据的多个版本的数据。</li><li>read view 和 隐藏字段 : 用来判断当前版本数据的可见性。</li></ul></li></ol><h4 id="–-SQL-标准定义了哪些事务隔离级别"><a href="#–-SQL-标准定义了哪些事务隔离级别" class="headerlink" title="– SQL 标准定义了哪些事务隔离级别?"></a>– SQL 标准定义了哪些事务隔离级别?</h4><ol><li><strong>READ-UNCOMMITTED(读取未提交)</strong> ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致<strong>脏读、幻读或不可重复读</strong>。</li><li><strong>READ-COMMITTED(读取已提交)</strong> ：允许读取并发事务已经提交的数据，可以<strong>阻止脏读</strong>，但是幻读或不可重复读仍有可能发生。</li><li><strong>REPEATABLE-READ(可重复读)</strong> ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以<strong>阻止脏读和不可重复读</strong>，但幻读仍有可能发生。</li><li><strong>SERIALIZABLE(可串行化)</strong> ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以<strong>防止脏读、不可重复读以及幻读</strong>。</li></ol><h4 id="–-MySQL-的隔离级别是基于锁实现的吗？"><a href="#–-MySQL-的隔离级别是基于锁实现的吗？" class="headerlink" title="– MySQL 的隔离级别是基于锁实现的吗？"></a>– MySQL 的隔离级别是基于锁实现的吗？</h4><p>MySQL 的隔离级别<strong>基于锁和 MVCC 机制共同实现</strong>的。</p><p>SERIALIZABLE 隔离级别是通过锁来实现的，READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于 MVCC 实现的。不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。</p><h4 id="–-MySQL-的默认隔离级别是什么"><a href="#–-MySQL-的默认隔离级别是什么" class="headerlink" title="– MySQL 的默认隔离级别是什么?"></a>– MySQL 的默认隔离级别是什么?</h4><p><strong>REPEATABLE-READ（可重读）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通过 SELECT @@tx_isolation; 命令来查看</span><br><span class="line"></span><br><span class="line">MySQL 8.0 该命令改为 SELECT @@transaction_isolation;</span><br></pre></td></tr></table></figure><h3 id="【MySQL-锁】"><a href="#【MySQL-锁】" class="headerlink" title="【MySQL 锁】"></a>【MySQL 锁】</h3><p><strong>锁</strong>是一种常见的<strong>并发事务的控制方式</strong>。</p><h4 id="–-表级锁和行级锁了解吗？有什么区别？"><a href="#–-表级锁和行级锁了解吗？有什么区别？" class="headerlink" title="– 表级锁和行级锁了解吗？有什么区别？"></a>– 表级锁和行级锁了解吗？有什么区别？</h4><ul><li><p><strong>MyISAM</strong> 仅仅支持表级锁(table-level locking)，一<strong>锁就锁整张表</strong>，这在并发写的情况下性非常差。</p><p><strong>InnoDB</strong> 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。</p></li><li><p>行级锁的<strong>粒度更小</strong>，仅<strong>对相关的记录上锁即可</strong>（对一行或者多行记录加锁），所以对于<strong>并发写入操作</strong>来说， InnoDB 的性能更高。</p></li><li><p><strong>表级锁和行级锁对比</strong>：</p><ul><li><p><strong>表级锁：</strong> MySQL 中<strong>锁定粒度最大</strong>的一种锁（全局锁除外），是针对<strong>非索引字段加的锁</strong>，对当前操作的<strong>整张表加锁</strong>，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。</p></li><li><p><strong>行级锁：</strong> MySQL 中锁<strong>定粒度最小</strong>的一种锁，是 <strong>针对索引字段加的锁</strong> ，只针对当前操作的行记录进行加锁。 行级锁能大大<strong>减少数据库操作的冲突</strong>。其加锁粒度最小，<strong>并发度高</strong>，但<strong>加锁的开销也最大，加锁慢，会出现死锁</strong>。行级锁和存储引擎有关，是在存储引擎层面实现的。</p></li></ul></li></ul><h4 id="–-行级锁的使用有什么注意事项？？"><a href="#–-行级锁的使用有什么注意事项？？" class="headerlink" title="– 行级锁的使用有什么注意事项？？"></a>– 行级锁的使用有什么注意事项？？</h4><p>当我们执行 <code>UPDATE</code>、<code>DELETE</code> 语句时，如果 <code>WHERE</code>条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。</p><p>不过，很多时候即使用了索引也有可能会走全表扫描，这是因为 MySQL 优化器的原因。</p><h4 id="–-InnoDB-有哪几类行锁？"><a href="#–-InnoDB-有哪几类行锁？" class="headerlink" title="– InnoDB 有哪几类行锁？"></a>– InnoDB 有哪几类行锁？</h4><p>InnoDB <strong>行锁</strong>是<strong>通过对索引数据页上的记录加锁实现</strong>的，MySQL InnoDB 支持三种行锁定方式：</p><p><strong>记录锁（Record Lock）</strong>：也被称为记录锁，属于<strong>单个行记录</strong>上的锁。</p><p><strong>间隙锁（Gap Lock）</strong>：锁定一个<strong>范围</strong>，不包括记录本身。</p><p><strong>临键锁（Next-Key Lock）</strong>：Record Lock+Gap Lock，<strong>锁定一个范围，包含记录本</strong>身，主要目的是<strong>为了解决幻读</strong>问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</p><p><strong>在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。</strong></p><h4 id="–-共享锁和排他锁呢？"><a href="#–-共享锁和排他锁呢？" class="headerlink" title="– 共享锁和排他锁呢？"></a>– 共享锁和排他锁呢？</h4><p>不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：</p><ul><li><strong>共享锁（S 锁）</strong>：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li><li><strong>排他锁（X 锁）</strong>：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。</li></ul><h4 id="–-意向锁有什么作用？"><a href="#–-意向锁有什么作用？" class="headerlink" title="– 意向锁有什么作用？"></a>– 意向锁有什么作用？</h4><p>需要用到表锁的时，判断表中的记录有没有行锁。</p><p>意向锁，<strong>快速判断是否可以对某个表使用表锁</strong>。</p><ul><li><strong>意向共享锁（Intention Shared Lock，IS 锁）</strong>：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。</li><li><strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。</li></ul><p>意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享&#x2F;排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。</p><ul><li>意向锁之间是互相兼容的。</li><li>意向锁和共享锁和排它锁互斥（这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥）。</li></ul><h4 id="–-当前读和快照读有什么区别？"><a href="#–-当前读和快照读有什么区别？" class="headerlink" title="– 当前读和快照读有什么区别？"></a>– 当前读和快照读有什么区别？</h4><ul><li><p><strong>快照读</strong>（一致性非锁定读）就是单纯的 <code>SELECT</code> 语句。</p><p>快照即记录的历史版本，每行记录可能存在多个历史版本（多版本技术）。</p></li><li><p><strong>当前读</strong> （一致性锁定读）就是给行记录加 X 锁或 S 锁。</p></li></ul><h4 id="–-自增锁有了解吗？"><a href="#–-自增锁有了解吗？" class="headerlink" title="– 自增锁有了解吗？"></a>– 自增锁有了解吗？</h4><p>InnoDB 中的自增主键会涉及一种比较特殊的表级锁— <strong>自增锁（AUTO-INC Locks）</strong> 。</p><p>更准确点来说，不仅仅是自增主键，<code>AUTO_INCREMENT</code>的列都会涉及到自增锁，毕竟非主键也可以设置自增长。</p><h3 id="【MySQL-性能优化】"><a href="#【MySQL-性能优化】" class="headerlink" title="【MySQL 性能优化】"></a>【MySQL 性能优化】</h3><h4 id="–-能用-MySQL-直接存储文件（比如图片）吗？"><a href="#–-能用-MySQL-直接存储文件（比如图片）吗？" class="headerlink" title="– 能用 MySQL 直接存储文件（比如图片）吗？"></a>– 能用 MySQL 直接存储文件（比如图片）吗？</h4><p>可以但不建议。会严重影响数据库性能，消耗过多存储空间。</p><p>可以选择使用云服务厂商提供的开箱即用的文件存储服务。MinIO（推荐）</p><p><strong>数据库只存储文件地址信息，文件由文件存储服务负责存储。</strong></p><h4 id="–-MySQL-如何存储-IP-地址？"><a href="#–-MySQL-如何存储-IP-地址？" class="headerlink" title="– MySQL 如何存储 IP 地址？"></a>– MySQL 如何存储 IP 地址？</h4><p>可以将 <strong>IP 地址转换成整形数据存储</strong>，<strong>性能更好，占用空间也更小</strong>。</p><p>MySQL 提供了两个方法来处理 ip 地址</p><ul><li><code>INET_ATON()</code>：把 ip 转为无符号整型 (4-8 位)</li><li><code>INET_NTOA()</code> :把整型的 ip 转为地址</li></ul><p>插入数据前，先用 <code>INET_ATON()</code> 把 ip 地址转为整型，显示数据时，使用 <code>INET_NTOA()</code> 把整型的 ip 地址转为地址显示即可</p><h4 id="–-有哪些常见的-SQL-优化手段？★"><a href="#–-有哪些常见的-SQL-优化手段？★" class="headerlink" title="– 有哪些常见的 SQL 优化手段？★"></a>– 有哪些常见的 SQL 优化手段？★</h4><h4 id="–-如何分析-SQL-的性能？☆"><a href="#–-如何分析-SQL-的性能？☆" class="headerlink" title="– 如何分析 SQL 的性能？☆"></a>– 如何分析 SQL 的性能？☆</h4><p>使用 <code>EXPLAIN</code> 命令来分析 SQL 的 <strong>执行计划</strong> 。执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化会后，具体的执行方式。</p><p><code>EXPLAIN</code> 并不会真的去执行相关的语句，而是通过 <strong>查询优化器</strong> 对语句进行分析，找出最优的查询方案，并显示对应的信息。</p><p><code>EXPLAIN</code> 适用于 <code>SELECT</code>, <code>DELETE</code>, <code>INSERT</code>, <code>REPLACE</code>, 和 <code>UPDATE</code>语句，我们一般分析 <code>SELECT</code> 查询较多。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT `score`,`name` FROM `cus_order` ORDER BY `score` DESC;</span><br><span class="line">+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+</span><br><span class="line">| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra          |</span><br><span class="line">+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+</span><br><span class="line">|  1 | SIMPLE      | cus_order | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 997572 |   100.00 | Using filesort |</span><br><span class="line">+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="–-读写分离和分库分表了解吗？"><a href="#–-读写分离和分库分表了解吗？" class="headerlink" title="– 读写分离和分库分表了解吗？"></a>– 读写分离和分库分表了解吗？</h4><h4 id="–-深度分页如何优化？"><a href="#–-深度分页如何优化？" class="headerlink" title="– 深度分页如何优化？"></a>– 深度分页如何优化？</h4><h4 id="–-数据冷热分离如何做？"><a href="#–-数据冷热分离如何做？" class="headerlink" title="– 数据冷热分离如何做？"></a>– 数据冷热分离如何做？</h4><h4 id="–-常见的数据库优化方法有哪些？★"><a href="#–-常见的数据库优化方法有哪些？★" class="headerlink" title="– 常见的数据库优化方法有哪些？★"></a>– 常见的数据库优化方法有哪些？★</h4><ul><li><a href="https://javaguide.cn/database/mysql/mysql-index.html">索引优化</a></li><li><a href="https://javaguide.cn/high-performance/read-and-write-separation-and-library-subtable.html">读写分离和分库分表</a></li><li><a href="https://javaguide.cn/high-performance/data-cold-hot-separation.html">数据冷热分离</a></li><li><a href="https://javaguide.cn/high-performance/sql-optimization.html">SQL 优化</a></li><li><a href="https://javaguide.cn/high-performance/deep-pagination-optimization.html">深度分页优化</a></li><li>适当冗余数据</li><li>使用更高的硬件配置</li></ul><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;持续补充…&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://sunrisel135.github.io/blog_lyl/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="面试" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>字符集</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/13/%E5%AD%97%E7%AC%A6%E9%9B%86/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/13/%E5%AD%97%E7%AC%A6%E9%9B%86/</id>
    <published>2024-03-13T01:56:47.000Z</published>
    <updated>2024-03-13T02:07:00.008Z</updated>
    
    <content type="html"><![CDATA[<p>详解请查看全文…</p><span id="more"></span><h4 id="字符集是什么？"><a href="#字符集是什么？" class="headerlink" title="字符集是什么？"></a>字符集是什么？</h4><p><strong>字符</strong>是各种文字和符号的统称，包括各个国家文字、标点符号、表情、数字等等。</p><p> <strong>字符集</strong> 就是一系列字符的集合。</p><h4 id="计算机只能存储二进制的数据，那英文、汉字、表情等字符应该如何存储呢？"><a href="#计算机只能存储二进制的数据，那英文、汉字、表情等字符应该如何存储呢？" class="headerlink" title="计算机只能存储二进制的数据，那英文、汉字、表情等字符应该如何存储呢？"></a>计算机只能存储二进制的数据，那英文、汉字、表情等字符应该如何存储呢？</h4><p>将这些字符和二进制的数据一一对应起来。</p><h5 id="字符编码、字符解码"><a href="#字符编码、字符解码" class="headerlink" title="字符编码、字符解码"></a>字符编码、字符解码</h5><p>将字符对应二进制数据的过程称为”<strong>字符编码</strong>“，反之，二进制数据解析成字符的过程称为“<strong>字符解码</strong>”。</p><h4 id="字符编码是什么？"><a href="#字符编码是什么？" class="headerlink" title="字符编码是什么？"></a>字符编码是什么？</h4><p>字符编码是一种将字符集中的<strong>字符与计算机中的二进制数据相互转换的方法</strong>，可以看作是一种映射规则。也就是说，字符编码的目的是为了让计算机能够存储和传输各种文字信息。</p><p>每种字符集都有自己的字符编码规则，常用的字符集编码规则有 ASCII 编码、 GB2312 编码、GBK 编码、GB18030 编码、Big5 编码、UTF-8 编码、UTF-16 编码等。</p><h4 id="有哪些常见的字符集？"><a href="#有哪些常见的字符集？" class="headerlink" title="有哪些常见的字符集？"></a>有哪些常见的字符集？</h4><p>不同的字符集的主要区别在于：</p><ul><li>可以表示的字符范围</li><li>编码方式</li></ul><h5 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h5><p>是一套主要用于现代美国英语的字符集（这也是 ASCII 字符集的局限性所在）。</p><h5 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h5><p>很多国家都捣鼓了一个适合自己国家语言的字符集。</p><h5 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h5><p>GBK 字符集可以看作是 GB2312 字符集的扩展，兼容 GB2312 字符集，共收录了 20000 多个汉字。</p><p>GBK 中 K 是汉语拼音 Kuo Zhan（扩展）中的“Kuo”的首字母。</p><h5 id="GB18030"><a href="#GB18030" class="headerlink" title="GB18030"></a>GB18030</h5><p>完全兼容 GB2312 和 GBK 字符集，纳入中国国内少数民族的文字，且收录了日韩汉字，是目前为止最全面的汉字字符集，共收录汉字 70000 多个。</p><h5 id="BIG5"><a href="#BIG5" class="headerlink" title="BIG5"></a>BIG5</h5><p>主要针对的是繁体中文，收录了 13000 多个汉字。</p><h5 id="Unicode-UTF-8"><a href="#Unicode-UTF-8" class="headerlink" title="Unicode &amp; UTF-8"></a>Unicode &amp; UTF-8</h5><p>了不同的字符集可以表示的字符范围以及编码规则存在差异。这就导致了一个非常严重的问题：<strong>使用错误的编码方式查看一个包含字符的文件就会产生乱码现象。</strong></p><p>乱码的本质：<strong>编码和解码时用了不同或者不兼容的字符集</strong> 。</p><p><strong>Unicode 字符集</strong>中包含了世界上几乎所有已知的字符。不过，Unicode 字符集并没有规定如何存储这些字符（也就是如何使用二进制数据表示这些字符）。</p><p>然后，就有了 <strong>UTF-8</strong>（<strong>8</strong>-bit <strong>U</strong>nicode <strong>T</strong>ransformation <strong>F</strong>ormat）。类似的还有 UTF-16、 UTF-32。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;详解请查看全文…&lt;/p&gt;</summary>
    
    
    
    <category term="字符集详解" scheme="https://sunrisel135.github.io/blog_lyl/categories/%E5%AD%97%E7%AC%A6%E9%9B%86%E8%AF%A6%E8%A7%A3/"/>
    
    
    <category term="知识点" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Java面试-JVM</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/12/Java%E9%9D%A2%E8%AF%95-JVM/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/12/Java%E9%9D%A2%E8%AF%95-JVM/</id>
    <published>2024-03-12T01:26:50.000Z</published>
    <updated>2024-03-12T08:12:42.286Z</updated>
    
    <content type="html"><![CDATA[<p>持续更新…</p><span id="more"></span><h2 id="JVM的组织架构"><a href="#JVM的组织架构" class="headerlink" title="JVM的组织架构"></a>JVM的组织架构</h2><p>大致划分为三个部分：<strong>类加载器</strong>、<strong>运行时数据区</strong>和<strong>执行引擎</strong>。</p><ol><li><p><strong>类加载器</strong></p><p>负责从文件系统、网络或其他来源加载 Class 文件，<strong>将 Class 文件中的二进制数据读入到内存当中</strong>。</p></li><li><p><strong>运行时数据区</strong></p><p>JVM 在执行 Java 程序时，需要在内存中分配空间来处理各种数据，这些内存区域主要包括<strong>方法区</strong>、<strong>堆</strong>、<strong>栈</strong>、<strong>程序计数器</strong>和<strong>本地方法栈</strong>。</p></li><li><p><strong>执行引擎</strong></p><p>负责<strong>执行字节码</strong>。它包括一个<strong>虚拟处理器</strong>，还包括<strong>即时编译器</strong>（<strong>JIT</strong> Compiler）和<strong>垃圾回收器</strong>（Garbage Collector）。</p></li></ol><img src="C:\Users\lyl\Desktop\总结复习\JVM组织架构.png" style="zoom: 67%;" /><h2 id="Java内存区域详解（重点）"><a href="#Java内存区域详解（重点）" class="headerlink" title="Java内存区域详解（重点）"></a>Java内存区域详解（重点）</h2><p>常见面试题：</p><ul><li>介绍下 Java 内存区域（运行时数据区）</li><li>Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）</li><li>对象的访问定位的两种方式（句柄和直接指针两种方式）</li></ul><h3 id="【运行时数据区域】"><a href="#【运行时数据区域】" class="headerlink" title="【运行时数据区域】"></a>【运行时数据区域】</h3><p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。</p><h4 id="运行时数据区域（JDK1-7）"><a href="#运行时数据区域（JDK1-7）" class="headerlink" title="运行时数据区域（JDK1.7）:"></a><strong>运行时数据区域（JDK1.7）:</strong></h4><ol><li><strong>线程共享</strong>：<strong>堆</strong>(Heep) {<strong>字符串常量池</strong>(String Constant Pool)} + <strong>方法区</strong>(Method Area) {<strong>运行时常量池</strong>(Runtime Constant Pool)}</li><li><strong>线程私有</strong>：线程(Thread)1 {<strong>虚拟机栈</strong>(VM Stack) + <strong>本地方法栈</strong>(Native Method Stack) + <strong>程序计数器</strong>(Program Counter Register)}</li><li><strong>本地内存</strong>{ <strong>直接内存</strong>(Direct Memory ) }</li></ol><h4 id="运行时数据区域（JDK1-8）"><a href="#运行时数据区域（JDK1-8）" class="headerlink" title="运行时数据区域（JDK1.8）:"></a><strong>运行时数据区域（JDK1.8）:</strong></h4><ol><li><p><strong>线程共享</strong>：<strong>堆</strong> {<strong>字符串常量池</strong> }</p></li><li><p><strong>线程私有</strong>：线程1 {<strong>虚拟机栈</strong> + <strong>本地方法栈</strong> + <strong>程序计数器</strong> }</p></li><li><p><strong>本地内存</strong> { <strong>元空间</strong>(MetaSpace) { <strong>运行时常量池</strong> } +  <strong>直接内存</strong> }</p></li></ol><p><strong>线程私有的：</strong></p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p><strong>线程共享的：</strong></p><ul><li>堆</li><li>方法区</li><li>直接内存 (非运行时数据区的一部分)</li></ul><h4 id="–-能说一下-JVM-的内存区域吗？"><a href="#–-能说一下-JVM-的内存区域吗？" class="headerlink" title="– 能说一下 JVM 的内存区域吗？"></a>– 能说一下 JVM 的内存区域吗？</h4><p>JVM 内存分为线程私有区和线程共享区，其中<code>方法区</code>和<code>堆</code>是线程共享区，<code>虚拟机栈</code>、<code>本地方法栈</code>和<code>程序计数器</code>是线程隔离的数据区。</p><h4 id="–-程序计数器"><a href="#–-程序计数器" class="headerlink" title="– 程序计数器"></a>– 程序计数器</h4><p>是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。</p><ul><li><strong>字节码解释器</strong>通过改变程序计数器来依次读取指令，从而<strong>实现代码的流程控制</strong>，如：顺序执行、选择、循环、异常处理。</li><li>在<strong>多线程</strong>的情况下，程序计数器用于<strong>记录当前线程执行的位置</strong>，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ul><p>⚠️ 注意：程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的<strong>生命周期随着线程</strong>的创建而创建，随着线程的结束而死亡。</p><h4 id="–-Java虚拟机栈"><a href="#–-Java虚拟机栈" class="headerlink" title="– Java虚拟机栈"></a>– Java虚拟机栈</h4><p>除了一些 <strong>Native 方法</strong>调用是通过<strong>本地方法栈</strong>实现的(后面会提到)，<strong>其他所有的 Java 方法调用</strong>都是通过<strong>栈</strong>来实现的（也需要和其他运行时数据区域比如程序计数器<strong>配合</strong>）。</p><ul><li>方法调用的数据需要通过栈进行传递，每一次<strong>方法</strong>调用都会有一个对应的<strong>栈帧</strong>被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。</li><li>栈由一个个栈帧组成，而每个<strong>栈帧</strong>中都拥有：<strong>局部变量表、操作数栈、动态链接、方法返回地址</strong>。<strong>先进后出</strong>的数据结构，只支持出栈和入栈两种操作。</li><li>生命周期和线程相同。</li><li><strong>栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。</strong></li></ul><p><strong>局部变量表</strong> ：主要存放<strong>编译期可知的</strong>各种<strong>基本数据类型</strong>、<strong>对象引用</strong>（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p><p><strong>操作数栈</strong> ：主要作为<strong>方法调用的中转站</strong>，用于<strong>存放方法执行过程中产生的中间计算结果</strong>。另外，计算过程中产生的临时变量也会放在操作数栈中。</p><p><strong>动态链接</strong>：主要<strong>服务一个方法需要调用其他方法的场景</strong>。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的<strong>作用就是为了将符号引用转换为调用方法的直接引用</strong>，这个过程也被称为 <strong>动态连接</strong> 。</p><h4 id="–-本地方法栈"><a href="#–-本地方法栈" class="headerlink" title="– 本地方法栈"></a>– 本地方法栈</h4><p><strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong>在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p><ul><li>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</li></ul><h4 id="–-堆"><a href="#–-堆" class="headerlink" title="– 堆"></a>– 堆</h4><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有<strong>线程共享</strong>的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p><ul><li><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。</p></li><li><p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p><ol><li>新生代内存(Young Generation)</li><li>老生代(Old Generation)</li><li>永久代(Permanent Generation</li></ol></li><li><p><strong>JDK 8 版本之后 PermGen(永久代) 已被 Metaspace(元空间) 取代，元空间使用的是本地内存。</strong></p></li></ul><h4 id="–-方法区"><a href="#–-方法区" class="headerlink" title="– 方法区"></a>– 方法区</h4><p>当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</p><ul><li><p>方法区属于是 JVM 运行时数据区域的一块<strong>逻辑区域</strong>，是<strong>各个线程共享</strong>的内存区域。</p></li><li><p><strong>永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式</strong>。并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。</p><p>方法区（<strong>抽象概念&#x2F;规范</strong>） -&gt; 元空间（<strong>具体实现</strong>）</p><p>​ -&gt; 永久代（具体实现）</p></li></ul><p><strong>为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</strong></p><ul><li>整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</li></ul><h4 id="–-运行时常量池"><a href="#–-运行时常量池" class="headerlink" title="– 运行时常量池"></a>– 运行时常量池</h4><p>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于<strong>存放编译期生成的</strong>各种<strong>字面量</strong>（Literal）和<strong>符号引用</strong>（Symbolic Reference）的 <strong>常量池表(Constant Pool Table)</strong> 。</p><ul><li><strong>字面量</strong>是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量。</li><li>常见的<strong>符号引用</strong>包括类符号引用、字段符号引用、方法符号引用、接口方法符号。</li></ul><h4 id="–-字符串常量池"><a href="#–-字符串常量池" class="headerlink" title="– 字符串常量池"></a>– 字符串常量池</h4><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗<strong>针对字符串</strong>（String 类）专门开辟的一块区域，主要目的是为了<strong>避免字符串的重复创建</strong>。</p><ul><li>JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。</li></ul><p><strong>JDK 1.7 为什么要将字符串常量池移动到堆中？</strong></p><p>因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运行时常量池、方法区、字符串常量池这些都是不随虚拟机实现而改变的逻辑概念，是公共且抽象的，元空间(Metaspace)、堆(Heap) 是与具体某种虚拟机实现相关的物理概念，是私有且具体的。</span><br></pre></td></tr></table></figure><h4 id="–-直接内存"><a href="#–-直接内存" class="headerlink" title="– 直接内存"></a>– 直接内存</h4><p>直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。</p><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 <code>OutOfMemoryError</code> 错误出现。</p><p><strong>NIO（Non-Blocking I&#x2F;O，也被称为 New I&#x2F;O）</strong>，引入了一种基于**通道（Channel）与缓存区（Buffer）的 I&#x2F;O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为**避免了在 Java 堆和 Native 堆之间来回复制数据**。</p><h3 id="【HotSpot-虚拟机对象探秘】"><a href="#【HotSpot-虚拟机对象探秘】" class="headerlink" title="【HotSpot 虚拟机对象探秘】"></a>【HotSpot 虚拟机对象探秘】</h3><h4 id="–-对象的创建过程"><a href="#–-对象的创建过程" class="headerlink" title="– 对象的创建过程"></a>– 对象的创建过程</h4><ol><li><strong>类加载检查</strong><ul><li>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</li></ul></li><li><strong>分配内存</strong><ul><li><strong>类加载检查</strong>通过后，虚拟机将为新生对象<strong>分配内存</strong>。</li><li><strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</li></ul></li><li><strong>初始化零值</strong><ul><li>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li></ul></li><li><strong>设置对象头</strong><ul><li><strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li></ul></li><li><strong>执行 init 方法</strong><ul><li>从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行<strong>初始化</strong>，这样一个真正可用的对象才算完全产生出来。</li></ul></li></ol><h4 id="–-对象在内存中的布局"><a href="#–-对象在内存中的布局" class="headerlink" title="– 对象在内存中的布局"></a>– 对象在内存中的布局</h4><p> Hotspot 虚拟机中，对象在内存中的布局：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><ul><li><strong>对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li><li><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</li><li><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong></li></ul><h4 id="–-对象的访问定位"><a href="#–-对象的访问定位" class="headerlink" title="– 对象的访问定位"></a>– 对象的访问定位</h4><p> Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：<strong>使用句柄</strong>、<strong>直接指针</strong>。</p><ul><li><strong>句柄</strong>： Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。</li><li><strong>直接指针</strong>：reference 中存储的直接就是对象的地址。</li></ul><h2 id="JVM垃圾回收详解（重点）"><a href="#JVM垃圾回收详解（重点）" class="headerlink" title="JVM垃圾回收详解（重点）"></a>JVM垃圾回收详解（重点）</h2><p>常见面试题：</p><ul><li>如何判断对象是否死亡（两种方法）。</li><li>简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。</li><li>如何判断一个常量是废弃常量</li><li>如何判断一个类是无用的类</li><li>垃圾收集有哪些算法，各自的特点？</li><li>HotSpot 为什么要分为新生代和老年代？</li><li>常见的垃圾回收器有哪些？</li><li>介绍一下 CMS,G1 收集器。</li><li>Minor Gc 和 Full GC 有什么不同呢？</li></ul><h3 id="【堆空间的基本结构】"><a href="#【堆空间的基本结构】" class="headerlink" title="【堆空间的基本结构】"></a>【堆空间的基本结构】</h3><h3 id="【JVM-的垃圾回收机制】"><a href="#【JVM-的垃圾回收机制】" class="headerlink" title="【JVM 的垃圾回收机制】"></a>【JVM 的垃圾回收机制】</h3><p>垃圾回收（Garbage Collection，GC），顾名思义就是释放垃圾占用的空间，防止内存爆掉。有效的使用可以使用的内存，<strong>对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收</strong>。</p><h4 id="–-JVM-在垃圾回收之前，判断谁是垃圾，即垃圾判断算法"><a href="#–-JVM-在垃圾回收之前，判断谁是垃圾，即垃圾判断算法" class="headerlink" title="– JVM 在垃圾回收之前，判断谁是垃圾，即垃圾判断算法"></a>– JVM 在垃圾回收之前，判断谁是垃圾，即垃圾判断算法</h4><p>通常有引用技术算法、可达性分析算法。</p><ul><li><strong>引用计数算法</strong>是通过在对象头中分配一个空间来保存该<strong>对象被引用的次数</strong>。</li><li><strong>可达性分析算法</strong>的基本思路是，通过一些被称为引用链（GC Roots）的对象作为起点，然后向下搜索，搜索走过的路径被称为（Reference Chain），当<strong>一个对象到 GC Roots 之间没有任何引用相连时</strong>，即从 GC Roots 到该对象节点不可达，则证明该对象是需要垃圾收集的。</li></ul><h4 id="–-确定了哪些垃圾可以被回收后，垃圾收集器如何高效地进行垃圾回收呢？？"><a href="#–-确定了哪些垃圾可以被回收后，垃圾收集器如何高效地进行垃圾回收呢？？" class="headerlink" title="– 确定了哪些垃圾可以被回收后，垃圾收集器如何高效地进行垃圾回收呢？？"></a>– 确定了哪些垃圾可以被回收后，垃圾收集器如何高效地进行垃圾回收呢？？</h4><ul><li><strong>标记清除算法</strong>，分为 2 部分，先把内存区域中的这些对象进行标记，哪些属于可回收的标记出来，然后把这些垃圾拎出来清理掉。</li><li><strong>复制算法</strong>，在标记清除算法上演化而来的，用于解决标记清除算法的内存碎片问题。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。</li><li><strong>标记整理算法</strong>，标记过程仍然与标记清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，再清理掉端边界以外的内存区域。</li><li><strong>分代收集算法</strong>，在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用<strong>复制算法</strong>，只需要付出少量存活对象的复制成本就可以完成收集。老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用<strong>标记清理或者标记整理算法</strong>来进行回收。</li></ul><h4 id="–-垃圾回收器"><a href="#–-垃圾回收器" class="headerlink" title="– 垃圾回收器"></a>– 垃圾回收器</h4><p>JVM 提供了多种垃圾回收器，不同的垃圾回收器适用于不同的场景和需求，包括 <code>CMS GC、G1 GC、ZGC</code> 等。</p><ol><li><strong>CMS</strong> 是第一个关注 GC 停顿时间（STW 的时间）的垃圾收集器，JDK 1.5 时引入，JDK9 被标记弃用，JDK14 被移除。</li><li><strong>G1</strong>（Garbage-First Garbage Collector）在 JDK 1.7 时引入，在 <strong>JDK 9</strong> 时取代 CMS 成为了<strong>默认</strong>的垃圾收集器。</li><li><strong>ZGC</strong> 是 JDK11 推出的一款低延迟垃圾收集器，适用于<strong>大内存低延迟</strong>服务的内存管理和回收，SPEC jbb 2015 基准测试，在 128G 的大堆下，最大停顿时间才 1.68 ms，停顿时间远胜于 G1 和 CMS。</li></ol><h2 id="类加载过程详解"><a href="#类加载过程详解" class="headerlink" title="类加载过程详解"></a>类加载过程详解</h2><h3 id="【类的生命周期】"><a href="#【类的生命周期】" class="headerlink" title="【类的生命周期】"></a>【类的生命周期】</h3><p>7 个阶段：</p><ol><li>加载（Loading）</li><li>验证（Verification）</li><li>准备（Preparation）</li><li>解析（Resolution）</li><li>初始化（Initialization）</li><li>使用（Using）</li><li>卸载（Unloading）</li></ol><p>其中，验证、准备和解析这三个阶段可以统称为连接（Linking）。</p><h3 id="【类加载过程】"><a href="#【类加载过程】" class="headerlink" title="【类加载过程】"></a>【类加载过程】</h3><p><strong>Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？</strong></p><p>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;持续更新…&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://sunrisel135.github.io/blog_lyl/categories/JVM/"/>
    
    
    <category term="面试" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java面试-IO</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/10/Java%E9%9D%A2%E8%AF%95-IO/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/10/Java%E9%9D%A2%E8%AF%95-IO/</id>
    <published>2024-03-10T01:42:29.000Z</published>
    <updated>2024-03-10T01:43:38.106Z</updated>
    
    <content type="html"><![CDATA[<p>持续补充！</p><span id="more"></span><h3 id="【Java-IO基础】"><a href="#【Java-IO基础】" class="headerlink" title="【Java IO基础】"></a>【Java IO基础】</h3><h4 id="–-IO流"><a href="#–-IO流" class="headerlink" title="– IO流"></a>– IO流</h4><p>即 <code>Input/Output</code>，输入和输出。</p><ul><li>输入-数据输入到计算机内存的过程。</li><li>输出-输出到外部存储（比如数据库，文件，远程主机）的过程。</li></ul><p>可分为：</p><ul><li>输入流和输出流 </li><li>字节流和字符流 (根据数据的处理方式)</li></ul><p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li><code>InputStream</code> (字节输入流) &#x2F; <code>Reader</code> (字符输入流) : 所有输入流的基类</li><li><code>OutputStream</code> (字节输出流) &#x2F; <code>Writer</code> (字符输出流) : 所有输出流的基类。</li></ul><h4 id="–-字节流"><a href="#–-字节流" class="headerlink" title="– 字节流"></a>– 字节流</h4><h5 id="InputStream（字节输入流）"><a href="#InputStream（字节输入流）" class="headerlink" title="InputStream（字节输入流）"></a>InputStream（字节输入流）</h5><ol><li><p><code>InputStream</code>用于从源头 (通常是文件) 读取数据 (字节信息) 到内存中，<code>java.io.InputStream</code>抽象类是所有字节输入流的父类。</p></li><li><p><code>FileInputStream</code> 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。</p><p>不过，一般我们是不会直接单独使用 FileInputStream ，通常会配合 <code>BufferedInputStream</code>（字节缓冲输入流）来使用。</p></li><li><p><code>DataInputStream</code> 用于读取指定类型数据，不能单独使用，必须结合其它流，比如 <code>FileInputStream</code> 。</p></li><li><p><code>ObjectInputStream</code> 用于从输入流中读取 Java 对象（<strong>反序列化</strong>），<code>ObjectOutputStream</code> 用于将对象写入到输出流(<strong>序列化</strong>)。</p><p>用于序列化和反序列化的类必须实现 <code>Serializable</code> 接口，对象中如果有属性不想被序列化，使用 <code>transient</code> 修饰。</p></li></ol><h5 id="OutputStream（字节输出流）"><a href="#OutputStream（字节输出流）" class="headerlink" title="OutputStream（字节输出流）"></a>OutputStream（字节输出流）</h5><ol><li><code>OutputStream</code>用于将数据 (字节信息) 写入到目的地 (通常是文件)，<code>java.io.OutputStream</code>抽象类是所有字节输出流的父类。</li><li><code>FileOutputStream</code> 是最常用的字节输出流对象，可直接指定文件路径，可以直接输出单字节数据，也可以输出指定的字节数组。</li><li><code>DataOutputStream</code> 用于写入指定类型数据，不能单独使用，必须结合其它流，比如 <code>FileOutputStream</code> 。</li><li><code>ObjectOutputStream</code>，将对象写入到输出流(序列化)。</li></ol><h4 id="–-字符流"><a href="#–-字符流" class="headerlink" title="– 字符流"></a>– 字符流</h4><ul><li>不管是文件读写还是网络发送接收，信息的<strong>最小存储单元</strong>都是<strong>字节</strong>。</li></ul><h5 id="那为什么-I-O-流操作要分为字节流操作和字符流操作呢？"><a href="#那为什么-I-O-流操作要分为字节流操作和字符流操作呢？" class="headerlink" title="那为什么 I&#x2F;O 流操作要分为字节流操作和字符流操作呢？"></a>那为什么 I&#x2F;O 流操作要分为字节流操作和字符流操作呢？</h5><ul><li>字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时。</li><li>使用字节流时，如果我们<strong>不知道编码类型</strong>就<strong>很容易出现乱码问题</strong>。（中文）</li><li>因此，I&#x2F;O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。</li><li>如果<strong>音频文件、图片</strong>等<strong>媒体文件</strong>用<strong>字节流</strong>比较好，如果涉及到<strong>字符</strong>的话使用<strong>字符流</strong>比较好。</li></ul><h5 id="Reader（字符输入流）"><a href="#Reader（字符输入流）" class="headerlink" title="Reader（字符输入流）"></a>Reader（字符输入流）</h5><ol><li><p><code>Reader</code>用于从源头（通常是文件）读取数据（字符信息）到内存中，<code>java.io.Reader</code>抽象类是所有字符输入流的父类。</p><p><code>Reader</code> 用于读取文本， <code>InputStream</code> 用于读取原始字节。</p></li><li><p><strong>InputStreamReader</strong> 是字节流转换为字符流的<strong>桥梁</strong>，其<strong>子类</strong> <code>FileReader</code> 是基于该基础上的封装，可以直接操作字符文件。</p></li></ol><h5 id="Writer（字符输出流）"><a href="#Writer（字符输出流）" class="headerlink" title="Writer（字符输出流）"></a>Writer（字符输出流）</h5><ol><li><code>Writer</code>用于将数据（字符信息）写入到目的地（通常是文件），<code>java.io.Writer</code>抽象类是所有字符输出流的父类。</li><li><code>OutputStreamWriter</code> 是字符流转换为字节流的桥梁，其子类 <code>FileWriter</code> 是基于该基础上的封装，可以直接将字符写入到文件。</li></ol><h4 id="–-缓冲流"><a href="#–-缓冲流" class="headerlink" title="– 缓冲流"></a>– 缓冲流</h4><ul><li>IO 操作是很消耗<strong>性能</strong>的，缓冲流将数据加载至缓冲区，<strong>一次性读取&#x2F;写入多个字节</strong>，从而避免频繁的 IO 操作，提高流的<strong>传输效率</strong>。</li><li>字节缓冲流这里采用了<strong>装饰器模式</strong>来<strong>增强 <code>InputStream</code> 和<code>OutputStream</code>子类对象</strong>的功能。</li><li>字节流和字节缓冲流的性能差别主要体现在我们使用两者的时候都是调用 write(int b) 和 read() 这两个一次只读取一个字节的方法的时候。由于字节缓冲流内部有缓冲区（字节数组），因此，字节缓冲流会先将读取到的字节存放在缓存区，大幅减少 IO 次数，提高读取效率。</li></ul><h5 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h5><ol><li><p><strong>BufferedInputStream（字节缓冲输入流）</strong></p><ul><li><p><code>BufferedInputStream</code> 从源头（通常是文件）读取数据（字节信息）到内存的过程中不会一个字节一个字节的读取，而是会<strong>先将读取到的字节存放在缓存区，并从内部缓冲区中单独读取字节</strong>。这样大幅减少了 IO 次数，提高了读取效率。</p></li><li><p><code>BufferedInputStream</code> 内部维护了一个<strong>缓冲区</strong>，这个缓冲区实际就是一个<strong>字节数组</strong>。</p></li></ul></li><li><p><strong>BufferedOutputStream（字节缓冲输出流）</strong></p><ul><li><code>BufferedOutputStream</code> 将数据（字节信息）写入到目的地（通常是文件）的过程中不会一个字节一个字节的写入，而是会先将要写入的字节存放在缓存区，并从内部缓冲区中单独写入字节。这样大幅减少了 IO 次数，提高了读取效率</li></ul></li></ol><h5 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h5><p><code>BufferedReader</code> （<strong>字符缓冲输入流</strong>）和 <code>BufferedWriter</code>（<strong>字符缓冲输出流</strong>）类似于 <code>BufferedInputStream</code>（字节缓冲输入流）和<code>BufferedOutputStream</code>（字节缓冲输入流），内部都维护了一个字节数组作为缓冲区。不过，前者主要是用来操作字符信息。</p><h4 id="–-打印流"><a href="#–-打印流" class="headerlink" title="– 打印流"></a>– 打印流</h4><ul><li><code>System.out</code> 实际是用于获取一个 PrintStream 对象，print方法实际调用的是 PrintStream 对象的 write 方法。</li><li><code>PrintStream</code> 属于<strong>字节打印流</strong>，与之对应的是 <code>PrintWriter</code> （<strong>字符打印流</strong>）。PrintStream 是 OutputStream 的子类，PrintWriter 是 Writer 的子类。</li></ul><h4 id="–-随机访问流"><a href="#–-随机访问流" class="headerlink" title="– 随机访问流"></a>– 随机访问流</h4><ul><li>支持<strong>随意跳转到文件的任意位置进行读写</strong>的 <code>RandomAccessFile</code> 。</li><li><code>RandomAccessFile</code> 比较常见的一个应用就是实现大文件的 <strong>断点续传</strong> 。</li><li><strong>断点续传？</strong>简单来说就是上传文件中途暂停或失败（比如遇到网络问题）之后，不需要重新上传，只需要上传那些未成功上传的文件分片即可。<strong>分片</strong>（先将文件切分成多个文件分片）<strong>上传</strong>是断点续传的基础。</li></ul><h3 id="【Java-IO-设计模式】"><a href="#【Java-IO-设计模式】" class="headerlink" title="【Java IO 设计模式】"></a>【Java IO 设计模式】</h3><h4 id="–-装饰器模式"><a href="#–-装饰器模式" class="headerlink" title="– 装饰器模式"></a>– 装饰器模式</h4><p>详解：<a href="https://zhuanlan.zhihu.com/p/444298983">https://zhuanlan.zhihu.com/p/444298983</a></p><ul><li>装饰器（Decorator）模式 指<strong>在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的</strong>模式，它属于对象结构型模式。</li><li>装饰器模式<strong>通过组合替代继承来扩展原始类的功能</strong>，在一些继承关系比较复杂的场景（IO 这一场景各种类的继承关系就比较复杂）更加实用。</li><li>例如，<code>InputStream</code> 的子类 <code>FilterInputStream</code>，<code>Reader</code> 的子类 <code>BufferedReader</code> 以及 <code>FilterReader</code>，还有 <code>Writer</code> 的子类 <code>BufferedWriter、FilterWriter</code> 以及 <code>PrintWriter</code> 等，它们都是抽象装饰类。</li></ul><ol><li>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</li><li>具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。</li><li>抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li><li>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li><li>代码</li></ol><h4 id="–-适配器模式"><a href="#–-适配器模式" class="headerlink" title="– 适配器模式"></a>– 适配器模式</h4><p>详解：<a href="https://segmentfault.com/a/1190000040524953">java - 一文彻底弄懂适配器模式(Adapter Pattern) - 个人文章 - SegmentFault 思否</a></p><ul><li>适配器（Adapter Pattern）模式 是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。</li><li>适配器模式中存在被适配的对象或者类称为 <strong>适配者(Adaptee)</strong> ，作用于适配者的对象或者类称为<strong>适配器(Adapter)</strong> 。适配器分为<strong>对象适配器</strong>和<strong>类适配器</strong>。类适配器使用<strong>继承关系</strong>来实现，对象适配器使用<strong>组合关系</strong>来实现。</li><li>IO 流中的<strong>字符流和字节流</strong>的接口不同，它们<strong>之间</strong>可以<strong>协调工作</strong>就是基于适配器模式来做的，更准确点来说是对象适配器。通过适配器，我们可以将字节流对象适配成一个字符流对象。</li><li><strong><code>InputStreamReader</code></strong> 和 <strong><code>OutputStreamWriter</code></strong> 就是两个适配器(Adapter)， 同时，它们两个也是字节流和字符流之间的桥梁。</li><li>代码</li></ul><h4 id="–-适配器模式和装饰器模式有什么区别呢？"><a href="#–-适配器模式和装饰器模式有什么区别呢？" class="headerlink" title="– 适配器模式和装饰器模式有什么区别呢？"></a>– 适配器模式和装饰器模式有什么区别呢？</h4><ul><li><strong>装饰器模式</strong> 更侧重于动态地增强原始类的功能，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。并且，装饰器模式支持对原始类嵌套使用多个装饰器。</li><li><strong>适配器模式</strong> 更侧重于让接口不兼容而不能交互的类可以一起工作，当我们调用适配器对应的方法时，适配器内部会调用适配者类或者和适配类相关的类的方法，这个过程透明的。</li></ul><h4 id="–-工厂模式"><a href="#–-工厂模式" class="headerlink" title="– 工厂模式"></a>– 工厂模式</h4><p>详解：<a href="https://blog.csdn.net/qq_42804736/article/details/115168313">java工厂模式：简单工厂、工厂方法、抽象工厂（通俗易懂）_java 抽象工厂模式-CSDN博客</a></p><p>工厂模式用于<strong>创建对象</strong>，NIO 中大量用到了工厂模式，</p><ol><li>比如 <code>Files</code> 类的 <code>newInputStream</code> 方法用于创建 <code>InputStream</code> 对象（<strong>静态工厂</strong>）</li><li>Paths 类的 get 方法创建 Path 对象（静态工厂）</li><li>ZipFileSystem 类（sun.nio包下的类，属于 java.nio 相关的一些内部实现）的 getPath 的方法创建 Path 对象（<strong>简单工厂</strong>）</li></ol><h4 id="–-观察者模式"><a href="#–-观察者模式" class="headerlink" title="– 观察者模式"></a>– 观察者模式</h4><p>详解：<a href="https://segmentfault.com/a/1190000040530952">java - 一文彻底搞懂观察者模式(Observer Pattern) - 个人文章 - SegmentFault 思否</a></p><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><p>NIO 中的文件目录监听服务使用到了观察者模式。</p><ul><li>NIO 中的文件目录监听服务基于 WatchService 接口和 Watchable 接口。WatchService 属于观察者，Watchable 属于被观察者。</li><li>Watchable 接口定义了一个用于将对象注册到 WatchService（监控服务） 并绑定监听事件的方法 register 。</li></ul><h3 id="【Java-IO-模型】"><a href="#【Java-IO-模型】" class="headerlink" title="【Java IO 模型】"></a>【Java IO 模型】</h3><p><a href="https://www.javabetter.cn/sidebar/sanfene/javase.html#_44-bio">https://www.javabetter.cn/sidebar/sanfene/javase.html#_44-bio</a></p><p>三种IO</p><ul><li><p><strong>BIO(blocking I&#x2F;O)</strong> ： 就是传统的 IO，<strong>同步阻塞</strong>，服务器实现模式为一个连接一个线程，即<strong>客户端有连接请求时服务器端就需要启动一个线程进行处理</strong>，如果这个连接不做任何事情会造成不必要的线程开销，可以通过连接池机制改善(实现多个客户连接服务器)。</p><p>BIO 方式适用于<strong>连接数目比较小且固定的架构</strong>，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，程序简单易理解。</p></li><li><p><strong>NIO</strong> ：全称 java non-blocking IO，是指 JDK 提供的新 API。从 JDK1.4 开始，Java 提供了一系列改进的输入&#x2F;输出的新特性，被统称为 NIO(即 New IO)。</p><p>NIO 是<strong>同步非阻塞</strong>的，服务器端<strong>用一个线程处理多个连接</strong>，客户端发送的<strong>连接请求会注册到多路复用器上</strong>，<strong>多路复用器轮询到连接有 IO 请求就进行处理</strong>。</p><p>NIO 的数据是面向<strong>缓冲区 Buffer</strong>的，必须从 Buffer 中读取或写入。</p></li><li><p><strong>AIO</strong>：JDK 7 引入了 Asynchronous I&#x2F;O，是<strong>异步不阻塞</strong>的 IO。在进行 I&#x2F;O 编程中，常用到两种模式：Reactor 和 Proactor。Java 的 NIO 就是 Reactor，<strong>当有事件触发时，服务器端得到通知，进行相应的处理，完成后才通知服务端程序启动线程去处理</strong>，一般适用于<strong>连接数较多且连接时间较长</strong>的应用。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;持续补充！&lt;/p&gt;</summary>
    
    
    
    <category term="Java IO" scheme="https://sunrisel135.github.io/blog_lyl/categories/Java-IO/"/>
    
    
    <category term="面试" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java面试-集合</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/10/Java%E9%9D%A2%E8%AF%95-%E9%9B%86%E5%90%88/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/10/Java%E9%9D%A2%E8%AF%95-%E9%9B%86%E5%90%88/</id>
    <published>2024-03-10T01:40:11.000Z</published>
    <updated>2024-03-11T02:07:03.074Z</updated>
    
    <content type="html"><![CDATA[<p>Java集合框架总结…</p><span id="more"></span><h3 id="【集合概述】"><a href="#【集合概述】" class="headerlink" title="【集合概述】"></a>【集合概述】</h3><h4 id="–-Java集合"><a href="#–-Java集合" class="headerlink" title="– Java集合"></a>– Java集合</h4><p>Java 集合， 也叫作容器，主要是由两大接口派生而来：</p><ol><li><code>Collection</code>接口，主要用于存放<strong>单一元素</strong>；</li><li><code>Map</code> 接口，主要用于存放<strong>键值对</strong>。</li></ol><h4 id="–-说说-List-Set-Queue-Map-四者的区别？"><a href="#–-说说-List-Set-Queue-Map-四者的区别？" class="headerlink" title="– 说说 List, Set, Queue, Map 四者的区别？"></a>– 说说 List, Set, Queue, Map 四者的区别？</h4><ul><li><code>List</code>(<em>对付顺序的好帮手</em>): 存储的元素是<strong>有序的</strong>、<strong>可重复</strong>的。</li><li><code>Set</code>(<em>注重独一无二的性质</em>): 存储的元素<strong>不可重复</strong>的。</li><li><code>Queue</code>(<em>实现排队功能的叫号机</em>): 按特定的<strong>排队</strong>规则来确定先后顺序，存储的元素是<strong>有序</strong>的、<strong>可重复</strong>的。</li><li><code>Map</code>(<em>用 key 来搜索的专家</em>): 使用<strong>键值对（key-value）</strong>存储，<strong>key 是无序的、不可重复的</strong>，<strong>value 是无序的、可重复的</strong>，<strong>每个键最多映射到一个值</strong>。</li></ul><h4 id="–-集合框架底层数据结构总结"><a href="#–-集合框架底层数据结构总结" class="headerlink" title="– 集合框架底层数据结构总结"></a>– 集合框架底层数据结构总结</h4><ul><li><strong>Collection</strong><ul><li><code>List</code><ul><li><code>ArrayList</code>：**<code>Object[]</code> 数组**。详细可以查看：<a href="">ArrayList 源码分析</a>。</li><li><code>Vector</code>：<code>Object[]</code> 数组。</li><li><code>LinkedList</code>：<strong>双向链表</strong> (JDK1.6 之前为循环链表，JDK1.7 取消了循环)。详细可以查看：<a href="">LinkedList 源码分析</a>。</li></ul></li><li><code>Set</code><ul><li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 HashMap 来保存元素。</li><li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 LinkedHashMap 来实现的。</li><li><code>TreeSet</code>(有序，唯一): <strong>红黑树</strong>(自平衡的排序二叉树)</li></ul></li><li><strong>Queue</strong><ul><li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现小顶堆。详细可以查看：<a href="">PriorityQueue 源码分析</a>。</li><li><code>DelayQueue</code>:<code>PriorityQueue</code>。详细可以查看：<a href="">DelayQueue 源码分析</a>。</li><li><code>ArrayDeque</code>: 可扩容动态双向数组。</li></ul></li></ul></li><li><strong>Map</strong><ul><li><code>HashMap</code>：<strong>JDK1.8 之前</strong> <code>HashMap</code> 由<strong>数组+链表</strong>组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。<strong>JDK1.8 以后</strong>在解决哈希冲突时有了较大的变化，<strong>当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树</strong>，以减少搜索时间。详细可以查看：<a href="">HashMap 源码分析</a>。</li><li><code>LinkedHashMap</code>：<code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于<strong>拉链式散列结构即由数组和链表或红黑树组成</strong>。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条<strong>双向链表</strong>，使得上面的结构可以保持键值对的插入顺序。</li><li><code>Hashtable</code>：<strong>数组+链表</strong>组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的。</li><li><code>TreeMap</code>：红黑树（自平衡的排序二叉树）。</li></ul></li></ul><h4 id="–-如何选用集合"><a href="#–-如何选用集合" class="headerlink" title="– 如何选用集合?"></a>– 如何选用集合?</h4><ul><li>根据<strong>键值</strong>获取到元素值时就选用 <code>Map</code> 接口下的集合<ul><li>需要<strong>排序</strong>时选择 <code>TreeMap</code></li><li>不需要排序时就选择 <code>HashMap</code></li><li>需要保证<strong>线程安全</strong>就选用 <code>ConcurrentHashMap</code></li></ul></li><li>只需要存放<strong>元素值</strong>时，就选择实现<code>Collection</code> 接口的集合，<ul><li>需要<strong>保证元素唯一</strong>时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code>，</li><li>不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code>，然后再根据实现这些接口的集合的特点来选用。</li></ul></li></ul><h4 id="–-为什么要使用集合？"><a href="#–-为什么要使用集合？" class="headerlink" title="– 为什么要使用集合？"></a>– 为什么要使用集合？</h4><ul><li>数组：存储一组类型相同的数据</li><li>集合：存储的数据类型多种多样且数量不确定</li><li>Java 集合提高了数据的存储和处理灵活性，可以更好地适应现代软件开发中多样化的数据需求，并支持高质量的代码编写</li></ul><h4 id="【List】"><a href="#【List】" class="headerlink" title="【List】"></a>【List】</h4><h4 id="–-ArrayList-和-Array（数组）的区别？"><a href="#–-ArrayList-和-Array（数组）的区别？" class="headerlink" title="– ArrayList 和 Array（数组）的区别？"></a>– ArrayList 和 Array（数组）的区别？</h4><p><code>ArrayList</code> 动态数组，比 Array（静态数组） 使用起来更加灵活：</p><ul><li><code>ArrayList</code>会<strong>动态地扩容或缩容</strong>，而 <code>Array</code> 创建后就无法改变长度。</li><li><code>ArrayList</code> 可使用<strong>泛型</strong>来确保类型安全，<code>Array</code> 则不行。</li><li><code>ArrayList</code> 中<strong>只能存储对象</strong>。对于基本类型数据，需要使用其对应的<strong>包装类</strong>（如 Integer、Double 等）。<code>Array</code> 则是都可以存储。</li><li><code>ArrayList</code> 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度的数组，<strong>只能按照下标访问其中的元素，不具备动态添加、删除元素的能力</strong>。</li><li><code>ArrayList</code><strong>创建时不需要指定大小</strong>，而<code>Array</code>创建时<strong>必须指定大小</strong>。</li></ul><h4 id="–-ArrayList-和-Vector-的区别-（了解即可）"><a href="#–-ArrayList-和-Vector-的区别-（了解即可）" class="headerlink" title="– ArrayList 和 Vector 的区别?（了解即可）"></a>– ArrayList 和 Vector 的区别?（了解即可）</h4><ul><li><code>ArrayList</code> 是 List 的主要实现类，底层使用 Object[]存储，适用于频繁的查找工作，线程不安全 </li><li><code>Vector</code> 是 List 的古老实现类，底层使用Object[] 存储，<strong>线程安全</strong></li></ul><h4 id="–-Vector-和-Stack-的区别-（了解即可）"><a href="#–-Vector-和-Stack-的区别-（了解即可）" class="headerlink" title="– Vector 和 Stack 的区别?（了解即可）"></a>– Vector 和 Stack 的区别?（了解即可）</h4><ul><li><code>Vector</code> 和 Stack 两者都是线程安全的，都是使用 synchronized 关键字进行同步处理。</li><li><code>Stack</code> 继承自 Vector，是一个后进先出的栈，而 Vector 是一个列表。</li></ul><p>随着 Java 并发编程的发展，Vector 和 Stack 已经被淘汰，推荐使用并发集合类（例如 <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code> 等）或者手动实现线程安全的方法来提供安全的多线程操作支持。</p><h4 id="–-ArrayList-可以添加-null-值吗？"><a href="#–-ArrayList-可以添加-null-值吗？" class="headerlink" title="– ArrayList 可以添加 null 值吗？"></a>– ArrayList 可以添加 null 值吗？</h4><p><code>ArrayList</code> 中可以<strong>存储任何类型的对象</strong>，包括 null 值。</p><p>不建议向ArrayList 中添加 null 值， null 值无意义，会让代码难以维护比如忘记做判空处理就会导致空指针异常。</p><h4 id="–-ArrayList-插入和删除元素的时间复杂度？"><a href="#–-ArrayList-插入和删除元素的时间复杂度？" class="headerlink" title="– ArrayList 插入和删除元素的时间复杂度？"></a>– ArrayList 插入和删除元素的时间复杂度？</h4><p><strong>对于插入：</strong></p><ul><li><p><strong>头插：</strong>需将所有元素依次向后移一个位置，所以<strong>O(n)</strong></p></li><li><p><strong>尾插</strong>：<code>ArrayList</code> 的容量未达到极限时，**O(1)**，只需在数组末尾添加元素；</p><p>容量已达到极限需要扩容时，需要执行一次 <strong>O(n)</strong> 的操作将原数组复制到新的更大的数组中，然后<strong>再</strong>执行 <strong>O(1)</strong> 的操作添加元素。</p></li><li><p><strong>指定位置插入：</strong>目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n&#x2F;2 个元素，因此时间复杂度为 **O(n)**。</p></li></ul><p><strong>对于删除：</strong></p><ul><li>头部删除：需将所有元素依次向前移动一个位置，**O(n)**。</li><li>尾部删除：**O(1)**。</li><li>指定位置删除：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 **O(n)**。</li></ul><h4 id="–-LinkedList-插入和删除元素的时间复杂度？"><a href="#–-LinkedList-插入和删除元素的时间复杂度？" class="headerlink" title="– LinkedList 插入和删除元素的时间复杂度？"></a>– LinkedList 插入和删除元素的时间复杂度？</h4><ul><li>头部插入&#x2F;删除：只需修改头结点的指针即可，时间复杂度为 **O(1)**。</li><li>尾部插入&#x2F;删除：只需修改尾结点的指针即可，时间复杂度为 **O(1)**。</li><li>指定位置插入&#x2F;删除：需<strong>先移动</strong>到指定位置，<strong>再修改</strong>指定节点的指针完成插入&#x2F;删除，因此需移动平均 n&#x2F;2 个元素，时间复杂度为 **O(n)**。</li></ul><h4 id="–-RandomAccess-接口？LinkedList-为什么不能实现-RandomAccess-接口？"><a href="#–-RandomAccess-接口？LinkedList-为什么不能实现-RandomAccess-接口？" class="headerlink" title="– RandomAccess 接口？LinkedList 为什么不能实现 RandomAccess 接口？"></a>– RandomAccess 接口？LinkedList 为什么不能实现 RandomAccess 接口？</h4><p>★<code>RandomAccess</code> 是一个<strong>标记接口</strong>，用来<strong>表明实现该接口的类支持随机访问（即可以通过索引快速访问元素）</strong>。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</p><p>在 <code>binarySearch（)</code> 方法中，它要判断传入的 list 是否 <code>RandomAccess</code> 的实例，如果是，调用<code>indexedBinarySearch()</code>方法，如果不是，那么调用<code>iteratorBinarySearch()</code>方法</p><p><code>LinkedList</code> 底层数据结构是链表，内存地址不连续，<strong>只能通过指针来定位</strong>，<strong>不支持随机快速访问</strong>，所以不能实现 <code>RandomAccess</code> 接口。</p><h4 id="–-ArrayList-与-LinkedList-区别"><a href="#–-ArrayList-与-LinkedList-区别" class="headerlink" title="– ArrayList 与 LinkedList 区别?"></a>– ArrayList 与 LinkedList 区别?</h4><ul><li><p><strong>是否保证线程安全</strong>：<code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也<strong>就</strong>是<strong>不保证线程安全</strong>；</p></li><li><p><strong>底层数据结构</strong>：<code>ArrayList</code> 底层使用的是 <code>Object</code> <strong>数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。）</p></li><li><p><strong>插入和删除是否受元素位置的影响：</strong></p><p><code>ArrayList</code> 采用<strong>数组存储</strong>，插入和删除元素的时间复杂度受元素位置的影响；</p><p><code>add(E e)</code>方法， <code>ArrayList</code> 会默认追加到列表的末尾。</p><p><code>LinkedList</code> 采用<strong>链表存储</strong>，在<strong>头尾插入或者删除元素</strong>不受元素位置的影响<code>LinkedList</code> 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响。<strong>指定位置</strong>需要先移动到指定位置再插入和删除。</p></li><li><p><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code>（实现了 <code>RandomAccess</code> 接口） 支持。</p></li><li><p><strong>内存空间占用：</strong> <code>ArrayList</code> 的空间浪费主要体现在在 list 列表的结尾会<strong>预留</strong>一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p></li></ul><h4 id="–-双向链表和双向循环链表"><a href="#–-双向链表和双向循环链表" class="headerlink" title="– 双向链表和双向循环链表"></a>– 双向链表和双向循环链表</h4><ul><li><strong>双向链表：</strong> 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。</li><li><strong>双向循环链表：</strong> 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。</li></ul><h4 id="–-说一说-ArrayList-的扩容机制吧"><a href="#–-说一说-ArrayList-的扩容机制吧" class="headerlink" title="– 说一说 ArrayList 的扩容机制吧"></a>– 说一说 ArrayList 的扩容机制吧</h4><h3 id="【Set】"><a href="#【Set】" class="headerlink" title="【Set】"></a>【Set】</h3><h4 id="–-Comparable-和-Comparator-的区别"><a href="#–-Comparable-和-Comparator-的区别" class="headerlink" title="– Comparable 和 Comparator 的区别"></a>– Comparable 和 Comparator 的区别</h4><p>都是 Java 中用于排序的接口。</p><p>需要对一个集合使用自定义排序时，我们就要重写<code>compareTo()</code>方法或<code>compare()</code>方法。</p><p>需要对某一个集合实现两种排序方式时，可以重写compareTo()方法和使用自制的Comparator方法或者以两个 Comparator 来实现。</p><ul><li><code>Comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li><li><code>Comparator</code>接口实际上是出自 <code>java.util</code> 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序。<code>Comparator</code> <strong>定制排序</strong>。</li></ul><h4 id="–-无序性和不可重复性的含义是什么"><a href="#–-无序性和不可重复性的含义是什么" class="headerlink" title="– 无序性和不可重复性的含义是什么"></a>– 无序性和不可重复性的含义是什么</h4><ul><li><strong>无序性</strong>不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的<strong>顺序</strong>添加 ，而是根据数据的哈希值决定的。</li><li><strong>不可重复性</strong>是指添加的元素按照 <code>equals()</code> 判断时 ，返回 false，需要同时重写 <code>equals()</code> 方法和 <code>hashCode()</code> 方法。</li></ul><h4 id="–-比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#–-比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="– 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>– 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h4><ul><li>都是 <code>Set</code> 接口的实现类，都能保证<strong>元素唯一</strong>，并且都<strong>不</strong>是<strong>线程安全</strong>的。</li><li><strong>底层数据结构：</strong><code>HashSet</code> 的底层数据结构是<strong>哈希表</strong>（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是<strong>链表和哈希表</strong>，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是<strong>红黑树</strong>，元素是有序的，排序的方式有<strong>自然排序</strong>和<strong>定制排序</strong>。</li><li><strong>应用场景：</strong><code>HashSet</code> <strong>不</strong>能保证元素插入和取出的<strong>有序</strong>，<code>LinkedHashSet</code> 用于保证元素的插入和取出<strong>顺序</strong>满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素<strong>自定义排序规则</strong>的场景。</li></ul><h3 id="【Queue】"><a href="#【Queue】" class="headerlink" title="【Queue】"></a>【Queue】</h3><h4 id="–-Queue-与-Deque-的区别"><a href="#–-Queue-与-Deque-的区别" class="headerlink" title="– Queue 与 Deque 的区别"></a>– Queue 与 Deque 的区别</h4><ul><li><p><code>Queue</code> 是单端队列，只能从<strong>一端插</strong>入元素，<strong>另一端删除</strong>元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p><p> 扩展了 <code>Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p></li><li><p><code>Deque</code> 是双端队列，扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法</p><p>同样根据失败后处理方式的不同分为两类。事实上，Deque 还提供有 push() 和 pop() 等其他方法，可用于模拟栈。</p></li></ul><h4 id="–-ArrayDeque-与-LinkedList-的区别"><a href="#–-ArrayDeque-与-LinkedList-的区别" class="headerlink" title="– ArrayDeque 与 LinkedList 的区别"></a>– ArrayDeque 与 LinkedList 的区别</h4><p>都实现了 <code>Deque</code> 接口，两者都具有队列的功能。</p><ul><li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li><li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li><li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li><li>从<strong>性能</strong>的角度上，选用 <code>ArrayDeque</code> 来实现队列更好。<code>ArrayDeque</code> 也可以用于实现栈。</li></ul><h3 id="【Map】"><a href="#【Map】" class="headerlink" title="【Map】"></a>【Map】</h3><h4 id="–-HashMap-和-Hashtable-的区别"><a href="#–-HashMap-和-Hashtable-的区别" class="headerlink" title="– HashMap 和 Hashtable 的区别"></a>– HashMap 和 Hashtable 的区别</h4><ul><li><p><strong>线程是否安全：</strong><code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</p></li><li><p><code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰；</p></li><li><p><code>HashMap</code>的key可以存储1个null，value可以有多个； Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</p></li><li><p><strong>初始容量大小和每次扩充容量大小的不同</strong>：</p><ul><li><p><code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1</p></li><li><p>创建时如果给定了容量初始值，那么 <code>Hashtable</code> 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <strong><code>HashMap</code> 总是使用 2 的幂作为哈希表的大小</strong>,后面会介绍到为什么是 2 的幂次方。</p></li></ul></li><li><p><strong>底层数据结构</strong></p><p><code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间。<code>Hashtable</code> 没有这样的机制。</p></li></ul><h4 id="–-HashMap-和-HashSet-区别"><a href="#–-HashMap-和-HashSet-区别" class="headerlink" title="– HashMap 和 HashSet 区别"></a>– HashMap 和 HashSet 区别</h4><p><code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。</p><ul><li><code>HashMap</code>实现了 <code>Map</code> 接口，存储键值对，调用 <code>put()</code>向 map 中添加元素，HashMap<code>使用键（Key）计算</code>hashcode。</li><li><code>HashSet</code>实现 <code>Set</code> 接口，仅存储对象，调用 <code>add()</code>方法向 <code>Set</code> 中添加元素，使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</li></ul><h4 id="–-HashMap-和-TreeMap-区别"><a href="#–-HashMap-和-TreeMap-区别" class="headerlink" title="– HashMap 和 TreeMap 区别"></a>– HashMap 和 TreeMap 区别</h4><p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p><ul><li>相比于<code>HashMap</code>来说 <code>TreeMap</code> 主要多了对集合中的元素根据键<strong>排序</strong>的能力以及<strong>对集合内元素的搜索</strong>的能力。</li></ul><h4 id="–-HashSet-如何检查重复-★"><a href="#–-HashSet-如何检查重复-★" class="headerlink" title="– HashSet 如何检查重复? ★"></a>– HashSet 如何检查重复? ★</h4><p>对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p><h4 id="–-HashMap-的底层实现-★"><a href="#–-HashMap-的底层实现-★" class="headerlink" title="– HashMap 的底层实现 ★"></a>– HashMap 的底层实现 ★</h4><ul><li><p><strong>JDK1.8 之前</strong> <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 <code>hashcode</code> 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p></li><li><p>所谓扰动函数指的就是 HashMap 的 <code>hash</code> 方法。使用 <code>hash</code> 方法也就是扰动函数是为了防止一些实现比较差的 <code>hashCode()</code> 方法 换句话说使用扰动函数之后可以减少碰撞。</p></li><li><p><strong>JDK1.8 之后</strong>在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p></li><li><p><strong>拉链法”</strong> ：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p></li></ul><h4 id="–-HashMap-的长度为什么是-2-的幂次方"><a href="#–-HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="– HashMap 的长度为什么是 2 的幂次方"></a>– HashMap 的长度为什么是 2 的幂次方</h4><p>为了<strong>加快哈希计算</strong>以及<strong>减少哈希冲突</strong>。</p><p><strong>“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。”</strong> 并且 <strong>采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。</strong></p><h4 id="–-HashMap-多线程操作导致死循环问题"><a href="#–-HashMap-多线程操作导致死循环问题" class="headerlink" title="– HashMap 多线程操作导致死循环问题"></a>– HashMap 多线程操作导致死循环问题</h4><p>JDK1.7 及之前版本的 <code>HashMap</code> 在多线程环境下<strong>扩容操作</strong>可能存在死循环问题，这是由于当一个桶位中有多个元素需要进行扩容时，多个线程同时<strong>对链表进行操作</strong>，<strong>头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束</strong>。</p><p>JDK1.8 版本的 <code>HashMap</code> 采用了<strong>尾插法</strong>而不是头插法来避免链表倒置，使得<strong>插入的节点永远都是放在链表的末尾，避免了链表中的环形结构</strong>。</p><p>并发环境下，推荐使用 <code>ConcurrentHashMap</code> 。</p><h4 id="–-HashMap-为什么线程不安全？"><a href="#–-HashMap-为什么线程不安全？" class="headerlink" title="– HashMap 为什么线程不安全？"></a>– HashMap 为什么线程不安全？</h4><p>JDK1.7 及之前版本，在多线程环境下，<code>HashMap</code> 扩容时会造成死循环和数据丢失的问题。</p><p>JDK 1.8 后，在 <code>HashMap</code> 中，多个键值对可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。多个线程对 <code>HashMap</code> 的 <code>put</code> 操作会导致线程不安全，具体来说会有数据覆盖的风险。</p><h4 id="–-HashMap-常见的遍历方式"><a href="#–-HashMap-常见的遍历方式" class="headerlink" title="– HashMap 常见的遍历方式?"></a>– HashMap 常见的遍历方式?</h4><p><strong>存在阻塞时 parallelStream 性能最高, 非阻塞时 parallelStream 性能最低</strong> 。</p><h4 id="–-ConcurrentHashMap-和-Hashtable-的区别"><a href="#–-ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="– ConcurrentHashMap 和 Hashtable 的区别"></a>– ConcurrentHashMap 和 Hashtable 的区别</h4><p>区别主要体现在<strong>实现线程安全的方式</strong>上不同。</p><ul><li><p><strong>底层数据结构：</strong></p><ul><li><code>ConcurrentHashMap</code>，JDK1.7采用分段的数组+链表，JDK1.8采用数组+链表&#x2F;红黑二叉树。</li><li><code>Hashtable</code>，<strong>数组+链表</strong></li></ul></li><li><p><strong>实现线程安全的方式（重要）：</strong></p><ul><li>JDK1.7，<code>ConcurrentHashMap</code>对整个桶数组进行了分割分段(<code>Segment</code>，<strong>分段锁</strong>)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</li><li>JDK1.8，<code>ConcurrentHashMap</code> 直接用 <code>Node</code> 数组+链表+红黑树的数据结构，并发控制使用 <code>synchronized</code> 和 <strong>CAS</strong> 来操作。（JDK1.6 以后 <code>synchronized</code> 锁做了很多优化） 存在旧的东西就是为了<strong>向下兼容</strong>版本。</li><li><strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。</li></ul></li></ul><h4 id="–-ConcurrentHashMap-线程安全的具体实现方式-底层具体实现"><a href="#–-ConcurrentHashMap-线程安全的具体实现方式-底层具体实现" class="headerlink" title="– ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现"></a>– ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现</h4><h4 id="–-JDK-1-7-和-JDK-1-8-的-ConcurrentHashMap-实现有什么不同？"><a href="#–-JDK-1-7-和-JDK-1-8-的-ConcurrentHashMap-实现有什么不同？" class="headerlink" title="– JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？"></a>– JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？</h4><ul><li><strong>线程安全实现方式</strong>：JDK 1.7 ， <code>Segment</code> 分段锁， <code>Segment</code> 继承自 <code>ReentrantLock</code>。JDK1.8 ，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</li><li><strong>Hash 碰撞解决方法</strong> : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树</li><li><strong>并发度</strong>：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</li></ul><h4 id="–-ConcurrentHashMap-为什么-key-和-value-不能为-null？"><a href="#–-ConcurrentHashMap-为什么-key-和-value-不能为-null？" class="headerlink" title="– ConcurrentHashMap 为什么 key 和 value 不能为 null？"></a>– ConcurrentHashMap 为什么 key 和 value 不能为 null？</h4><p>避免二义性，</p><p>用 null 作为键，那么你就无法区分这个键是否存在于 <code>ConcurrentHashMap</code> 中，还是根本没有这个键。同样，</p><p>用 null 作为值，那么你就无法区分这个值是否是真正存储在 <code>ConcurrentHashMap</code> 中的，还是因为找不到对应的键而返回的。</p><h4 id="–-ConcurrentHashMap-能保证复合操作的原子性吗？"><a href="#–-ConcurrentHashMap-能保证复合操作的原子性吗？" class="headerlink" title="– ConcurrentHashMap 能保证复合操作的原子性吗？"></a>– ConcurrentHashMap 能保证复合操作的原子性吗？</h4><p>不一定！</p><ul><li><code>ConcurrentHashMap</code> 是线程安全的，可以保证多个线程同时对它进行读写操作时，不会出现数据不一致的情况和死循环问题。</li><li>复合操作是指由多个基本操作(如<code>put</code>、<code>get</code>、<code>remove</code>、<code>containsKey</code>等)组成的操作。这种操作在执行过程中可能会<strong>被其他线程打断</strong>，导致结果不符合预期。</li></ul><p><strong>那如何保证 <code>ConcurrentHashMap</code> 复合操作的原子性呢？</strong></p><p><code>ConcurrentHashMap</code> 提供了一些原子性的复合操作，如 <code>putIfAbsent</code>、<code>compute</code>、<code>computeIfAbsent</code> 、<code>computeIfPresent</code>、<code>merge</code>等。这些<strong>方法</strong>都可以接受一个函数作为参数，根据给定的 key 和 value 来计算一个新的 value，并且将其更新到 map 中。</p><h3 id="【Collections-工具类（不重要）】"><a href="#【Collections-工具类（不重要）】" class="headerlink" title="【Collections 工具类（不重要）】"></a>【Collections 工具类（不重要）】</h3><p><strong><code>Collections</code> 工具类常用方法</strong>:</p><ul><li>排序</li><li>查找,替换操作</li><li>同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)</li></ul><h3 id="【其他-注意项】"><a href="#【其他-注意项】" class="headerlink" title="【其他 注意项】"></a>【其他 注意项】</h3><h4 id="–-集合判空"><a href="#–-集合判空" class="headerlink" title="– 集合判空"></a>– 集合判空</h4><p>判断所有集合内部的元素是否为空，使用 <code>isEmpty()</code> 方法，而不是 <code>size()==0</code> 的方式。</p><p>这是因为 **isEmpty() 方法的可读性更好，并且时间复杂度为 O(1)**。</p><h4 id="–-集合转-Map"><a href="#–-集合转-Map" class="headerlink" title="– 集合转 Map"></a>– 集合转 Map</h4><p>在使用 <code>java.util.stream.Collectors</code> 类的 <code>toMap()</code> 方法转为 <code>Map</code> 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。</p><h4 id="–-集合遍历"><a href="#–-集合遍历" class="headerlink" title="– 集合遍历"></a>– 集合遍历</h4><p>不要在 <code>foreach</code> 循环里进行元素的 <code>remove/add</code> 操作。<code>remove</code> 元素请使用 <code>Iterator</code> 方式，如果并发操作，需要对 <code>Iterator</code> 对象加锁。</p><ul><li>foreach 语法底层其实还是依赖 <code>Iterator</code> 。不过， <code>remove/add</code> 操作直接调用的是集合自己的方法，而不是 <code>Iterator</code> 的 <code>remove/add</code>方法。这就导致 <code>Iterator</code> 莫名其妙地发现自己有元素被 <code>remove/add</code> ，然后，它就会抛出一个 <code>ConcurrentModificationException</code> 来提示用户发生了并发修改异常。这就是单线程状态下产生的 <strong>fail-fast 机制</strong>。</li><li><strong>fail-fast 机制</strong>：多个线程对 fail-fast 集合进行修改的时候，可能会抛出<code>ConcurrentModificationException</code>。 即使是单线程下也有可能会出现这种情况，上面已经提到过。</li></ul><h4 id="–-集合去重"><a href="#–-集合去重" class="headerlink" title="– 集合去重"></a>– 集合去重</h4><p>可以利用 <strong><code>Set</code></strong> 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 <code>List</code> 的 <code>contains()</code> 进行遍历去重或者判断包含操作。</p><h4 id="–-集合转数组"><a href="#–-集合转数组" class="headerlink" title="– 集合转数组"></a>– 集合转数组</h4><p>使用集合转数组的方法，必须使用集合的 <strong><code>toArray(T[] array)</code><strong>，</strong>传入的是类型完全一致、长度为 0 的空数组</strong>。</p><h4 id="–-数组转集合"><a href="#–-数组转集合" class="headerlink" title="– 数组转集合"></a>– 数组转集合</h4><p>使用工具类 <code>Arrays.asList()</code> 把数组转换成集合时，不能使用其修改集合相关的方法， 它的 <code>add/remove/clear</code> 方法会抛出 <code>UnsupportedOperationException</code> 异常。</p><ul><li><code>Arrays.asList()</code>是泛型方法，传递的数组必须是对象数组，而不是基本类型。</li><li>使用集合的修改方法: <code>add()</code>、<code>remove()</code>、<code>clear()</code>会抛出异常。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java集合框架总结…&lt;/p&gt;</summary>
    
    
    
    <category term="Java集合" scheme="https://sunrisel135.github.io/blog_lyl/categories/Java%E9%9B%86%E5%90%88/"/>
    
    
    <category term="面试" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java面试-并发编程</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/08/Java%E9%9D%A2%E8%AF%95-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/08/Java%E9%9D%A2%E8%AF%95-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</id>
    <published>2024-03-08T05:45:56.000Z</published>
    <updated>2024-03-08T07:51:13.415Z</updated>
    
    <content type="html"><![CDATA[<p>常看常新，持续更新…</p><span id="more"></span><h3 id="【线程】"><a href="#【线程】" class="headerlink" title="【线程】"></a>【线程】</h3><h4 id="–-什么是线程和进程"><a href="#–-什么是线程和进程" class="headerlink" title="– 什么是线程和进程?"></a>– 什么是线程和进程?</h4><h5 id="进程？"><a href="#进程？" class="headerlink" title="进程？"></a>进程？</h5><ul><li><strong>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。</strong></li><li>系统运行一个程序即是一个进程从创建，运行到消亡的过程。</li><li>Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</li></ul><h5 id="线程"><a href="#线程" class="headerlink" title="线程?"></a>线程?</h5><ul><li><strong>与进程相似，线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。</strong></li><li>与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</li></ul><h5 id="用户线程、内核线程？"><a href="#用户线程、内核线程？" class="headerlink" title="用户线程、内核线程？"></a>用户线程、内核线程？</h5><ul><li>用户线程 (jdk1.2前)：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）。<br>内核线程 (jdk1.2及以后)：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）。</li><li>现在的 Java 线程的本质其实就是操作系统的线程。</li></ul><h4 id="–-线程与进程的关系-区别及优缺点？"><a href="#–-线程与进程的关系-区别及优缺点？" class="headerlink" title="– 线程与进程的关系,区别及优缺点？"></a>– 线程与进程的关系,区别及优缺点？</h4><p>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p><h4 id="–-并发与并行的区别"><a href="#–-并发与并行的区别" class="headerlink" title="– 并发与并行的区别"></a>– 并发与并行的区别</h4><ul><li><strong>并发</strong>：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li><li><strong>并行</strong>：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li></ul><p>最关键的点是：是否是 <strong>同时</strong> 执行。</p><h4 id="–-同步和异步的区别"><a href="#–-同步和异步的区别" class="headerlink" title="– 同步和异步的区别"></a>– 同步和异步的区别</h4><ul><li>同步：发出一个调用之后，在<strong>没有得到结果之前</strong>， 该调用就不可以返回，<strong>一直等待</strong>。</li><li>异步：调用在发出之后，<strong>不用等待返回结果</strong>，该调用直接返回。</li></ul><h4 id="–-为什么要使用多线程"><a href="#–-为什么要使用多线程" class="headerlink" title="– 为什么要使用多线程?"></a>– 为什么要使用多线程?</h4><ul><li>线程是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li><li>可以大大提高系统整体的并发能力以及性能。</li></ul><h4 id="–-使用多线程可能带来什么问题"><a href="#–-使用多线程可能带来什么问题" class="headerlink" title="– 使用多线程可能带来什么问题?"></a>– 使用多线程可能带来什么问题?</h4><p>并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：<strong>内存泄漏、死锁、线程不安全</strong>等。</p><h4 id="–-如何理解线程安全？"><a href="#–-如何理解线程安全？" class="headerlink" title="– 如何理解线程安全？"></a>– 如何理解线程安全？</h4><p><strong>多线程环境下对于同一份数据的访问是否能够保证其正确性和一致性。</strong></p><p>线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。</p><h4 id="–-线程的生命周期和状态-★"><a href="#–-线程的生命周期和状态-★" class="headerlink" title="– 线程的生命周期和状态? ★"></a>– 线程的生命周期和状态? ★</h4><p>六种状态：</p><ul><li><strong>NEW: 初始状态</strong>，线程被创建出来但没有被调用 <code>start()</code> 。</li><li><strong>RUNNABLE: 运行状态</strong>，线程被调用了 <code>start()</code>等待运行的状态。</li><li><strong>BLOCKED：阻塞状态</strong>，需要等待锁释放。</li><li><strong>WAITING：等待状态</strong>，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</li><li><strong>TIME_WAITING：超时等待状态</strong>，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</li><li><strong>TERMINATED：终止状态</strong>，表示该线程已经运行完毕。</li></ul><ol><li>线程创建之后它将处于 NEW（新建） 状态，调用 start() 方法后开始运行，线程这时候处于 READY（可运行） 状态。</li><li>可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 RUNNING（运行） 状态。</li><li>当线程执行 wait()方法之后，线程进入 WAITING（等待） 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。</li><li>TIMED_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制，比如通过 sleep（long millis）方法或 wait（long millis）方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。</li><li>当线程进入 synchronized 方法&#x2F;块或者调用 wait 后（被 notify）重新进入 synchronized 方法&#x2F;块，但是锁被其它线程占有，这个时候线程就会进入 BLOCKED（阻塞） 状态。</li><li>线程在执行完了 run()方法之后之后将会进入到 TERMINATED（终止） 状态。</li></ol><h4 id="–-什么是线程上下文切换"><a href="#–-什么是线程上下文切换" class="headerlink" title="– 什么是线程上下文切换?"></a>– 什么是线程上下文切换?</h4><p>当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p><ul><li>主动让出 CPU，比如调用了 sleep(), wait() 等。</li><li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li><li>被终止或结束运行</li></ul><p>这其中前三种都会发生线程切换，<strong>线程切换</strong>意味着<strong>需要保存当前线程的上下文</strong>，<strong>待线程下次占用 CPU 的时候恢复</strong>现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 上下文切换。</p><p>因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p><h4 id="–-什么是线程死锁-如何避免死锁"><a href="#–-什么是线程死锁-如何避免死锁" class="headerlink" title="– 什么是线程死锁?如何避免死锁?"></a>– 什么是线程死锁?如何避免死锁?</h4><h5 id="什么是死锁："><a href="#什么是死锁：" class="headerlink" title="什么是死锁："></a>什么是死锁：</h5><ul><li><strong>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。</strong>由于线程被无限期地阻塞，因此程序不可能正常终止。</li><li>线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</li></ul><h5 id="产生死锁的四个必要条件："><a href="#产生死锁的四个必要条件：" class="headerlink" title="产生死锁的四个必要条件："></a>产生死锁的四个必要条件：</h5><ol><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。如何预防和避</li></ol><h5 id="预防和避免线程死锁："><a href="#预防和避免线程死锁：" class="headerlink" title="预防和避免线程死锁："></a>预防和避免线程死锁：</h5><p>破坏死锁的产生的必要条件即可：</p><ol><li>破坏请求与保持条件：一次性申请所有的资源。</li><li>破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li>破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li></ol><p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态</p><h4 id="–-sleep-方法和-wait-方法对比"><a href="#–-sleep-方法和-wait-方法对比" class="headerlink" title="– sleep() 方法和 wait() 方法对比"></a>– sleep() 方法和 wait() 方法对比</h4><p><strong>共同点</strong>：两者都可以暂停线程的执行。</p><p><strong>区别</strong>: </p><ul><li><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁 。</li><li><code>wait()</code> 通常被用于线程间交互&#x2F;通信，<code>sleep()</code>通常被用于暂停执行。</li><li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li><li><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法（因为wait要释放当前线程占有的对象锁，操作的对象自然是Object）。</li></ul><h4 id="–-可以直接调用-Thread-类的-run-方法吗？"><a href="#–-可以直接调用-Thread-类的-run-方法吗？" class="headerlink" title="– 可以直接调用 Thread 类的 run 方法吗？"></a>– 可以直接调用 Thread 类的 run 方法吗？</h4><p><strong>调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。</strong></p><h3 id="【volatile-关键字】"><a href="#【volatile-关键字】" class="headerlink" title="【volatile 关键字】"></a>【volatile 关键字】</h3><h4 id="–-volatile总结"><a href="#–-volatile总结" class="headerlink" title="– volatile总结"></a>– volatile总结</h4><ul><li>volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。</li><li>防止 JVM 的指令重排序。</li></ul><h4 id="–-保证变量的可见性？"><a href="#–-保证变量的可见性？" class="headerlink" title="– 保证变量的可见性？"></a>– 保证变量的可见性？</h4><p>将变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JMM(Java内存模型): </span><br><span class="line">线程1 &lt;-&gt; 本地内存(共享变量副本) &lt;--&gt; 主内存-共享变量</span><br><span class="line">强制在主内存中进行读取:</span><br><span class="line">线程1 &lt;-&gt; 本地内存(共享变量副本) &lt;--&gt; 主内存-共享变量</span><br><span class="line"> &lt;---------------------&gt; 主内存-共享变量</span><br></pre></td></tr></table></figure><h4 id="–-volatile-可以保证原子性么？"><a href="#–-volatile-可以保证原子性么？" class="headerlink" title="– volatile 可以保证原子性么？"></a>– volatile 可以保证原子性么？</h4><p>不能。</p><ul><li><p>线程 1 对 inc 进行读取操作之后，还未对其进行修改。线程 2 又读取了 inc的值并对其进行修改（+1），再将inc 的值写回内存。</p><p>线程 2 操作完毕后，线程 1 对 inc的值进行修改（+1），再将inc 的值写回内存。</p><p>这也就导致两个线程分别对 inc 进行了一次自增操作后，inc 实际上只增加了 1。</p></li><li><p>如果想要保证上面的代码运行正确也非常简单，利用 synchronized、Lock或者AtomicInteger都可以。</p></li></ul><h4 id="–-禁止指令重排序？"><a href="#–-禁止指令重排序？" class="headerlink" title="– 禁止指令重排序？"></a>– 禁止指令重排序？</h4><p>将变量声明为 volatile ，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。</p><h4 id="–-指令重排序"><a href="#–-指令重排序" class="headerlink" title="– 指令重排序"></a>– 指令重排序</h4><ul><li><p>为了提升执行速度&#x2F;性能，计算机在执行程序代码的时候，会对指令进行重排序。</p></li><li><p>系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行</p></li><li><p>常见的指令重排序有下面 2 种情况：</p><ul><li><p>编译器优化重排：编译器（包括 JVM、JIT 编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序。</p></li><li><p>指令并行重排：现代处理器采用了指令级并行技术(Instruction-Level Parallelism，ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p></li></ul></li><li><p>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致 ，所以在多线程下，指令重排序可能会导致一些问题。</p></li></ul><h4 id="–-乐观锁和悲观锁"><a href="#–-乐观锁和悲观锁" class="headerlink" title="– 乐观锁和悲观锁"></a>– 乐观锁和悲观锁</h4><h5 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h5><ul><li>总是假设最坏的情况。<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。</strong></li><li>synchronized 和 ReentrantLock 等<strong>独占锁</strong>就是悲观锁思想的实现。</li></ul><h5 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h5><ul><li>总是假设最好的情况。</li><li>共享资源每次被访问的时候不会出现问题，<strong>线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源</strong>（也就是数据）<strong>是否被其它线程修改了</strong>（具体方法可以使用<strong>版本号机制</strong>或 <strong>CAS 算法</strong>）。</li></ul><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul><li>悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。如果乐观锁解决了频繁失败和重试这个问题的话（比如LongAdder），也是可以考虑使用乐观锁的，要视实际情况而定。</li><li>乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。主要针对的对象是单个共享变量。</li></ul><h5 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h5><p>在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。</p><h5 id="CAS算法-乐观锁使用更多"><a href="#CAS算法-乐观锁使用更多" class="headerlink" title="CAS算法(乐观锁使用更多)"></a>CAS算法(乐观锁使用更多)</h5><p>用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</p><h3 id="【synchronized-关键字】"><a href="#【synchronized-关键字】" class="headerlink" title="【synchronized 关键字】"></a>【synchronized 关键字】</h3><ul><li>Java 中的一个关键字，主要解决的是<strong>多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行</strong>。</li><li>Java 6 进行了<strong>优化</strong></li><li><strong>修饰实例方法、修饰静态方法、修饰代码块</strong></li></ul><h4 id="–-构造方法可以用-synchronized-修饰么？"><a href="#–-构造方法可以用-synchronized-修饰么？" class="headerlink" title="– 构造方法可以用 synchronized 修饰么？"></a>– 构造方法可以用 synchronized 修饰么？</h4><p>构造方法本身就属于线程安全的，不存在同步的构造方法一说。</p><h4 id="–-synchronized-和-volatile-有什么区别？"><a href="#–-synchronized-和-volatile-有什么区别？" class="headerlink" title="– synchronized 和 volatile 有什么区别？"></a>– synchronized 和 volatile 有什么区别？</h4><p>互补。</p><ul><li>volatile 关键字是线程同步的轻量级实现，所以 volatile性能肯定比synchronized关键字要好 。但是 volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块 。</li><li>volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。</li><li>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。</li></ul><h3 id="【ReentrantLock】"><a href="#【ReentrantLock】" class="headerlink" title="【ReentrantLock】"></a>【ReentrantLock】</h3><h4 id="–-ReentrantLock-是什么？"><a href="#–-ReentrantLock-是什么？" class="headerlink" title="– ReentrantLock 是什么？"></a>– ReentrantLock 是什么？</h4><ul><li>实现了 <strong><code>Lock</code></strong> 接口，是一个<strong>可重入且独占式的锁</strong>，和 synchronized 关键字类似。不过，ReentrantLock 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</li><li>ReentrantLock 默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁。</li></ul><h4 id="–-公平锁和非公平锁有什么区别？"><a href="#–-公平锁和非公平锁有什么区别？" class="headerlink" title="– 公平锁和非公平锁有什么区别？"></a>– 公平锁和非公平锁有什么区别？</h4><ul><li><strong>公平锁</strong> : 锁被释放之后，<strong>先申请的线程先得到锁</strong>。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</li><li>非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</li></ul><h4 id="–-synchronized-和-ReentrantLock-有什么区别？"><a href="#–-synchronized-和-ReentrantLock-有什么区别？" class="headerlink" title="– synchronized 和 ReentrantLock 有什么区别？"></a>– synchronized 和 ReentrantLock 有什么区别？</h4><ul><li><strong>两者都是可重入锁</strong><ul><li>可重入锁 也叫递归锁，指的是线程<strong>可以再次获取自己的内部锁</strong>。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</li><li>JDK 提供的所有现成的 Lock 实现类，包括 synchronized 关键字锁都是可重入的。</li></ul></li><li><strong>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</strong></li><li><strong>相比synchronized，ReentrantLock增加了一些高级功能</strong><ul><li>等待可中断</li><li>可实现公平锁</li><li>可实现选择性通知（锁可以绑定多个条件）</li></ul></li></ul><h4 id="–-可中断锁和不可中断锁有什么区别？"><a href="#–-可中断锁和不可中断锁有什么区别？" class="headerlink" title="– 可中断锁和不可中断锁有什么区别？"></a>– 可中断锁和不可中断锁有什么区别？</h4><ul><li>可中断锁：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。ReentrantLock 就属于是可中断锁。</li><li>不可中断锁：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 synchronized 就属于是不可中断锁。</li></ul><h3 id="【ThreadLocal】"><a href="#【ThreadLocal】" class="headerlink" title="【ThreadLocal】"></a>【ThreadLocal】</h3><h4 id="–-ThreadLocal-有什么用？"><a href="#–-ThreadLocal-有什么用？" class="headerlink" title="– ThreadLocal 有什么用？"></a>– ThreadLocal 有什么用？</h4><ul><li>ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以<strong>存储每个线程的私有数据</strong>。</li><li>创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，可以使用 get() 和 set() 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</li></ul><h4 id="–-ThreadLocal-原理了解吗？"><a href="#–-ThreadLocal-原理了解吗？" class="headerlink" title="– ThreadLocal 原理了解吗？"></a>– ThreadLocal 原理了解吗？</h4><ul><li>最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。</li><li>每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为 key ，Object 对象为 value 的键值对。</li></ul><h4 id="–-ThreadLocal-内存泄露问题是怎么导致的？"><a href="#–-ThreadLocal-内存泄露问题是怎么导致的？" class="headerlink" title="– ThreadLocal 内存泄露问题是怎么导致的？"></a>– ThreadLocal 内存泄露问题是怎么导致的？</h4><ul><li>ThreadLocalMap 中使用的 key 为 ThreadLocal 的<strong>弱引用</strong>，而 value 是<strong>强引用</strong>。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</li><li><strong>使用完 ThreadLocal方法后最好手动调用remove()方法</strong></li><li><strong>弱引用</strong>：在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</li></ul><h3 id="【线程池】"><a href="#【线程池】" class="headerlink" title="【线程池】"></a>【线程池】</h3><h4 id="–-线程池？"><a href="#–-线程池？" class="headerlink" title="– 线程池？"></a>– 线程池？</h4><ul><li>管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</li><li>使用线程池的好处：<ul><li>降低资源消耗</li><li>提高响应速度</li><li>提高线程的可管理性</li></ul></li></ul><h4 id="–-如何创建线程池？"><a href="#–-如何创建线程池？" class="headerlink" title="– 如何创建线程池？"></a>– 如何创建线程池？</h4><p>方式一：通过**<code>ThreadPoolExecutor</code>**构造函数来创建（推荐）</p><p>方式二：通过 <strong>Executor 框架</strong>的工具类 <strong>Executors</strong> 来创建。</p><h4 id="–-线程池常见参数有哪些？"><a href="#–-线程池常见参数有哪些？" class="headerlink" title="– 线程池常见参数有哪些？"></a>– 线程池常见参数有哪些？</h4><ul><li><p>ThreadPoolExecutor 3 个最重要的参数：</p><ul><li><strong>corePoolSize</strong> : 任务队列未达到队列容量时，<strong>最大可以同时运行的线程数量</strong>。</li><li><strong>maximumPoolSize</strong> : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong>workQueue:</strong> 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul></li><li><p>ThreadPoolExecutor其他常见参数 :</p><ul><li><p>keepAliveTime:线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，多余的空闲线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁，线程池回收线程时，会对核心线程和非核心线程一视同仁，直到线程池中线程的数量等于 corePoolSize ，回收过程才会停止</p></li><li><p>unit : keepAliveTime 参数的时间单位</p></li><li><p>threadFactory :executor 创建新线程的时候会用到</p></li><li><p>handler :<strong>饱和策略</strong></p></li></ul></li></ul><h4 id="–-线程池的饱和策略有哪些？"><a href="#–-线程池的饱和策略有哪些？" class="headerlink" title="– 线程池的饱和策略有哪些？"></a>– 线程池的饱和策略有哪些？</h4><ul><li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。(spring默认策略)</li><li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li><li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li><li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。</li></ul><h4 id="–-线程池常用的阻塞队列有哪些？"><a href="#–-线程池常用的阻塞队列有哪些？" class="headerlink" title="– 线程池常用的阻塞队列有哪些？"></a>– 线程池常用的阻塞队列有哪些？</h4><p>新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</p><ul><li>容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue（无界队列）</li><li>SynchronousQueue（同步队列）</li><li>DelayedWorkQueue（延迟阻塞队列）</li></ul><h4 id="–-线程池处理任务的流程了解吗？"><a href="#–-线程池处理任务的流程了解吗？" class="headerlink" title="– 线程池处理任务的流程了解吗？"></a>– 线程池处理任务的流程了解吗？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">提交任务 -》 核心线程池是否已满 -Y-》等待队列是否已满 -Y-》线程池是否已满 -Y-》按照策略处理</span><br><span class="line">   -N 》创建线程   - N-》创建队列 -N-》创建线程</span><br></pre></td></tr></table></figure><h3 id="【Future】"><a href="#【Future】" class="headerlink" title="【Future】"></a>【Future】</h3><h4 id="–-Future-类有什么用？"><a href="#–-Future-类有什么用？" class="headerlink" title="– Future 类有什么用？"></a>– Future 类有什么用？</h4><ul><li><p>当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 Future 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p></li><li><p>多线程中经典的 Future 模式，你可以将其看作是一种设计模式，核心思想是异步调用</p></li><li><p>Future 类只是一个泛型接口，位于 java.util.concurrent 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p><ul><li><p>取消任务；</p></li><li><p>判断任务是否被取消;</p></li><li><p>判断任务是否已经执行完成;</p></li><li><p>获取任务执行结果。</p></li></ul></li></ul><h3 id="【AQS】"><a href="#【AQS】" class="headerlink" title="【AQS】"></a>【AQS】</h3><h4 id="–-AQS-是什么？"><a href="#–-AQS-是什么？" class="headerlink" title="– AQS 是什么？"></a>– AQS 是什么？</h4><ul><li>AQS 的全称为 AbstractQueuedSynchronizer ，翻译过来的意思就是抽象队列同步器。</li><li>AQS 就是一个抽象类，主要用来构建锁和同步器。</li><li>AQS 为构建锁和同步器提供了一些通用功能的实现，因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue等等皆是基于 AQS 的。</li></ul><h3 id="【虚拟线程】"><a href="#【虚拟线程】" class="headerlink" title="【虚拟线程】"></a>【虚拟线程】</h3><h3 id="【JMM-Java内存模型-】"><a href="#【JMM-Java内存模型-】" class="headerlink" title="【JMM (Java内存模型)】"></a>【JMM (Java内存模型)】</h3><p><strong>抽象线程和主内存之间的关系</strong></p><h4 id="–-Java-内存区域和-JMM-有何区别？"><a href="#–-Java-内存区域和-JMM-有何区别？" class="headerlink" title="– Java 内存区域和 JMM 有何区别？"></a>– Java 内存区域和 JMM 有何区别？</h4><ul><li>JVM 内存结构和 Java 虚拟机的运行时区域相关，定义了 JVM 在运行时如何分区存储程序数据，就比如说堆主要用于存放对象实例。</li><li>Java 内存模型和 Java 的并发编程相关，抽象了线程和主内存之间的关系就比如说线程之间的共享变量必须存储在主内存中，规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。</li></ul><h3 id="–-并发编程三个重要特性"><a href="#–-并发编程三个重要特性" class="headerlink" title="– 并发编程三个重要特性"></a>– 并发编程三个重要特性</h3><ul><li><p>原子性：一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。</p></li><li><p>可见性：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。</p></li><li><p>有序性：由于指令重排序问题，代码的执行顺序未必就是编写代码时候的顺序。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;常看常新，持续更新…&lt;/p&gt;</summary>
    
    
    
    <category term="并发编程" scheme="https://sunrisel135.github.io/blog_lyl/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="面试" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot3与druid-无法自动装配问题</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/07/SpringBoot3%E4%B8%8Edruid-%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E9%97%AE%E9%A2%98/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/07/SpringBoot3%E4%B8%8Edruid-%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E9%97%AE%E9%A2%98/</id>
    <published>2024-03-07T12:08:30.000Z</published>
    <updated>2024-03-07T12:13:04.660Z</updated>
    
    <content type="html"><![CDATA[<p>SpringBoot3与druid，因为druid版本问题，无法在spring boot中自动装配。</p><span id="more"></span><ul><li><p>解决方式1：</p><p>通过源码分析，druid-spring-boot-3-starter目前最新版本是1.2.18，虽然适配了SpringBoot3，但缺少自动装配的配置文件。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">需要手动在resources目录下创建META-INF/spring  (注意创建时要使用/)</span><br><span class="line">文件：org.springframework.boot.autoconfigure.AutoConfiguration.imports，文件内容如下：</span><br><span class="line">com.alibaba.druid.spring.boot3.autoconfigure.DruidDataSourceAutoConfigure</span><br></pre></td></tr></table></figure><ul><li><p>解决方式2：</p><p>使用 druid1.2.20 版本</p></li></ul><p></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-3-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;SpringBoot3与druid，因为druid版本问题，无法在spring boot中自动装配。&lt;/p&gt;</summary>
    
    
    
    <category term="SpringBoot" scheme="https://sunrisel135.github.io/blog_lyl/categories/SpringBoot/"/>
    
    
    <category term="问题" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Spring从配置文件获取到的值与实际值不一致问题</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/07/Spring%E4%BB%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%8E%B7%E5%8F%96%E5%88%B0%E7%9A%84%E5%80%BC%E4%B8%8E%E5%AE%9E%E9%99%85%E5%80%BC%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/07/Spring%E4%BB%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%8E%B7%E5%8F%96%E5%88%B0%E7%9A%84%E5%80%BC%E4%B8%8E%E5%AE%9E%E9%99%85%E5%80%BC%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/</id>
    <published>2024-03-07T07:51:41.000Z</published>
    <updated>2024-03-07T07:52:33.123Z</updated>
    
    <content type="html"><![CDATA[<p>使用Spring框架对druid数据库连接池配置时，value&#x3D;${username}获取到的值并非配置文件中的值。。。</p><span id="more"></span><ul><li><p>参考链接: <a href="https://blog.csdn.net/qq_46274901/article/details/123835512">https://blog.csdn.net/qq_46274901/article/details/123835512</a></p></li><li><p>原因：</p><p>使用Spring框架对druid数据库连接池配置时，value&#x3D;${username}获取到的值并非配置文件中的值，而是获取的windows系统用户的值，也就是我的名字。从而导致配置信息错误，无法连接数据库。</p></li><li><p>解决：</p><p>将配置文件的username改名为user，将spring中的value配置信息改为value&#x3D;${user}.避免重名即可。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用Spring框架对druid数据库连接池配置时，value&amp;#x3D;${username}获取到的值并非配置文件中的值。。。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="https://sunrisel135.github.io/blog_lyl/categories/Spring/"/>
    
    
    <category term="问题" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>实例化对象方式</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/07/%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%E6%96%B9%E5%BC%8F/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/07/%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%E6%96%B9%E5%BC%8F/</id>
    <published>2024-03-07T07:15:31.000Z</published>
    <updated>2024-03-07T07:38:50.430Z</updated>
    
    <content type="html"><![CDATA[<p>实例化对象的几种方式总结。</p><span id="more"></span><ul><li>构造函数实例化<ul><li>无参构造函数</li><li>有参构造函数</li></ul></li><li>工厂模式实例化<ul><li>静态工厂</li><li>非静态工厂</li></ul></li><li>反射</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;实例化对象的几种方式总结。&lt;/p&gt;</summary>
    
    
    
    <category term="Java基础" scheme="https://sunrisel135.github.io/blog_lyl/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="知识点" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>子、父类加载顺序</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/06/%E5%AD%90%E3%80%81%E7%88%B6%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/06/%E5%AD%90%E3%80%81%E7%88%B6%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/</id>
    <published>2024-03-06T12:58:55.000Z</published>
    <updated>2024-03-13T01:57:43.784Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接: <a href="https://blog.csdn.net/j_love93/article/details/77693230">https://blog.csdn.net/j_love93/article/details/77693230</a></p><p>详解请查看全文…</p><span id="more"></span><h5 id="1-在没有子类的情况下"><a href="#1-在没有子类的情况下" class="headerlink" title="1.在没有子类的情况下"></a>1.在没有子类的情况下</h5><p>**在初始化类时候，首先加载类的静态变量和静态语句块（按照代码上下顺序执行），然后加载类的非静态变量和非静态语句块（按照代码上下顺序执行），最后加载类的构造函数。 </p><p>至于类的静态方法和非静态方法只有主动调用的时候才会执行,区别在于静态方法可以直接用类名直接调用(实例化对象也可以),而非静态方法只能先实例化对象后才能调用。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS:不管是父类还是子类加载（静态变量和静态语句块）都只能加载一次。</span><br><span class="line"></span><br><span class="line">总结：静态 -&gt; 非静态 -&gt; 构造函数</span><br></pre></td></tr></table></figure><h5 id="2-在有子类的情况下"><a href="#2-在有子类的情况下" class="headerlink" title="2.在有子类的情况下"></a>2.在有子类的情况下</h5><p>在初始化子类的时候，首先加载父类的静态变量和静态语句块（按照代码上下顺序执行），然后加载子类的静态变量和静态语句块（按照代码上下顺序执行），然后加载父类的非静态变量和非静态语句块（按照代码上下顺序执行），再加载父类的构造函数。然后加载子类的非静态变量和非静态语句块（按照代码上下顺序执行），最后加载子类的构造函数。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 父类的静态变量和静态语句块（按照代码上下顺序执行）</span><br><span class="line">2. 子类的静态变量和静态语句块（按照代码上下顺序执行）</span><br><span class="line">3. 父类的非静态变量和非静态语句块（按照代码上下顺序执行）</span><br><span class="line">4. 父类的构造函数</span><br><span class="line">5. 子类的非静态变量和非静态语句块（按照代码上下顺序执行）</span><br><span class="line">6. 子类的构造函数</span><br><span class="line"></span><br><span class="line">总结：父类静态--子类静态--父类非静态--父类构造--子类非静态--子类构造</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;参考链接: &lt;a href=&quot;https://blog.csdn.net/j_love93/article/details/77693230&quot;&gt;https://blog.csdn.net/j_love93/article/details/77693230&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;详解请查看全文…&lt;/p&gt;</summary>
    
    
    
    <category term="Java基础" scheme="https://sunrisel135.github.io/blog_lyl/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="知识点" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Java面试-Java基础</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/05/Java%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/05/Java%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/</id>
    <published>2024-03-05T02:21:45.000Z</published>
    <updated>2024-03-09T13:26:51.010Z</updated>
    
    <content type="html"><![CDATA[<p>持续更新。。。</p><span id="more"></span><h2 id="Java基础常见面试题-上"><a href="#Java基础常见面试题-上" class="headerlink" title="Java基础常见面试题(上)"></a>Java基础常见面试题(上)</h2><h3 id="【基础概念与常识】"><a href="#【基础概念与常识】" class="headerlink" title="【基础概念与常识】"></a>【基础概念与常识】</h3><h4 id="–Java-语言有哪些特点"><a href="#–Java-语言有哪些特点" class="headerlink" title="–Java 语言有哪些特点?"></a>–Java 语言有哪些特点?</h4><ul><li>面向对象（封装，继承，多态）</li><li>平台无关性（ Java 虚拟机实现平台无关性）</li><li>支持多线程</li><li>可靠性（具备异常处理和自动内存管理机制）</li><li>安全性（Java 语言本身的设计就提供了多重安全防护机制如访问权限修饰符、限制程序直接访问操作系统资源）</li><li>编译与解释并存</li></ul><h4 id="–Java-SE-vs-Java-EE"><a href="#–Java-SE-vs-Java-EE" class="headerlink" title="–Java SE vs Java EE"></a>–Java SE vs Java EE</h4><p>简单来说，Java SE 是 Java 的基础版本，Java EE 是 Java 的高级版本。Java SE 更适合开发桌面应用程序或简单的服务器应用程序，Java EE 更适合开发复杂的企业级应用程序或 Web 应用程序。</p><p>Java ME 是 Java 的微型版本，主要用于开发嵌入式消费电子设备的应用程序。</p><h4 id="–JVM-vs-JDK-vs-JRE"><a href="#–JVM-vs-JDK-vs-JRE" class="headerlink" title="–JVM vs JDK vs JRE"></a>–JVM vs JDK vs JRE</h4><ul><li><p><strong>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机</strong>。</p><p>JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“<strong>一次编译，随处可以运行</strong>”的关键所在。</p></li><li><p><strong>JRE（Java Runtime Environment） 是 Java 运行时环境。</strong></p><p>它是运行已编译 Java 程序所需的所有内容的集合，主要包括 <strong>Java 虚拟机（JVM）</strong>、<strong>Java 基础类库（Class Library）</strong>。</p></li><li><p><strong>JDK（Java Development Kit），它是功能齐全的 Java SDK，是提供给开发者使用，能够创建和编译 Java 程序的开发套件</strong>。</p><p>它包含了 <strong>JRE</strong>，同时还包含了<strong>编译 java 源码的编译器 javac 以及一些其他工具</strong>比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等。</p></li></ul><h4 id="–什么是字节码-采用字节码的好处是什么"><a href="#–什么是字节码-采用字节码的好处是什么" class="headerlink" title="–什么是字节码?采用字节码的好处是什么?"></a>–什么是字节码?采用字节码的好处是什么?</h4><p><strong>JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），只面向虚拟机。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java 程序从源代码到运行的过程：</span><br><span class="line">.java -&gt; javac 编译 -&gt; .class -&gt; 热点代码？ NO-&gt; 解释器 -&gt; 机器可理解的代码</span><br><span class="line">     YES-&gt; JIT -&gt; 机器可理解的代码</span><br></pre></td></tr></table></figure><p> <strong>JIT</strong>（Just in Time Compilation） <strong>编译器</strong>，而 JIT 属于<strong>运行时编译</strong>。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</p><h4 id="–-为什么说-Java-语言“编译与解释并存”？"><a href="#–-为什么说-Java-语言“编译与解释并存”？" class="headerlink" title="– 为什么说 Java 语言“编译与解释并存”？"></a>– 为什么说 Java 语言“编译与解释并存”？</h4><ul><li><strong>编译型：</strong>编译型语言open in new window 会通过编译器open in new window将源代码<strong>一次性</strong>翻译成可被该平台执行的机器码。一般情况下，编译语言的<strong>执行速度比较快</strong>，开发效率比较低。</li><li><strong>解释型：</strong>解释型语言open in new window会通过解释器open in new window<strong>一句一句</strong>的将代码解释（interpret）为机器代码后再执行。解释型语言<strong>开发效率比较快</strong>，执行速度比较慢。</li><li>因为 Java 程序要经过先编译，后解释两个步骤，<strong>由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</strong></li></ul><h4 id="–-AOT-VS-JIT"><a href="#–-AOT-VS-JIT" class="headerlink" title="– AOT VS JIT ?"></a>– AOT VS JIT ?</h4><ul><li>新的编译模式 <code>AOT</code>(Ahead of Time Compilation) </li><li><code>AOT</code>会在程序被<strong>执行前就将其编译成机器码</strong>，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）</li><li>而 <code>JIT</code> 属于<strong>运行时编译</strong>。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</li><li><code>AOT</code> 的主要优势在于启动时间、内存占用和打包体积。<code>JIT</code> 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。</li><li><code>AOT</code> 更适合当下的云原生场景，对微服务架构的支持也比较友好。无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等。然而，很多框架和库（如 Spring、CGLIB）都用到了这些特性。如果只使用 AOT 编译，那就没办法使用这些框架和库了，或者说需要针对性地去做适配和优化。</li></ul><h4 id="–-Oracle-JDK-vs-OpenJDK"><a href="#–-Oracle-JDK-vs-OpenJDK" class="headerlink" title="– Oracle JDK vs OpenJDK"></a>– Oracle JDK vs OpenJDK</h4><ol><li>是否开源</li><li>是否免费</li><li>功能性：Oracle JDK 在 OpenJDK 的基础上添加了一些特有的功能和工具</li><li>稳定性</li><li>协议</li></ol><h4 id="–-Java-和-C-的区别"><a href="#–-Java-和-C-的区别" class="headerlink" title="– Java 和 C++ 的区别?"></a>– Java 和 C++ 的区别?</h4><ul><li>都是面向对象的语言，都支持封装、继承和多态</li></ul><ol><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li><li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li><li>……</li></ol><h3 id="【基本语法】"><a href="#【基本语法】" class="headerlink" title="【基本语法】"></a>【基本语法】</h3><h4 id="–-注释有哪几种形式？"><a href="#–-注释有哪几种形式？" class="headerlink" title="– 注释有哪几种形式？"></a>– 注释有哪几种形式？</h4><ol><li><strong>单行注释</strong>：通常用于解释方法内某单行代码的作用。</li><li><strong>多行注释</strong>：通常用于解释一段代码的作用。</li><li><strong>文档注释</strong>：通常用于生成 Java 开发文档。</li></ol><h4 id="–-标识符和关键字的区别是什么？"><a href="#–-标识符和关键字的区别是什么？" class="headerlink" title="– 标识符和关键字的区别是什么？"></a>– 标识符和关键字的区别是什么？</h4><ul><li>在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了 <strong>标识符</strong> 。简单来说， <strong>标识符就是一个名字</strong> 。</li><li><strong>关键字是被赋予特殊含义的标识符</strong> 。</li><li>Tips：所有的关键字都是小写的，在 IDE 中会以特殊颜色显示。</li></ul><h4 id="–-自增自减运算符"><a href="#–-自增自减运算符" class="headerlink" title="– 自增自减运算符"></a>– 自增自减运算符</h4><p>自增运算符（++)和自减运算符（–）</p><h4 id="–-移位运算符"><a href="#–-移位运算符" class="headerlink" title="– 移位运算符"></a>– 移位运算符</h4><ul><li><code>&lt;&lt;</code> :左移运算符，向左移若干位，高位丢弃，低位补零。<code>x &lt;&lt; 1</code>,相当于 x 乘以 2(不溢出的情况下)。</li><li><code>&gt;&gt;</code> :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。<code>x &gt;&gt; 1</code>,相当于 x 除以 2。</li><li><code>&gt;&gt;&gt;</code> :无符号右移，忽略符号位，空位都以 0 补齐。</li><li>移位操作符实际上支持的类型只有<code>int</code>和<code>long</code>，编译器在对short、byte、char类型进行移位前，都会将其转换为int类型再操作。</li></ul><h4 id="–-continue、break-和-return-的区别是什么？"><a href="#–-continue、break-和-return-的区别是什么？" class="headerlink" title="– continue、break 和 return 的区别是什么？"></a>– continue、break 和 return 的区别是什么？</h4><ol><li><code>continue</code>：指跳出当前的这一次循环，继续下一次循环。</li><li><code>break</code>：指跳出整个循环体，继续执行循环下面的语句。</li><li><code>return</code> 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：<ul><li><code>return;</code>：直接使用 return 结束方法执行，用于没有返回值函数的方法</li><li><code>return value;</code>：return 一个特定值，用于有返回值函数的方法</li></ul></li></ol><h3 id="【基本数据类型】"><a href="#【基本数据类型】" class="headerlink" title="【基本数据类型】"></a>【基本数据类型】</h3><h4 id="–-Java-中有-8-种基本数据类型"><a href="#–-Java-中有-8-种基本数据类型" class="headerlink" title="– Java 中有 8 种基本数据类型"></a>– Java 中有 8 种基本数据类型</h4><ul><li>6 种数字类型：<ul><li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>2 种浮点型：<code>float</code>、<code>double</code></li></ul></li><li>1 种字符类型：<code>char</code></li><li>1 种布尔型：<code>boolean</code>。</li></ul><h4 id="–-基本类型和包装类型的区别？"><a href="#–-基本类型和包装类型的区别？" class="headerlink" title="– 基本类型和包装类型的区别？"></a>– 基本类型和包装类型的区别？</h4><p>八种基本类型都有对应的包装类分别为：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</p><ul><li><p>除了定义一些常量和局部变量之外，我们在其他地方比如<strong>方法参数、对象属性</strong>中很少会使用基本类型<strong>来定义变量</strong>。并且，<strong>包装类型</strong>可<strong>用于泛型</strong>，而基本类型不可以。</p></li><li><p><strong>基本数据类型</strong>：<strong>局部变量</strong>存放在JVM<strong>栈</strong>的局部变量表中，<strong>成员变量</strong>存放在<strong>堆</strong>中。</p><p><strong>包装类型</strong>属于<strong>对象</strong>类型，我们知道几乎所有对象实例都存在于<strong>堆</strong>中。</p></li><li><p><strong>占用空间</strong>：基本数据类型占用的空间往往非常小。</p></li><li><p><strong>默认值</strong>：成员变量<strong>包装类</strong>型不赋值就是 <strong>null</strong> ，而<strong>基本类型有默认值</strong>且不是 null。</p></li><li><p><strong>比较方式</strong>：基本数据类型 <code>==</code>，整型包装类对象 <code>equals()</code></p></li></ul><h4 id="–-包装类型的缓存机制了解么？"><a href="#–-包装类型的缓存机制了解么？" class="headerlink" title="– 包装类型的缓存机制了解么？"></a>– 包装类型的缓存机制了解么？</h4><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p><h4 id="–-自动装箱与拆箱了解吗？原理是什么？"><a href="#–-自动装箱与拆箱了解吗？原理是什么？" class="headerlink" title="– 自动装箱与拆箱了解吗？原理是什么？"></a>– 自动装箱与拆箱了解吗？原理是什么？</h4><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来； <code>valueOf()</code>方法</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型； <code>xxxValue()</code>方法</li><li><code>Integer i = 10 等价于 Integer i = Integer.valueOf(10)</code><br><code>int n = i 等价于 int n = i.intValue();</code></li><li>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</li></ul><h4 id="–-为什么浮点数运算的时候会有精度丢失的风险？"><a href="#–-为什么浮点数运算的时候会有精度丢失的风险？" class="headerlink" title="– 为什么浮点数运算的时候会有精度丢失的风险？"></a>– 为什么浮点数运算的时候会有精度丢失的风险？</h4><p>计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。</p><h4 id="–-如何解决浮点数运算的精度丢失问题？"><a href="#–-如何解决浮点数运算的精度丢失问题？" class="headerlink" title="– 如何解决浮点数运算的精度丢失问题？"></a>– 如何解决浮点数运算的精度丢失问题？</h4><p><code>BigDecimal</code></p><h4 id="–-超过-long-整型的数据应该如何表示？"><a href="#–-超过-long-整型的数据应该如何表示？" class="headerlink" title="– 超过 long 整型的数据应该如何表示？"></a>– 超过 long 整型的数据应该如何表示？</h4><p><code>BigInteger</code></p><h3 id="【变量】"><a href="#【变量】" class="headerlink" title="【变量】"></a>【变量】</h3><h4 id="–-成员变量与局部变量的区别？"><a href="#–-成员变量与局部变量的区别？" class="headerlink" title="– 成员变量与局部变量的区别？"></a>– 成员变量与局部变量的区别？</h4><ul><li><p><strong>语法形式</strong>：</p><p>成员变量是<strong>属于类</strong>的，而局部变量是<strong>在代码块或方法中定义的变量或是方法的参数</strong>；</p><p>成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</p></li><li><p><strong>存储方式</strong>：</p><p>如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而<strong>对象存在于堆内存，局部变量则存在于栈内存</strong>。</p></li><li><p><strong>生存时间</strong>：</p><p>成员变量是对象的一部分，它<strong>随着对象的创建而存在</strong>，</p><p>而局部变量随着方法的调用而自动生成，<strong>随着方法的调用结束而消亡</strong>。</p></li><li><p><strong>默认值</strong>：</p><p>成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值 (一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值) ；</p><p>而<strong>局部变量则不会自动赋值</strong>；</p></li></ul><h4 id="–-字符型常量和字符串常量的区别"><a href="#–-字符型常量和字符串常量的区别" class="headerlink" title="– 字符型常量和字符串常量的区别?"></a>– 字符型常量和字符串常量的区别?</h4><ul><li><p>形式 : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。</p></li><li><p>含义 : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。</p></li><li><p>占内存大小：字符常量只占 2 个字节; 字符串常量占若干个字节。</p></li><li><p>注意 char 在 Java 中占两个字节。</p></li></ul><h3 id="【方法】"><a href="#【方法】" class="headerlink" title="【方法】"></a>【方法】</h3><h4 id="–-静态方法为什么不能调用非静态成员"><a href="#–-静态方法为什么不能调用非静态成员" class="headerlink" title="– 静态方法为什么不能调用非静态成员?"></a>– 静态方法为什么不能调用非静态成员?</h4><ul><li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li><li>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li></ul><h4 id="–-静态方法和实例方法有何不同？"><a href="#–-静态方法和实例方法有何不同？" class="headerlink" title="– 静态方法和实例方法有何不同？"></a>– 静态方法和实例方法有何不同？</h4><ol><li><strong>调用方式</strong>：在外部调用静态方法时，可以使用 类名.方法名 的方式，也可以使用 对象.方法名 的方式，而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象 。</li><li><strong>访问类成员是否存在限制</strong> ：静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</li></ol><h4 id="–-重载和重写有什么区别？"><a href="#–-重载和重写有什么区别？" class="headerlink" title="– 重载和重写有什么区别？"></a>– 重载和重写有什么区别？</h4><ul><li><p><strong>重载</strong></p><p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p></li><li><p><strong>重写</strong></p><p>发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><ol><li><p>方法名、参数列表必须相同，子类方法<strong>返回值类型</strong>应比父类方法返回值类型<strong>更小或相等</strong>，抛出的<strong>异常范围小于等于</strong>父类，<strong>访问修饰符范围大于等于</strong>父类。</p><p>如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p></li><li><p>如果父类方法访问修饰符为 <strong><code>private/final/static</code></strong> 则子类就<strong>不能重写</strong>该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</p></li><li><p>构造方法无法被重写</p></li></ol><p><strong>方法的重写要遵循“两同两小一大</strong></p></li></ul><h4 id="–-什么是可变长参数？"><a href="#–-什么是可变长参数？" class="headerlink" title="– 什么是可变长参数？"></a>– 什么是可变长参数？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">   <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这样方法就可以接受 0 个或者多个参数</li><li>可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。</li><li>方法重载会优先匹配固定参数</li></ul><h2 id="Java基础常见面试题-中"><a href="#Java基础常见面试题-中" class="headerlink" title="Java基础常见面试题(中)"></a>Java基础常见面试题(中)</h2><h3 id="【面向对象基础】"><a href="#【面向对象基础】" class="headerlink" title="【面向对象基础】"></a>【面向对象基础】</h3><h4 id="–-面向对象和面向过程的区别"><a href="#–-面向对象和面向过程的区别" class="headerlink" title="– 面向对象和面向过程的区别"></a>– 面向对象和面向过程的区别</h4><p>主要区别在于<strong>解决问题的方式</strong>不同：</p><ul><li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li></ul><p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p><h4 id="–-面向过程性能比面向对象高？"><a href="#–-面向过程性能比面向对象高？" class="headerlink" title="– 面向过程性能比面向对象高？"></a>– 面向过程性能比面向对象高？</h4><p><strong>面向过程性能比面向对象高</strong>。</p><p>因为<strong>类调用时需要实例化</strong>，开销较大，<strong>比较消耗资源</strong>，所以当性能是最重要的考量因素的的时候，比如单片机、嵌入式开发、Linux&#x2F;Unix等一般采用面向过程开发。</p><p>但这并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java性能差的主要原因并不是因为它是面向对象语言，而是<strong>Java是半编译语言，最终的执行代码并不是可以直接被CPU执行的二进制机械码</strong>。</p><p>而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其他一些面向过程的脚本语言性能也<strong>并不一定</strong>比Java好。</p><h4 id="–-创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#–-创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="– 创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>– 创建一个对象用什么运算符?对象实体与对象引用有何不同?</h4><p><strong>new</strong> 运算符。</p><p>new 创建对象实例 (对象实例在堆内存中)，<strong>对象引用</strong>指向<strong>对象实例</strong> (对象引用存放在栈内存中)。</p><ul><li>一个对象引用可以指向 0 个或 1 个对象；</li><li>一个对象可以有 n 个引用指向它；</li></ul><h4 id="–-对象的相等和引用相等的区别"><a href="#–-对象的相等和引用相等的区别" class="headerlink" title="– 对象的相等和引用相等的区别"></a>– 对象的相等和引用相等的区别</h4><ul><li><strong>对象的相等</strong>一般比较的是内存中<strong>存放的内容</strong>是否相等。</li><li><strong>引用相等</strong>一般比较的是他们<strong>指向的内存地址</strong>是否相等。</li></ul><h4 id="–-如果一个类没有声明构造方法，该程序能正确执行吗"><a href="#–-如果一个类没有声明构造方法，该程序能正确执行吗" class="headerlink" title="– 如果一个类没有声明构造方法，该程序能正确执行吗?"></a>– 如果一个类没有声明构造方法，该程序能正确执行吗?</h4><p><strong>可以</strong>执行！</p><p><strong>构造方法</strong>是一种特殊的方法，主要作用是完成对象的初始化工作。</p><p>一个类即使没有声明构造方法也会有<strong>默认的不带参数的构造方法</strong>。如果我们自己添加了类的构造方法 (无论是否有参)，Java 就不会添加默认的无参数的构造方法了。</p><p>这也是为什么我们在创建对象的时候后面要加一个括号 (因为要调用无参的构造方法)。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来 (无论是否用到)，因为这可以帮助我们在创建对象的时候少踩坑。</p><h4 id="–-构造方法有哪些特点？是否可被-override"><a href="#–-构造方法有哪些特点？是否可被-override" class="headerlink" title="– 构造方法有哪些特点？是否可被 override?"></a>– 构造方法有哪些特点？是否可被 override?</h4><ul><li>名字与类名相同。</li><li>没有返回值，但不能用 void 声明构造函数。</li><li>生成类的对象时自动执行，无需调用。</li></ul><p>构造方法不能被 override (重写),但是可以 overload (重载)。</p><h3 id="【面向对象三大特征】"><a href="#【面向对象三大特征】" class="headerlink" title="【面向对象三大特征】"></a>【面向对象三大特征】</h3><h4 id="–-封装"><a href="#–-封装" class="headerlink" title="– 封装"></a>– 封装</h4><p><strong>指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。</strong>但是可以提供一些可以被外界访问的方法来操作属性。如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p><h4 id="–-继承"><a href="#–-继承" class="headerlink" title="– 继承"></a>– 继承</h4><p>不同类型的对象，相互之间经常有一定数量的共同点。同时，每一个对象还定义了额外的特性使得他们与众不同。</p><p><strong>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。</strong>通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p><p><strong>注意：</strong></p><ol><li>子类拥有父类对象所有的属性和方法 (包括私有属性和私有方法)，但是<strong>父类中的私有属性和方法子类是无法访问</strong>，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。(以后介绍)。</li></ol><h4 id="–-多态"><a href="#–-多态" class="headerlink" title="– 多态"></a>– 多态</h4><p><strong>表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</strong></p><p><strong>特点:</strong></p><ul><li>对象类型和引用类型之间具有<strong>继承</strong> (类) &#x2F; 实现(接口)的<strong>关系</strong>；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序<strong>运行期间才能确定</strong>；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li></ul><h4 id="–-接口和抽象类有什么共同点和区别？"><a href="#–-接口和抽象类有什么共同点和区别？" class="headerlink" title="– 接口和抽象类有什么共同点和区别？"></a>– 接口和抽象类有什么共同点和区别？</h4><p><strong>共同点</strong>：</p><ul><li>都不能<strong>被实例化</strong>。</li><li>都可以<strong>包含抽象方法</strong>。</li><li>都可以<strong>有默认实现的方法</strong>（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</li></ul><p><strong>区别</strong>：</p><ul><li><strong>接口</strong>主要用于对<strong>类</strong>的<strong>行为</strong>进行<strong>约束</strong>，你实现了某个接口就具有了对应的行为。<strong>抽象类</strong>主要用于<strong>代码复用</strong>，<strong>强调的是所属关系</strong>。</li><li>一个类只能继承一个类，但是可以实现多个接口 (<strong>类的单继承，接口多继承</strong>)。</li><li><strong>接口</strong>中的<strong>成员变量</strong>只能是 <code>public static final</code> 类型的，<strong>不能被修改且必须有初始值</strong>，而<strong>抽象类</strong>的<strong>成员变量</strong>默认 <code>default</code>，<strong>可在子类中被重新定义，也可被重新赋值</strong>。</li></ul><h4 id="–-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><a href="#–-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？" class="headerlink" title="– 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"></a>– 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h4><ul><li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。（父类 <code>Object</code> 的 <code>clone()</code> 方法）</li><li><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。(重写了父类<code>Object</code> 的<code>clone(</code>)方法)</li></ul><p><strong>那什么是引用拷贝呢？</strong> 简单来说，<strong>引用拷贝</strong>就是两个不同的引用指向同一个对象。</p><p><img src="C:\Users\lyl\Desktop\其他\photo\shallow&deep-copy.png"></p><h3 id="【Object】"><a href="#【Object】" class="headerlink" title="【Object】"></a>【Object】</h3><h4 id="–-Object-类的常见方法有哪些？"><a href="#–-Object-类的常见方法有哪些？" class="headerlink" title="– Object 类的常见方法有哪些？"></a>– Object 类的常见方法有哪些？</h4><p>Object 类是一个特殊的类，是<strong>所有类的父类</strong>。它主要提供了以下 11 个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;持续更新。。。&lt;/p&gt;</summary>
    
    
    
    <category term="Java基础" scheme="https://sunrisel135.github.io/blog_lyl/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="面试" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Hexo搭建博客</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/04/Hexo+github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/04/Hexo+github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2024-03-04T12:12:17.000Z</published>
    <updated>2024-03-07T12:06:46.629Z</updated>
    
    <content type="html"><![CDATA[<p>基于 Hexo + GithubPage 搭建博客，我的第一个博客。</p><span id="more"></span><p>参考链接: <a href="https://blog.csdn.net/redrose2100/article/details/121731468">https://blog.csdn.net/redrose2100/article/details/121731468</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;基于 Hexo + GithubPage 搭建博客，我的第一个博客。&lt;/p&gt;</summary>
    
    
    
    <category term="博客相关" scheme="https://sunrisel135.github.io/blog_lyl/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="教程" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
