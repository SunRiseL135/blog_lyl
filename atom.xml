<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lyl&#39;blog</title>
  
  
  <link href="https://sunrisel135.github.io/blog_lyl/atom.xml" rel="self"/>
  
  <link href="https://sunrisel135.github.io/blog_lyl/"/>
  <updated>2024-03-08T07:51:13.415Z</updated>
  <id>https://sunrisel135.github.io/blog_lyl/</id>
  
  <author>
    <name>lyl_L-</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java面试-并发编程</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/08/Java%E9%9D%A2%E8%AF%95-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/08/Java%E9%9D%A2%E8%AF%95-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</id>
    <published>2024-03-08T05:45:56.000Z</published>
    <updated>2024-03-08T07:51:13.415Z</updated>
    
    <content type="html"><![CDATA[<p>常看常新，持续更新…</p><span id="more"></span><h3 id="【线程】"><a href="#【线程】" class="headerlink" title="【线程】"></a>【线程】</h3><h4 id="–-什么是线程和进程"><a href="#–-什么是线程和进程" class="headerlink" title="– 什么是线程和进程?"></a>– 什么是线程和进程?</h4><h5 id="进程？"><a href="#进程？" class="headerlink" title="进程？"></a>进程？</h5><ul><li><strong>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。</strong></li><li>系统运行一个程序即是一个进程从创建，运行到消亡的过程。</li><li>Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</li></ul><h5 id="线程"><a href="#线程" class="headerlink" title="线程?"></a>线程?</h5><ul><li><strong>与进程相似，线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。</strong></li><li>与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</li></ul><h5 id="用户线程、内核线程？"><a href="#用户线程、内核线程？" class="headerlink" title="用户线程、内核线程？"></a>用户线程、内核线程？</h5><ul><li>用户线程 (jdk1.2前)：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）。<br>内核线程 (jdk1.2及以后)：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）。</li><li>现在的 Java 线程的本质其实就是操作系统的线程。</li></ul><h4 id="–-线程与进程的关系-区别及优缺点？"><a href="#–-线程与进程的关系-区别及优缺点？" class="headerlink" title="– 线程与进程的关系,区别及优缺点？"></a>– 线程与进程的关系,区别及优缺点？</h4><p>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p><h4 id="–-并发与并行的区别"><a href="#–-并发与并行的区别" class="headerlink" title="– 并发与并行的区别"></a>– 并发与并行的区别</h4><ul><li><strong>并发</strong>：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li><li><strong>并行</strong>：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li></ul><p>最关键的点是：是否是 <strong>同时</strong> 执行。</p><h4 id="–-同步和异步的区别"><a href="#–-同步和异步的区别" class="headerlink" title="– 同步和异步的区别"></a>– 同步和异步的区别</h4><ul><li>同步：发出一个调用之后，在<strong>没有得到结果之前</strong>， 该调用就不可以返回，<strong>一直等待</strong>。</li><li>异步：调用在发出之后，<strong>不用等待返回结果</strong>，该调用直接返回。</li></ul><h4 id="–-为什么要使用多线程"><a href="#–-为什么要使用多线程" class="headerlink" title="– 为什么要使用多线程?"></a>– 为什么要使用多线程?</h4><ul><li>线程是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li><li>可以大大提高系统整体的并发能力以及性能。</li></ul><h4 id="–-使用多线程可能带来什么问题"><a href="#–-使用多线程可能带来什么问题" class="headerlink" title="– 使用多线程可能带来什么问题?"></a>– 使用多线程可能带来什么问题?</h4><p>并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：<strong>内存泄漏、死锁、线程不安全</strong>等。</p><h4 id="–-如何理解线程安全？"><a href="#–-如何理解线程安全？" class="headerlink" title="– 如何理解线程安全？"></a>– 如何理解线程安全？</h4><p><strong>多线程环境下对于同一份数据的访问是否能够保证其正确性和一致性。</strong></p><p>线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。</p><h4 id="–-线程的生命周期和状态-★"><a href="#–-线程的生命周期和状态-★" class="headerlink" title="– 线程的生命周期和状态? ★"></a>– 线程的生命周期和状态? ★</h4><p>六种状态：</p><ul><li><strong>NEW: 初始状态</strong>，线程被创建出来但没有被调用 <code>start()</code> 。</li><li><strong>RUNNABLE: 运行状态</strong>，线程被调用了 <code>start()</code>等待运行的状态。</li><li><strong>BLOCKED：阻塞状态</strong>，需要等待锁释放。</li><li><strong>WAITING：等待状态</strong>，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</li><li><strong>TIME_WAITING：超时等待状态</strong>，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</li><li><strong>TERMINATED：终止状态</strong>，表示该线程已经运行完毕。</li></ul><ol><li>线程创建之后它将处于 NEW（新建） 状态，调用 start() 方法后开始运行，线程这时候处于 READY（可运行） 状态。</li><li>可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 RUNNING（运行） 状态。</li><li>当线程执行 wait()方法之后，线程进入 WAITING（等待） 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。</li><li>TIMED_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制，比如通过 sleep（long millis）方法或 wait（long millis）方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。</li><li>当线程进入 synchronized 方法&#x2F;块或者调用 wait 后（被 notify）重新进入 synchronized 方法&#x2F;块，但是锁被其它线程占有，这个时候线程就会进入 BLOCKED（阻塞） 状态。</li><li>线程在执行完了 run()方法之后之后将会进入到 TERMINATED（终止） 状态。</li></ol><h4 id="–-什么是线程上下文切换"><a href="#–-什么是线程上下文切换" class="headerlink" title="– 什么是线程上下文切换?"></a>– 什么是线程上下文切换?</h4><p>当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p><ul><li>主动让出 CPU，比如调用了 sleep(), wait() 等。</li><li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li><li>被终止或结束运行</li></ul><p>这其中前三种都会发生线程切换，<strong>线程切换</strong>意味着<strong>需要保存当前线程的上下文</strong>，<strong>待线程下次占用 CPU 的时候恢复</strong>现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 上下文切换。</p><p>因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p><h4 id="–-什么是线程死锁-如何避免死锁"><a href="#–-什么是线程死锁-如何避免死锁" class="headerlink" title="– 什么是线程死锁?如何避免死锁?"></a>– 什么是线程死锁?如何避免死锁?</h4><h5 id="什么是死锁："><a href="#什么是死锁：" class="headerlink" title="什么是死锁："></a>什么是死锁：</h5><ul><li><strong>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。</strong>由于线程被无限期地阻塞，因此程序不可能正常终止。</li><li>线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</li></ul><h5 id="产生死锁的四个必要条件："><a href="#产生死锁的四个必要条件：" class="headerlink" title="产生死锁的四个必要条件："></a>产生死锁的四个必要条件：</h5><ol><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。如何预防和避</li></ol><h5 id="预防和避免线程死锁："><a href="#预防和避免线程死锁：" class="headerlink" title="预防和避免线程死锁："></a>预防和避免线程死锁：</h5><p>破坏死锁的产生的必要条件即可：</p><ol><li>破坏请求与保持条件：一次性申请所有的资源。</li><li>破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li>破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li></ol><p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态</p><h4 id="–-sleep-方法和-wait-方法对比"><a href="#–-sleep-方法和-wait-方法对比" class="headerlink" title="– sleep() 方法和 wait() 方法对比"></a>– sleep() 方法和 wait() 方法对比</h4><p><strong>共同点</strong>：两者都可以暂停线程的执行。</p><p><strong>区别</strong>: </p><ul><li><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁 。</li><li><code>wait()</code> 通常被用于线程间交互&#x2F;通信，<code>sleep()</code>通常被用于暂停执行。</li><li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li><li><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法（因为wait要释放当前线程占有的对象锁，操作的对象自然是Object）。</li></ul><h4 id="–-可以直接调用-Thread-类的-run-方法吗？"><a href="#–-可以直接调用-Thread-类的-run-方法吗？" class="headerlink" title="– 可以直接调用 Thread 类的 run 方法吗？"></a>– 可以直接调用 Thread 类的 run 方法吗？</h4><p><strong>调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。</strong></p><h3 id="【volatile-关键字】"><a href="#【volatile-关键字】" class="headerlink" title="【volatile 关键字】"></a>【volatile 关键字】</h3><h4 id="–-volatile总结"><a href="#–-volatile总结" class="headerlink" title="– volatile总结"></a>– volatile总结</h4><ul><li>volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。</li><li>防止 JVM 的指令重排序。</li></ul><h4 id="–-保证变量的可见性？"><a href="#–-保证变量的可见性？" class="headerlink" title="– 保证变量的可见性？"></a>– 保证变量的可见性？</h4><p>将变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JMM(Java内存模型): </span><br><span class="line">线程1 &lt;-&gt; 本地内存(共享变量副本) &lt;--&gt; 主内存-共享变量</span><br><span class="line">强制在主内存中进行读取:</span><br><span class="line">线程1 &lt;-&gt; 本地内存(共享变量副本) &lt;--&gt; 主内存-共享变量</span><br><span class="line"> &lt;---------------------&gt; 主内存-共享变量</span><br></pre></td></tr></table></figure><h4 id="–-volatile-可以保证原子性么？"><a href="#–-volatile-可以保证原子性么？" class="headerlink" title="– volatile 可以保证原子性么？"></a>– volatile 可以保证原子性么？</h4><p>不能。</p><ul><li><p>线程 1 对 inc 进行读取操作之后，还未对其进行修改。线程 2 又读取了 inc的值并对其进行修改（+1），再将inc 的值写回内存。</p><p>线程 2 操作完毕后，线程 1 对 inc的值进行修改（+1），再将inc 的值写回内存。</p><p>这也就导致两个线程分别对 inc 进行了一次自增操作后，inc 实际上只增加了 1。</p></li><li><p>如果想要保证上面的代码运行正确也非常简单，利用 synchronized、Lock或者AtomicInteger都可以。</p></li></ul><h4 id="–-禁止指令重排序？"><a href="#–-禁止指令重排序？" class="headerlink" title="– 禁止指令重排序？"></a>– 禁止指令重排序？</h4><p>将变量声明为 volatile ，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。</p><h4 id="–-指令重排序"><a href="#–-指令重排序" class="headerlink" title="– 指令重排序"></a>– 指令重排序</h4><ul><li><p>为了提升执行速度&#x2F;性能，计算机在执行程序代码的时候，会对指令进行重排序。</p></li><li><p>系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行</p></li><li><p>常见的指令重排序有下面 2 种情况：</p><ul><li><p>编译器优化重排：编译器（包括 JVM、JIT 编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序。</p></li><li><p>指令并行重排：现代处理器采用了指令级并行技术(Instruction-Level Parallelism，ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p></li></ul></li><li><p>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致 ，所以在多线程下，指令重排序可能会导致一些问题。</p></li></ul><h4 id="–-乐观锁和悲观锁"><a href="#–-乐观锁和悲观锁" class="headerlink" title="– 乐观锁和悲观锁"></a>– 乐观锁和悲观锁</h4><h5 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h5><ul><li>总是假设最坏的情况。<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。</strong></li><li>synchronized 和 ReentrantLock 等<strong>独占锁</strong>就是悲观锁思想的实现。</li></ul><h5 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h5><ul><li>总是假设最好的情况。</li><li>共享资源每次被访问的时候不会出现问题，<strong>线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源</strong>（也就是数据）<strong>是否被其它线程修改了</strong>（具体方法可以使用<strong>版本号机制</strong>或 <strong>CAS 算法</strong>）。</li></ul><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul><li>悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。如果乐观锁解决了频繁失败和重试这个问题的话（比如LongAdder），也是可以考虑使用乐观锁的，要视实际情况而定。</li><li>乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。主要针对的对象是单个共享变量。</li></ul><h5 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h5><p>在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。</p><h5 id="CAS算法-乐观锁使用更多"><a href="#CAS算法-乐观锁使用更多" class="headerlink" title="CAS算法(乐观锁使用更多)"></a>CAS算法(乐观锁使用更多)</h5><p>用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</p><h3 id="【synchronized-关键字】"><a href="#【synchronized-关键字】" class="headerlink" title="【synchronized 关键字】"></a>【synchronized 关键字】</h3><ul><li>Java 中的一个关键字，主要解决的是<strong>多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行</strong>。</li><li>Java 6 进行了<strong>优化</strong></li><li><strong>修饰实例方法、修饰静态方法、修饰代码块</strong></li></ul><h4 id="–-构造方法可以用-synchronized-修饰么？"><a href="#–-构造方法可以用-synchronized-修饰么？" class="headerlink" title="– 构造方法可以用 synchronized 修饰么？"></a>– 构造方法可以用 synchronized 修饰么？</h4><p>构造方法本身就属于线程安全的，不存在同步的构造方法一说。</p><h4 id="–-synchronized-和-volatile-有什么区别？"><a href="#–-synchronized-和-volatile-有什么区别？" class="headerlink" title="– synchronized 和 volatile 有什么区别？"></a>– synchronized 和 volatile 有什么区别？</h4><p>互补。</p><ul><li>volatile 关键字是线程同步的轻量级实现，所以 volatile性能肯定比synchronized关键字要好 。但是 volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块 。</li><li>volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。</li><li>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。</li></ul><h3 id="【ReentrantLock】"><a href="#【ReentrantLock】" class="headerlink" title="【ReentrantLock】"></a>【ReentrantLock】</h3><h4 id="–-ReentrantLock-是什么？"><a href="#–-ReentrantLock-是什么？" class="headerlink" title="– ReentrantLock 是什么？"></a>– ReentrantLock 是什么？</h4><ul><li>实现了 <strong><code>Lock</code></strong> 接口，是一个<strong>可重入且独占式的锁</strong>，和 synchronized 关键字类似。不过，ReentrantLock 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</li><li>ReentrantLock 默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁。</li></ul><h4 id="–-公平锁和非公平锁有什么区别？"><a href="#–-公平锁和非公平锁有什么区别？" class="headerlink" title="– 公平锁和非公平锁有什么区别？"></a>– 公平锁和非公平锁有什么区别？</h4><ul><li><strong>公平锁</strong> : 锁被释放之后，<strong>先申请的线程先得到锁</strong>。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</li><li>非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</li></ul><h4 id="–-synchronized-和-ReentrantLock-有什么区别？"><a href="#–-synchronized-和-ReentrantLock-有什么区别？" class="headerlink" title="– synchronized 和 ReentrantLock 有什么区别？"></a>– synchronized 和 ReentrantLock 有什么区别？</h4><ul><li><strong>两者都是可重入锁</strong><ul><li>可重入锁 也叫递归锁，指的是线程<strong>可以再次获取自己的内部锁</strong>。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</li><li>JDK 提供的所有现成的 Lock 实现类，包括 synchronized 关键字锁都是可重入的。</li></ul></li><li><strong>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</strong></li><li><strong>相比synchronized，ReentrantLock增加了一些高级功能</strong><ul><li>等待可中断</li><li>可实现公平锁</li><li>可实现选择性通知（锁可以绑定多个条件）</li></ul></li></ul><h4 id="–-可中断锁和不可中断锁有什么区别？"><a href="#–-可中断锁和不可中断锁有什么区别？" class="headerlink" title="– 可中断锁和不可中断锁有什么区别？"></a>– 可中断锁和不可中断锁有什么区别？</h4><ul><li>可中断锁：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。ReentrantLock 就属于是可中断锁。</li><li>不可中断锁：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 synchronized 就属于是不可中断锁。</li></ul><h3 id="【ThreadLocal】"><a href="#【ThreadLocal】" class="headerlink" title="【ThreadLocal】"></a>【ThreadLocal】</h3><h4 id="–-ThreadLocal-有什么用？"><a href="#–-ThreadLocal-有什么用？" class="headerlink" title="– ThreadLocal 有什么用？"></a>– ThreadLocal 有什么用？</h4><ul><li>ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以<strong>存储每个线程的私有数据</strong>。</li><li>创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，可以使用 get() 和 set() 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</li></ul><h4 id="–-ThreadLocal-原理了解吗？"><a href="#–-ThreadLocal-原理了解吗？" class="headerlink" title="– ThreadLocal 原理了解吗？"></a>– ThreadLocal 原理了解吗？</h4><ul><li>最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。</li><li>每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为 key ，Object 对象为 value 的键值对。</li></ul><h4 id="–-ThreadLocal-内存泄露问题是怎么导致的？"><a href="#–-ThreadLocal-内存泄露问题是怎么导致的？" class="headerlink" title="– ThreadLocal 内存泄露问题是怎么导致的？"></a>– ThreadLocal 内存泄露问题是怎么导致的？</h4><ul><li>ThreadLocalMap 中使用的 key 为 ThreadLocal 的<strong>弱引用</strong>，而 value 是<strong>强引用</strong>。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</li><li><strong>使用完 ThreadLocal方法后最好手动调用remove()方法</strong></li><li><strong>弱引用</strong>：在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</li></ul><h3 id="【线程池】"><a href="#【线程池】" class="headerlink" title="【线程池】"></a>【线程池】</h3><h4 id="–-线程池？"><a href="#–-线程池？" class="headerlink" title="– 线程池？"></a>– 线程池？</h4><ul><li>管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</li><li>使用线程池的好处：<ul><li>降低资源消耗</li><li>提高响应速度</li><li>提高线程的可管理性</li></ul></li></ul><h4 id="–-如何创建线程池？"><a href="#–-如何创建线程池？" class="headerlink" title="– 如何创建线程池？"></a>– 如何创建线程池？</h4><p>方式一：通过**<code>ThreadPoolExecutor</code>**构造函数来创建（推荐）</p><p>方式二：通过 <strong>Executor 框架</strong>的工具类 <strong>Executors</strong> 来创建。</p><h4 id="–-线程池常见参数有哪些？"><a href="#–-线程池常见参数有哪些？" class="headerlink" title="– 线程池常见参数有哪些？"></a>– 线程池常见参数有哪些？</h4><ul><li><p>ThreadPoolExecutor 3 个最重要的参数：</p><ul><li><strong>corePoolSize</strong> : 任务队列未达到队列容量时，<strong>最大可以同时运行的线程数量</strong>。</li><li><strong>maximumPoolSize</strong> : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong>workQueue:</strong> 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul></li><li><p>ThreadPoolExecutor其他常见参数 :</p><ul><li><p>keepAliveTime:线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，多余的空闲线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁，线程池回收线程时，会对核心线程和非核心线程一视同仁，直到线程池中线程的数量等于 corePoolSize ，回收过程才会停止</p></li><li><p>unit : keepAliveTime 参数的时间单位</p></li><li><p>threadFactory :executor 创建新线程的时候会用到</p></li><li><p>handler :<strong>饱和策略</strong></p></li></ul></li></ul><h4 id="–-线程池的饱和策略有哪些？"><a href="#–-线程池的饱和策略有哪些？" class="headerlink" title="– 线程池的饱和策略有哪些？"></a>– 线程池的饱和策略有哪些？</h4><ul><li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。(spring默认策略)</li><li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li><li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li><li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。</li></ul><h4 id="–-线程池常用的阻塞队列有哪些？"><a href="#–-线程池常用的阻塞队列有哪些？" class="headerlink" title="– 线程池常用的阻塞队列有哪些？"></a>– 线程池常用的阻塞队列有哪些？</h4><p>新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</p><ul><li>容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue（无界队列）</li><li>SynchronousQueue（同步队列）</li><li>DelayedWorkQueue（延迟阻塞队列）</li></ul><h4 id="–-线程池处理任务的流程了解吗？"><a href="#–-线程池处理任务的流程了解吗？" class="headerlink" title="– 线程池处理任务的流程了解吗？"></a>– 线程池处理任务的流程了解吗？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">提交任务 -》 核心线程池是否已满 -Y-》等待队列是否已满 -Y-》线程池是否已满 -Y-》按照策略处理</span><br><span class="line">   -N 》创建线程   - N-》创建队列 -N-》创建线程</span><br></pre></td></tr></table></figure><h3 id="【Future】"><a href="#【Future】" class="headerlink" title="【Future】"></a>【Future】</h3><h4 id="–-Future-类有什么用？"><a href="#–-Future-类有什么用？" class="headerlink" title="– Future 类有什么用？"></a>– Future 类有什么用？</h4><ul><li><p>当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 Future 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p></li><li><p>多线程中经典的 Future 模式，你可以将其看作是一种设计模式，核心思想是异步调用</p></li><li><p>Future 类只是一个泛型接口，位于 java.util.concurrent 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p><ul><li><p>取消任务；</p></li><li><p>判断任务是否被取消;</p></li><li><p>判断任务是否已经执行完成;</p></li><li><p>获取任务执行结果。</p></li></ul></li></ul><h3 id="【AQS】"><a href="#【AQS】" class="headerlink" title="【AQS】"></a>【AQS】</h3><h4 id="–-AQS-是什么？"><a href="#–-AQS-是什么？" class="headerlink" title="– AQS 是什么？"></a>– AQS 是什么？</h4><ul><li>AQS 的全称为 AbstractQueuedSynchronizer ，翻译过来的意思就是抽象队列同步器。</li><li>AQS 就是一个抽象类，主要用来构建锁和同步器。</li><li>AQS 为构建锁和同步器提供了一些通用功能的实现，因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue等等皆是基于 AQS 的。</li></ul><h3 id="【虚拟线程】"><a href="#【虚拟线程】" class="headerlink" title="【虚拟线程】"></a>【虚拟线程】</h3><h3 id="【JMM-Java内存模型-】"><a href="#【JMM-Java内存模型-】" class="headerlink" title="【JMM (Java内存模型)】"></a>【JMM (Java内存模型)】</h3><p><strong>抽象线程和主内存之间的关系</strong></p><h4 id="–-Java-内存区域和-JMM-有何区别？"><a href="#–-Java-内存区域和-JMM-有何区别？" class="headerlink" title="– Java 内存区域和 JMM 有何区别？"></a>– Java 内存区域和 JMM 有何区别？</h4><ul><li>JVM 内存结构和 Java 虚拟机的运行时区域相关，定义了 JVM 在运行时如何分区存储程序数据，就比如说堆主要用于存放对象实例。</li><li>Java 内存模型和 Java 的并发编程相关，抽象了线程和主内存之间的关系就比如说线程之间的共享变量必须存储在主内存中，规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。</li></ul><h3 id="–-并发编程三个重要特性"><a href="#–-并发编程三个重要特性" class="headerlink" title="– 并发编程三个重要特性"></a>– 并发编程三个重要特性</h3><ul><li><p>原子性：一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。</p></li><li><p>可见性：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。</p></li><li><p>有序性：由于指令重排序问题，代码的执行顺序未必就是编写代码时候的顺序。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;常看常新，持续更新…&lt;/p&gt;</summary>
    
    
    
    <category term="并发编程" scheme="https://sunrisel135.github.io/blog_lyl/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="面试" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot3与druid-无法自动装配问题</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/07/SpringBoot3%E4%B8%8Edruid-%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E9%97%AE%E9%A2%98/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/07/SpringBoot3%E4%B8%8Edruid-%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E9%97%AE%E9%A2%98/</id>
    <published>2024-03-07T12:08:30.000Z</published>
    <updated>2024-03-07T12:13:04.660Z</updated>
    
    <content type="html"><![CDATA[<p>SpringBoot3与druid，因为druid版本问题，无法在spring boot中自动装配。</p><span id="more"></span><ul><li><p>解决方式1：</p><p>通过源码分析，druid-spring-boot-3-starter目前最新版本是1.2.18，虽然适配了SpringBoot3，但缺少自动装配的配置文件。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">需要手动在resources目录下创建META-INF/spring  (注意创建时要使用/)</span><br><span class="line">文件：org.springframework.boot.autoconfigure.AutoConfiguration.imports，文件内容如下：</span><br><span class="line">com.alibaba.druid.spring.boot3.autoconfigure.DruidDataSourceAutoConfigure</span><br></pre></td></tr></table></figure><ul><li><p>解决方式2：</p><p>使用 druid1.2.20 版本</p></li></ul><p></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-3-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;SpringBoot3与druid，因为druid版本问题，无法在spring boot中自动装配。&lt;/p&gt;</summary>
    
    
    
    <category term="SpringBoot" scheme="https://sunrisel135.github.io/blog_lyl/categories/SpringBoot/"/>
    
    
    <category term="问题" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Spring从配置文件获取到的值与实际值不一致问题</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/07/Spring%E4%BB%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%8E%B7%E5%8F%96%E5%88%B0%E7%9A%84%E5%80%BC%E4%B8%8E%E5%AE%9E%E9%99%85%E5%80%BC%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/07/Spring%E4%BB%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%8E%B7%E5%8F%96%E5%88%B0%E7%9A%84%E5%80%BC%E4%B8%8E%E5%AE%9E%E9%99%85%E5%80%BC%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/</id>
    <published>2024-03-07T07:51:41.000Z</published>
    <updated>2024-03-07T07:52:33.123Z</updated>
    
    <content type="html"><![CDATA[<p>使用Spring框架对druid数据库连接池配置时，value&#x3D;${username}获取到的值并非配置文件中的值。。。</p><span id="more"></span><ul><li><p>参考链接: <a href="https://blog.csdn.net/qq_46274901/article/details/123835512">https://blog.csdn.net/qq_46274901/article/details/123835512</a></p></li><li><p>原因：</p><p>使用Spring框架对druid数据库连接池配置时，value&#x3D;${username}获取到的值并非配置文件中的值，而是获取的windows系统用户的值，也就是我的名字。从而导致配置信息错误，无法连接数据库。</p></li><li><p>解决：</p><p>将配置文件的username改名为user，将spring中的value配置信息改为value&#x3D;${user}.避免重名即可。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用Spring框架对druid数据库连接池配置时，value&amp;#x3D;${username}获取到的值并非配置文件中的值。。。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="https://sunrisel135.github.io/blog_lyl/categories/Spring/"/>
    
    
    <category term="问题" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>实例化对象方式</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/07/%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%E6%96%B9%E5%BC%8F/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/07/%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%E6%96%B9%E5%BC%8F/</id>
    <published>2024-03-07T07:15:31.000Z</published>
    <updated>2024-03-07T07:38:50.430Z</updated>
    
    <content type="html"><![CDATA[<p>实例化对象的几种方式总结。</p><span id="more"></span><ul><li>构造函数实例化<ul><li>无参构造函数</li><li>有参构造函数</li></ul></li><li>工厂模式实例化<ul><li>静态工厂</li><li>非静态工厂</li></ul></li><li>反射</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;实例化对象的几种方式总结。&lt;/p&gt;</summary>
    
    
    
    <category term="Java基础" scheme="https://sunrisel135.github.io/blog_lyl/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="知识点" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>子、父类加载顺序</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/06/%E5%AD%90%E3%80%81%E7%88%B6%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/06/%E5%AD%90%E3%80%81%E7%88%B6%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/</id>
    <published>2024-03-06T12:58:55.000Z</published>
    <updated>2024-03-07T07:38:57.767Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接: <a href="https://blog.csdn.net/j_love93/article/details/77693230">https://blog.csdn.net/j_love93/article/details/77693230</a></p><p>详解请查看全文。。。</p><span id="more"></span><h5 id="1-在没有子类的情况下"><a href="#1-在没有子类的情况下" class="headerlink" title="1.在没有子类的情况下"></a>1.在没有子类的情况下</h5><p>**在初始化类时候，首先加载类的静态变量和静态语句块（按照代码上下顺序执行），然后加载类的非静态变量和非静态语句块（按照代码上下顺序执行），最后加载类的构造函数。 </p><p>至于类的静态方法和非静态方法只有主动调用的时候才会执行,区别在于静态方法可以直接用类名直接调用(实例化对象也可以),而非静态方法只能先实例化对象后才能调用。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS:不管是父类还是子类加载（静态变量和静态语句块）都只能加载一次。</span><br><span class="line"></span><br><span class="line">总结：静态 -&gt; 非静态 -&gt; 构造函数</span><br></pre></td></tr></table></figure><h5 id="2-在有子类的情况下"><a href="#2-在有子类的情况下" class="headerlink" title="2.在有子类的情况下"></a>2.在有子类的情况下</h5><p>在初始化子类的时候，首先加载父类的静态变量和静态语句块（按照代码上下顺序执行），然后加载子类的静态变量和静态语句块（按照代码上下顺序执行），然后加载父类的非静态变量和非静态语句块（按照代码上下顺序执行），再加载父类的构造函数。然后加载子类的非静态变量和非静态语句块（按照代码上下顺序执行），最后加载子类的构造函数。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 父类的静态变量和静态语句块（按照代码上下顺序执行）</span><br><span class="line">2. 子类的静态变量和静态语句块（按照代码上下顺序执行）</span><br><span class="line">3. 父类的非静态变量和非静态语句块（按照代码上下顺序执行）</span><br><span class="line">4. 父类的构造函数</span><br><span class="line">5. 子类的非静态变量和非静态语句块（按照代码上下顺序执行）</span><br><span class="line">6. 子类的构造函数</span><br><span class="line"></span><br><span class="line">总结：父类静态--子类静态--父类非静态--父类构造--子类非静态--子类构造</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;参考链接: &lt;a href=&quot;https://blog.csdn.net/j_love93/article/details/77693230&quot;&gt;https://blog.csdn.net/j_love93/article/details/77693230&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;详解请查看全文。。。&lt;/p&gt;</summary>
    
    
    
    <category term="Java基础" scheme="https://sunrisel135.github.io/blog_lyl/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="知识点" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Java面试-Java基础</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/05/Java%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/05/Java%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/</id>
    <published>2024-03-05T02:21:45.000Z</published>
    <updated>2024-03-07T12:32:37.759Z</updated>
    
    <content type="html"><![CDATA[<p>持续更新。。。</p><span id="more"></span><h2 id="Java基础常见面试题-上"><a href="#Java基础常见面试题-上" class="headerlink" title="Java基础常见面试题(上)"></a>Java基础常见面试题(上)</h2><h3 id="【基础概念与常识】"><a href="#【基础概念与常识】" class="headerlink" title="【基础概念与常识】"></a>【基础概念与常识】</h3><h4 id="–Java-语言有哪些特点"><a href="#–Java-语言有哪些特点" class="headerlink" title="–Java 语言有哪些特点?"></a>–Java 语言有哪些特点?</h4><ul><li>面向对象（封装，继承，多态）</li><li>平台无关性（ Java 虚拟机实现平台无关性）</li><li>支持多线程</li><li>可靠性（具备异常处理和自动内存管理机制）</li><li>安全性（Java 语言本身的设计就提供了多重安全防护机制如访问权限修饰符、限制程序直接访问操作系统资源）</li><li>编译与解释并存</li></ul><h4 id="–Java-SE-vs-Java-EE"><a href="#–Java-SE-vs-Java-EE" class="headerlink" title="–Java SE vs Java EE"></a>–Java SE vs Java EE</h4><p>简单来说，Java SE 是 Java 的基础版本，Java EE 是 Java 的高级版本。Java SE 更适合开发桌面应用程序或简单的服务器应用程序，Java EE 更适合开发复杂的企业级应用程序或 Web 应用程序。</p><p>Java ME 是 Java 的微型版本，主要用于开发嵌入式消费电子设备的应用程序。</p><h4 id="–JVM-vs-JDK-vs-JRE"><a href="#–JVM-vs-JDK-vs-JRE" class="headerlink" title="–JVM vs JDK vs JRE"></a>–JVM vs JDK vs JRE</h4><ul><li><p><strong>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机</strong>。</p><p>JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“<strong>一次编译，随处可以运行</strong>”的关键所在。</p></li><li><p><strong>JRE（Java Runtime Environment） 是 Java 运行时环境。</strong></p><p>它是运行已编译 Java 程序所需的所有内容的集合，主要包括 <strong>Java 虚拟机（JVM）</strong>、<strong>Java 基础类库（Class Library）</strong>。</p></li><li><p><strong>JDK（Java Development Kit），它是功能齐全的 Java SDK，是提供给开发者使用，能够创建和编译 Java 程序的开发套件</strong>。</p><p>它包含了 <strong>JRE</strong>，同时还包含了<strong>编译 java 源码的编译器 javac 以及一些其他工具</strong>比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等。</p></li></ul><h4 id="–什么是字节码-采用字节码的好处是什么"><a href="#–什么是字节码-采用字节码的好处是什么" class="headerlink" title="–什么是字节码?采用字节码的好处是什么?"></a>–什么是字节码?采用字节码的好处是什么?</h4><p><strong>JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），只面向虚拟机。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java 程序从源代码到运行的过程：</span><br><span class="line">.java -&gt; javac 编译 -&gt; .class -&gt; 热点代码？ NO-&gt; 解释器 -&gt; 机器可理解的代码</span><br><span class="line">     YES-&gt; JIT -&gt; 机器可理解的代码</span><br></pre></td></tr></table></figure><p> <strong>JIT</strong>（Just in Time Compilation） <strong>编译器</strong>，而 JIT 属于<strong>运行时编译</strong>。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</p><h2 id="Java基础常见面试题-中"><a href="#Java基础常见面试题-中" class="headerlink" title="Java基础常见面试题(中)"></a>Java基础常见面试题(中)</h2><h3 id="【面向对象基础】"><a href="#【面向对象基础】" class="headerlink" title="【面向对象基础】"></a>【面向对象基础】</h3><h4 id="–-面向对象和面向过程的区别"><a href="#–-面向对象和面向过程的区别" class="headerlink" title="– 面向对象和面向过程的区别"></a>– 面向对象和面向过程的区别</h4><p>主要区别在于<strong>解决问题的方式</strong>不同：</p><ul><li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li></ul><p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p><h4 id="–-面向过程性能比面向对象高？"><a href="#–-面向过程性能比面向对象高？" class="headerlink" title="– 面向过程性能比面向对象高？"></a>– 面向过程性能比面向对象高？</h4><p><strong>面向过程性能比面向对象高</strong>。</p><p>因为<strong>类调用时需要实例化</strong>，开销较大，<strong>比较消耗资源</strong>，所以当性能是最重要的考量因素的的时候，比如单片机、嵌入式开发、Linux&#x2F;Unix等一般采用面向过程开发。</p><p>但这并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java性能差的主要原因并不是因为它是面向对象语言，而是<strong>Java是半编译语言，最终的执行代码并不是可以直接被CPU执行的二进制机械码</strong>。</p><p>而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其他一些面向过程的脚本语言性能也<strong>并不一定</strong>比Java好。</p><h4 id="–-创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#–-创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="– 创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>– 创建一个对象用什么运算符?对象实体与对象引用有何不同?</h4><p><strong>new</strong> 运算符。</p><p>new 创建对象实例 (对象实例在堆内存中)，<strong>对象引用</strong>指向<strong>对象实例</strong> (对象引用存放在栈内存中)。</p><ul><li>一个对象引用可以指向 0 个或 1 个对象；</li><li>一个对象可以有 n 个引用指向它；</li></ul><h4 id="–-对象的相等和引用相等的区别"><a href="#–-对象的相等和引用相等的区别" class="headerlink" title="– 对象的相等和引用相等的区别"></a>– 对象的相等和引用相等的区别</h4><ul><li><strong>对象的相等</strong>一般比较的是内存中<strong>存放的内容</strong>是否相等。</li><li><strong>引用相等</strong>一般比较的是他们<strong>指向的内存地址</strong>是否相等。</li></ul><h4 id="–-如果一个类没有声明构造方法，该程序能正确执行吗"><a href="#–-如果一个类没有声明构造方法，该程序能正确执行吗" class="headerlink" title="– 如果一个类没有声明构造方法，该程序能正确执行吗?"></a>– 如果一个类没有声明构造方法，该程序能正确执行吗?</h4><p><strong>可以</strong>执行！</p><p><strong>构造方法</strong>是一种特殊的方法，主要作用是完成对象的初始化工作。</p><p>一个类即使没有声明构造方法也会有<strong>默认的不带参数的构造方法</strong>。如果我们自己添加了类的构造方法 (无论是否有参)，Java 就不会添加默认的无参数的构造方法了。</p><p>这也是为什么我们在创建对象的时候后面要加一个括号 (因为要调用无参的构造方法)。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来 (无论是否用到)，因为这可以帮助我们在创建对象的时候少踩坑。</p><h4 id="–-构造方法有哪些特点？是否可被-override"><a href="#–-构造方法有哪些特点？是否可被-override" class="headerlink" title="– 构造方法有哪些特点？是否可被 override?"></a>– 构造方法有哪些特点？是否可被 override?</h4><ul><li>名字与类名相同。</li><li>没有返回值，但不能用 void 声明构造函数。</li><li>生成类的对象时自动执行，无需调用。</li></ul><p>构造方法不能被 override (重写),但是可以 overload (重载)。</p><h3 id="【面向对象三大特征】"><a href="#【面向对象三大特征】" class="headerlink" title="【面向对象三大特征】"></a>【面向对象三大特征】</h3><h4 id="–-封装"><a href="#–-封装" class="headerlink" title="– 封装"></a>– 封装</h4><p><strong>指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。</strong>但是可以提供一些可以被外界访问的方法来操作属性。如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p><h4 id="–-继承"><a href="#–-继承" class="headerlink" title="– 继承"></a>– 继承</h4><p>不同类型的对象，相互之间经常有一定数量的共同点。同时，每一个对象还定义了额外的特性使得他们与众不同。</p><p><strong>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。</strong>通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p><p><strong>注意：</strong></p><ol><li>子类拥有父类对象所有的属性和方法 (包括私有属性和私有方法)，但是<strong>父类中的私有属性和方法子类是无法访问</strong>，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。(以后介绍)。</li></ol><h4 id="–-多态"><a href="#–-多态" class="headerlink" title="– 多态"></a>– 多态</h4><p><strong>表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</strong></p><p><strong>特点:</strong></p><ul><li>对象类型和引用类型之间具有<strong>继承</strong> (类) &#x2F; 实现(接口)的<strong>关系</strong>；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序<strong>运行期间才能确定</strong>；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li></ul><h4 id="–-接口和抽象类有什么共同点和区别？"><a href="#–-接口和抽象类有什么共同点和区别？" class="headerlink" title="– 接口和抽象类有什么共同点和区别？"></a>– 接口和抽象类有什么共同点和区别？</h4><p><strong>共同点</strong>：</p><ul><li>都不能<strong>被实例化</strong>。</li><li>都可以<strong>包含抽象方法</strong>。</li><li>都可以<strong>有默认实现的方法</strong>（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</li></ul><p><strong>区别</strong>：</p><ul><li><strong>接口</strong>主要用于对<strong>类</strong>的<strong>行为</strong>进行<strong>约束</strong>，你实现了某个接口就具有了对应的行为。<strong>抽象类</strong>主要用于<strong>代码复用</strong>，<strong>强调的是所属关系</strong>。</li><li>一个类只能继承一个类，但是可以实现多个接口 (<strong>类的单继承，接口多继承</strong>)。</li><li><strong>接口</strong>中的<strong>成员变量</strong>只能是 <code>public static final</code> 类型的，<strong>不能被修改且必须有初始值</strong>，而<strong>抽象类</strong>的<strong>成员变量</strong>默认 <code>default</code>，<strong>可在子类中被重新定义，也可被重新赋值</strong>。</li></ul><h4 id="–-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><a href="#–-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？" class="headerlink" title="– 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"></a>– 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h4><ul><li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。（父类 <code>Object</code> 的 <code>clone()</code> 方法）</li><li><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。(重写了父类<code>Object</code> 的<code>clone(</code>)方法)</li></ul><p><strong>那什么是引用拷贝呢？</strong> 简单来说，<strong>引用拷贝</strong>就是两个不同的引用指向同一个对象。</p><p><img src="C:\Users\lyl\Desktop\其他\photo\shallow&deep-copy.png"></p><p>【Object】</p><h4 id="–-Object-类的常见方法有哪些？"><a href="#–-Object-类的常见方法有哪些？" class="headerlink" title="– Object 类的常见方法有哪些？"></a>– Object 类的常见方法有哪些？</h4><p>Object 类是一个特殊的类，是<strong>所有类的父类</strong>。它主要提供了以下 11 个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;持续更新。。。&lt;/p&gt;</summary>
    
    
    
    <category term="Java基础" scheme="https://sunrisel135.github.io/blog_lyl/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="面试" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Hexo搭建博客</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/04/Hexo+github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/04/Hexo+github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2024-03-04T12:12:17.000Z</published>
    <updated>2024-03-07T12:06:46.629Z</updated>
    
    <content type="html"><![CDATA[<p>基于 Hexo + GithubPage 搭建博客，我的第一个博客。</p><span id="more"></span><p>参考链接: <a href="https://blog.csdn.net/redrose2100/article/details/121731468">https://blog.csdn.net/redrose2100/article/details/121731468</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;基于 Hexo + GithubPage 搭建博客，我的第一个博客。&lt;/p&gt;</summary>
    
    
    
    <category term="博客相关" scheme="https://sunrisel135.github.io/blog_lyl/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="教程" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
