<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lyl&#39;blog</title>
  
  
  <link href="https://sunrisel135.github.io/blog_lyl/atom.xml" rel="self"/>
  
  <link href="https://sunrisel135.github.io/blog_lyl/"/>
  <updated>2024-03-13T02:14:28.815Z</updated>
  <id>https://sunrisel135.github.io/blog_lyl/</id>
  
  <author>
    <name>lyl_L-</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库面试-数据库基础</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</id>
    <published>2024-03-13T02:13:28.000Z</published>
    <updated>2024-03-13T02:14:28.815Z</updated>
    
    <content type="html"><![CDATA[<p>基础概念</p><span id="more"></span><h3 id="【数据库基础】"><a href="#【数据库基础】" class="headerlink" title="【数据库基础】"></a>【数据库基础】</h3><h4 id="–-什么是数据库-数据库管理系统-数据库系统-数据库管理员"><a href="#–-什么是数据库-数据库管理系统-数据库系统-数据库管理员" class="headerlink" title="– 什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?"></a>– 什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?</h4><ul><li><strong>数据库</strong> : 数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。</li><li><strong>数据库管理系统</strong> : 数据库管理系统(Database Management System 简称 DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。</li><li><strong>数据库系统</strong> : 数据库系统(Data Base System，简称 DBS)通常由软件、数据库和数据管理员(DBA)组成。</li><li><strong>数据库管理员</strong> : 数据库管理员(Database Administrator, 简称 DBA)负责全面管理和控制数据库系统。</li></ul><h4 id="–-什么是元组-码-候选码-主码-外码-主属性-非主属性？"><a href="#–-什么是元组-码-候选码-主码-外码-主属性-非主属性？" class="headerlink" title="– 什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？"></a>– 什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？</h4><p><strong>元组</strong>：元组（tuple），<strong>表中的每行</strong>（即数据库中的每条记录）就是一个元组，<strong>每列就是一个属性</strong>。 在二维表里，元组也称为<strong>行</strong>。</p><p><strong>码</strong>：码就是能唯一标识实体的属性，对应表中的<strong>列</strong>。</p><p><strong>候选码</strong>：若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性组为候选码。</p><p><strong>主码</strong> : 主码也叫<strong>主键</strong>。主码是从<strong>候选码中</strong>选出来的。 一<strong>个实体集中只能有一个主码，但可以有多个候选码。</strong></p><p><strong>外码</strong> : 外码也叫<strong>外键</strong>。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。</p><p><strong>主属性</strong>：<strong>候选码中出现过的属性称为主属性</strong>。如果主码是一个属性组，那么属性组中的属性都是主属性。</p><p><strong>非主属性：</strong> <strong>不包含在任何一个候选码中的属性称为非主属性。</strong></p><h4 id="–-什么是-ER-图？"><a href="#–-什么是-ER-图？" class="headerlink" title="– 什么是 ER 图？"></a>– 什么是 ER 图？</h4><p> Entity Relationship Diagram（实体联系图），提供了表示<strong>实体</strong>类型、<strong>属性</strong>和<strong>联系</strong>的方法。</p><h4 id="–-数据库范式了解吗"><a href="#–-数据库范式了解吗" class="headerlink" title="– 数据库范式了解吗?"></a>– 数据库范式了解吗?</h4><ul><li>1NF(第一范式)：属性不可再分。</li><li>2NF(第二范式)：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。</li><li>3NF(第三范式)：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。</li></ul><h4 id="–-主键和外键有什么区别"><a href="#–-主键和外键有什么区别" class="headerlink" title="– 主键和外键有什么区别?"></a>– 主键和外键有什么区别?</h4><ul><li>**主键(主码)**：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。</li><li>**外键(外码)**：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</li></ul><h4 id="–-drop、delete-与-truncate-区别？"><a href="#–-drop、delete-与-truncate-区别？" class="headerlink" title="– drop、delete 与 truncate 区别？"></a>– drop、delete 与 truncate 区别？</h4><p><code>truncate</code> 和 <code>drop</code> 属于 <strong>DDL</strong>(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。</p><p> <code>delete</code> 语句是 <strong>DML</strong> (数据库操作语言)语句，这个操作会放到 rollback segment 中，事务提交之后才生效。</p><ul><li><code>drop</code>(丢弃数据): <code>drop table 表名</code> ，直接将表都删除掉，在<strong>删除表</strong>的时候使用。</li><li><code>truncate</code> (清空数据) : <code>truncate table 表名</code> ，只<strong>删除表中的数据</strong>，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。</li><li><code>delete</code>（删除数据） : <code>delete from 表名 where 列名=值</code>，<strong>删除某一行的数据</strong>，如果不加 <code>where</code> 子句和<code>truncate table 表名</code>作用类似。</li></ul><h3 id="【NoSQL基础知识】"><a href="#【NoSQL基础知识】" class="headerlink" title="【NoSQL基础知识】"></a>【NoSQL基础知识】</h3><h4 id="–-NoSQL-是什么？"><a href="#–-NoSQL-是什么？" class="headerlink" title="– NoSQL 是什么？"></a>– NoSQL 是什么？</h4><p>NoSQL（Not Only SQL 的缩写）泛指<strong>非关系型的数据库</strong>，主要针对的是<strong>键值</strong>、<strong>文档</strong>以及<strong>图形类型数据</strong>存储。并且，NoSQL 数据库天生<strong>支持分布式</strong>，<strong>数据冗余</strong>和<strong>数据分片</strong>等特性，旨在提供可扩展的高可用高性能数据存储解决方案。</p><p>NoSQL 数据库可以存储关系型数据—它们与关系型数据库的存储方式不同。</p><h4 id="–-NoSQL-数据库有什么优势？"><a href="#–-NoSQL-数据库有什么优势？" class="headerlink" title="– NoSQL 数据库有什么优势？"></a>– NoSQL 数据库有什么优势？</h4><p>NoSQL 数据库非常适合许多现代应用程序，例如移动、Web 和游戏等应用程序，它们需要<strong>灵活</strong>、<strong>可扩展</strong>、<strong>高性能</strong>和<strong>功能强大</strong>的数据库以提供卓越的用户体验。</p><h4 id="–-NoSQL-数据库有哪些类型？"><a href="#–-NoSQL-数据库有哪些类型？" class="headerlink" title="– NoSQL 数据库有哪些类型？"></a>– NoSQL 数据库有哪些类型？</h4><p><strong>键值</strong>：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。</p><p><strong>文档</strong>：文档数据库中的数据被存储在类似于 JSON（JavaScript 对象表示法）对象的文档中，非常清晰直观。</p><p><strong>图形</strong>：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。</p><p><strong>宽列</strong>：宽列存储数据库非常适合需要存储大量的数据。</p><h3 id="【MySQL-字符集】"><a href="#【MySQL-字符集】" class="headerlink" title="【MySQL 字符集】"></a>【MySQL 字符集】</h3><p>MySQL 支持很多种字符集的方式，比如 GB2312、GBK、BIG5、多种 Unicode 字符集（UTF-8 编码、UTF-16 编码、UCS-2 编码、UTF-32 编码等等）。</p><h4 id="–-默认字符集"><a href="#–-默认字符集" class="headerlink" title="– 默认字符集"></a>– 默认字符集</h4><p>在 MySQL5.7 中，默认字符集是 <code>latin1</code> ；在 MySQL8.0 中，默认字符集是 <strong><code>utf8mb4</code></strong></p><h4 id="–-字符集的层次级别"><a href="#–-字符集的层次级别" class="headerlink" title="– 字符集的层次级别"></a>– 字符集的层次级别</h4><p>MySQL 中的字符集有以下的层次级别：</p><ul><li><code>server</code>（MySQL 实例级别）</li><li><code>database</code>（库级别）</li><li><code>table</code>（表级别）</li><li><code>column</code>（字段级别）</li></ul><h4 id="–-UTF-8-使用"><a href="#–-UTF-8-使用" class="headerlink" title="– UTF-8 使用"></a>– UTF-8 使用</h4><p>MySQL 字符编码集中有两套 UTF-8 编码实现：</p><ul><li>**<code>utf8</code>**：<code>utf8</code>编码只支持<code>1-3</code>个字节 。 在 <code>utf8</code> 编码中，中文是占 3 个字节，其他数字、英文、符号占一个字节。但 emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节。</li><li>**<code>utf8mb4</code>**：UTF-8 的完整实现，正版！最多支持使用 4 个字节表示字符，因此，可以用来存储 emoji 符号。</li></ul><p>如果你需要存储<code>emoji</code>类型的数据或者一些比较复杂的文字、繁体字到 MySQL 数据库的话，数据库的编码一定要指定为<code>utf8mb4</code> 而不是<code>utf8</code> ，要不然存储的时候就会报错了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;基础概念&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://sunrisel135.github.io/blog_lyl/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="面试" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>数据库面试-MySQL</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95-MySQL/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95-MySQL/</id>
    <published>2024-03-13T02:11:29.000Z</published>
    <updated>2024-03-13T12:43:08.722Z</updated>
    
    <content type="html"><![CDATA[<p>持续补充…</p><span id="more"></span><h3 id="【MySQL-基础】"><a href="#【MySQL-基础】" class="headerlink" title="【MySQL 基础】"></a>【MySQL 基础】</h3><h4 id="–-什么是关系型数据库？"><a href="#–-什么是关系型数据库？" class="headerlink" title="– 什么是关系型数据库？"></a>– 什么是关系型数据库？</h4><p>关系型数据库（RDB，Relational Database）就是一种<strong>建立在关系模型的基础上的数据库</strong>。<strong>关系模型表明了数据库中所存储的数据之间的联系</strong>（一对一、一对多、多对多）。大部分关系型数据库都支持事务的四大特性(<strong>ACID</strong>)。</p><h4 id="–-什么是-SQL？"><a href="#–-什么是-SQL？" class="headerlink" title="– 什么是 SQL？"></a>– 什么是 SQL？</h4><p>一种结构化查询语言(Structured Query Language)，专门用来与数据库打交道，目的是提供一种从数据库中读写数据的简单有效的方法。</p><p>几乎所有的主流关系数据库都支持 SQL ，适用性非常强。并且，一些非关系型数据库也兼容 SQL 或者使用的是类似于 SQL 的查询语言。</p><h4 id="–-什么是-MySQL？"><a href="#–-什么是-MySQL？" class="headerlink" title="– 什么是 MySQL？"></a>– 什么是 MySQL？</h4><p><strong>MySQL 是一种关系型数据库，主要用于持久化存储我们的系统中的一些数据比如用户信息。</strong></p><p>由于 MySQL 是开源免费并且比较成熟的数据库，因此，MySQL 被大量使用在各种系统中。任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是<strong>3306</strong>。</p><h4 id="–-MySQL-有什么优点？"><a href="#–-MySQL-有什么优点？" class="headerlink" title="– MySQL 有什么优点？"></a>– MySQL 有什么优点？</h4><ol><li>成熟稳定，功能完善。</li><li>开源免费。</li><li>文档丰富，既有详细的官方文档，又有非常多优质文章可供参考学习。</li><li>开箱即用，操作简单，维护成本低。</li><li>兼容性好，支持常见的操作系统，支持多种开发语言。</li><li>社区活跃，生态完善。</li><li>事务支持优秀， InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失，并且，InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的。</li><li>支持分库分表、读写分离、高可用。</li></ol><h4 id="–-MySQL-字段类型"><a href="#–-MySQL-字段类型" class="headerlink" title="– MySQL 字段类型"></a>– MySQL 字段类型</h4><ul><li><strong>数值类型</strong>：整型（TINYINT、SMALLINT、MEDIUMINT、INT 和 BIGINT）、浮点型（FLOAT 和 DOUBLE）、定点型（DECIMAL）</li><li><strong>字符串类型</strong>：CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB 等，最常用的是 CHAR 和 VARCHAR。</li><li><strong>日期时间类型</strong>：YEAR、TIME、DATE、DATETIME 和 TIMESTAMP 等。</li></ul><h4 id="–-整数类型的-UNSIGNED-属性有什么用？unsigned"><a href="#–-整数类型的-UNSIGNED-属性有什么用？unsigned" class="headerlink" title="– 整数类型的 UNSIGNED 属性有什么用？unsigned"></a>– 整数类型的 UNSIGNED 属性有什么用？unsigned</h4><p>MySQL 中的整数类型可以使用可选的 UNSIGNED 属性来<strong>表示不允许负值的无符号整数</strong>。使用 UNSIGNED 属性可以将正整数的上限提高一倍，因为它不需要存储负数值。</p><h4 id="–-CHAR-和-VARCHAR-的区别是什么？★"><a href="#–-CHAR-和-VARCHAR-的区别是什么？★" class="headerlink" title="– CHAR 和 VARCHAR 的区别是什么？★"></a>– CHAR 和 VARCHAR 的区别是什么？★</h4><p>主要区别在于：<strong>CHAR 是定长字符串，VARCHAR 是变长字符串。</strong></p><ul><li><p><strong>CHAR</strong> 在<strong>存储时</strong>会<strong>在右边填充空格</strong>以达到指定的长度，<strong>检索时</strong>会<strong>去掉空格</strong>；</p><p><strong>VARCHAR</strong> 在<strong>存储时</strong>需要使用 1 或 2 个<strong>额外字节记录</strong>字符串的<strong>长度</strong>，<strong>检索时不</strong>需要<strong>处理</strong>。</p></li><li><p><strong>CHAR</strong> 更适合存储<strong>长度较短或者长度都差不多的字符串</strong>，例如 <em>Bcrypt 算法、MD5 算法加密后的密码、身份证号码</em>。</p><p><strong>VARCHAR</strong> 类型适合存储<strong>长度不确定或者差异较大的字符串</strong>，例如<em>用户昵称、文章标题</em>等。</p></li><li><p>CHAR(M) 和 VARCHAR(M) 的 M 都代表能够保存的字符数的最大值，无论是字母、数字还是中文，每个都只占用一个字符。</p></li></ul><h4 id="–-VARCHAR-100-和-VARCHAR-10-的区别是什么？"><a href="#–-VARCHAR-100-和-VARCHAR-10-的区别是什么？" class="headerlink" title="– VARCHAR(100)和 VARCHAR(10)的区别是什么？"></a>– VARCHAR(100)和 VARCHAR(10)的区别是什么？</h4><p> <strong>VARCHAR(100)和 VARCHAR(10)能存储的字符范围不同，但二者存储相同的字符串，所占用磁盘的存储空间其实是一样的。</strong></p><ul><li>VARCHAR (100) <strong>可以满足更大范围的字符存储需求，有更好的业务拓展性</strong>。而 VARCHAR(10)存储<strong>超过 10 个字符时，就需要修改表结构才可以</strong>。</li><li>VARCHAR(100) 会消耗更多的内存。这是因为 VARCHAR 类型在内存中操作时，通常会分配固定大小的内存块来保存值，即使用字符类型中定义的长度。</li></ul><h4 id="–-DECIMAL-和-FLOAT-DOUBLE-的区别是什么？"><a href="#–-DECIMAL-和-FLOAT-DOUBLE-的区别是什么？" class="headerlink" title="– DECIMAL 和 FLOAT&#x2F;DOUBLE 的区别是什么？"></a>– DECIMAL 和 FLOAT&#x2F;DOUBLE 的区别是什么？</h4><p>DECIMAL 和 FLOAT 的区别是：<strong>DECIMAL 是定点数，FLOAT&#x2F;DOUBLE 是浮点数。DECIMAL 可以存储精确的小数值，FLOAT&#x2F;DOUBLE 只能存储近似的小数值。</strong></p><h4 id="–-为什么不推荐使用-TEXT-和-BLOB？"><a href="#–-为什么不推荐使用-TEXT-和-BLOB？" class="headerlink" title="– 为什么不推荐使用 TEXT 和 BLOB？"></a>– 为什么不推荐使用 TEXT 和 BLOB？</h4><p>TEXT 类型类似于 CHAR（0-255 字节）和 VARCHAR（0-65,535 字节），但可以存储更长的字符串，即长文本数据，例如博客内容。</p><p>数据库规范通常不推荐使用 BLOB 和 TEXT 类型，这两种类型具有一些缺点和限制，例如：</p><ul><li>不能有默认值。</li><li>在使用临时表时无法使用内存临时表，只能在磁盘上创建临时表（《高性能 MySQL》书中有提到）。</li><li>检索效率较低。</li><li>不能直接创建索引，需要指定前缀长度。</li><li>可能会消耗大量的网络和 IO 带宽。</li><li>可能导致表上的 DML 操作变慢。</li></ul><h4 id="–-DATETIME-和-TIMESTAMP-的区别是什么？"><a href="#–-DATETIME-和-TIMESTAMP-的区别是什么？" class="headerlink" title="– DATETIME 和 TIMESTAMP 的区别是什么？"></a>– DATETIME 和 TIMESTAMP 的区别是什么？</h4><p>DATETIME 类型没有时区信息，TIMESTAMP 和<strong>时区有关</strong>。</p><p>TIMESTAMP 只需要使用 4 个字节的存储空间，但是 DATETIME 需要耗费 8 个字节的存储空间。但是，这样同样造成了一个问题，Timestamp 表示的时间范围更小。</p><h4 id="–-NULL-和-‘’-的区别是什么？"><a href="#–-NULL-和-‘’-的区别是什么？" class="headerlink" title="– NULL 和 ‘’ 的区别是什么？"></a>– NULL 和 ‘’ 的区别是什么？</h4><p><code>NULL</code> 跟 <code>&#39;&#39;</code>(空字符串)是两个完全不一样的值，区别如下：</p><ul><li><code>NULL</code> 代表一个<strong>不确定的值</strong>,就算是两个 <code>NULL</code>,它俩也不一定相等。例如，<code>SELECT NULL=NULL</code>的结果为 false，但是在我们使用<code>DISTINCT</code>,<code>GROUP BY</code>,<code>ORDER BY</code>时,<code>NULL</code>又被认为是相等的。</li><li><code>&#39;&#39;</code>的<strong>长度是 0，是不占用空间的</strong>，而<code>NULL</code> 是需要占用空间的。</li><li><code>NULL</code> 会<strong>影响聚合函数的结果</strong>。例如，<code>SUM</code>、<code>AVG</code>、<code>MIN</code>、<code>MAX</code> 等聚合函数会忽略 <code>NULL</code> 值。 <code>COUNT</code> 的处理方式取决于参数的类型。如果参数是 <code>*</code>(<code>COUNT(*)</code>)，则会统计所有的记录数，包括 <code>NULL</code> 值；如果参数是某个字段名(<code>COUNT(列名)</code>)，则会忽略 <code>NULL</code> 值，只统计非空值的个数。</li><li>查询 <code>NULL</code> 值时，必须<strong>使用 <code>IS NULL</code> 或 <code>IS NOT NULLl</code> 来判断</strong>，而不能使用 &#x3D;、!&#x3D;、 &lt;、&gt; 之类的比较运算符。而<code>&#39;&#39;</code>是可以使用这些比较运算符的。</li></ul><p>看了上面的介绍之后，相信你对另外一个高频面试题：“<strong>为什么 MySQL 不建议使用 <code>NULL</code> 作为列默认值？</strong>”也有了答案。</p><h4 id="–-Boolean-类型如何表示？tinyint-1"><a href="#–-Boolean-类型如何表示？tinyint-1" class="headerlink" title="– Boolean 类型如何表示？tinyint(1)"></a>– Boolean 类型如何表示？tinyint(1)</h4><p>MySQL 中没有专门的布尔类型，而是用 <strong>TINYINT(1)</strong> 类型来表示布尔值。<strong>TINYINT(1) 类型可以存储 0 或 1，分别对应 false 或 true。</strong></p><h3 id="【MySQL-基础架构】"><a href="#【MySQL-基础架构】" class="headerlink" title="【MySQL 基础架构】"></a>【MySQL 基础架构】</h3><p> <a href="https://javaguide.cn/database/mysql/how-sql-executed-in-mysql.html">SQL 语句在 MySQL 中的执行过程</a> ★</p><ol><li><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li><li><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li><li><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li><li><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</li><li><strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。</li><li><strong>插件式存储引擎</strong>：主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。</li></ol><h3 id="【MySQL-存储引擎】"><a href="#【MySQL-存储引擎】" class="headerlink" title="【MySQL 存储引擎】"></a>【MySQL 存储引擎】</h3><h4 id="–-MySQL-支持哪些存储引擎？默认使用哪个？"><a href="#–-MySQL-支持哪些存储引擎？默认使用哪个？" class="headerlink" title="– MySQL 支持哪些存储引擎？默认使用哪个？"></a>– MySQL 支持哪些存储引擎？默认使用哪个？</h4><p> <code>SHOW ENGINES</code> 命令来查看 MySQL 支持的所有存储引擎。</p><p> <code>SELECT VERSION()</code> 命令查看你的 MySQL 版本。</p><p><code>SHOW VARIABLES LIKE &#39;%storage_engine%&#39;</code> 命令直接查看 MySQL 当前默认的存储引擎。</p><ul><li>MySQL 5.5.5 之前，<strong>MyISAM</strong> 是 MySQL 的默认存储引擎。</li><li><strong>5.5.5 版本</strong>之后，<strong>InnoDB</strong> 是 MySQL 的默认存储引擎。</li></ul><h4 id="–-MySQL-存储引擎架构了解吗？"><a href="#–-MySQL-存储引擎架构了解吗？" class="headerlink" title="– MySQL 存储引擎架构了解吗？"></a>– MySQL 存储引擎架构了解吗？</h4><p>MySQL 存储引擎采用的是 <strong>插件式架构</strong> ，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。<strong>存储引擎是基于表的，而不是数据库。</strong></p><p>还可以根据 MySQL 定义的存储引擎实现标准接口来编写一个属于自己的存储引擎。</p><h4 id="–-MyISAM-和-InnoDB-有什么区别？☆"><a href="#–-MyISAM-和-InnoDB-有什么区别？☆" class="headerlink" title="– MyISAM 和 InnoDB 有什么区别？☆"></a>– MyISAM 和 InnoDB 有什么区别？☆</h4><p>MyISAM <strong>不支持事务和行级锁</strong>，而且最大的缺陷就是<strong>崩溃后无法安全恢复</strong>。</p><p><strong>总结</strong>：</p><ul><li>InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度。</li><li>MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。</li><li>MyISAM 不支持外键，而 InnoDB 支持。</li><li>MyISAM 不支持 MVCC，而 InnoDB 支持。</li><li>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</li><li>MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。</li><li>InnoDB 的性能比 MyISAM 更强大。</li></ul><ol><li><p><strong>是否支持行级锁</strong></p><ul><li><strong>MyISAM 只有表级锁</strong>(table-level locking)，而 <strong>InnoDB 支持行级锁</strong>(row-level locking)和<strong>表级锁</strong>，默认行级锁。</li><li>也就说，MyISAM 一锁就是锁住了整张表，这在并发写的情况下是多么滴憨憨啊！这也是为什么 InnoDB 在并发写的时候，性能更牛皮了！</li></ul></li><li><p><strong>是否支持事务</strong></p><p><strong>MyISAM 不提供事务支持。</strong></p><p>InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有<strong>提交(commit)和回滚(rollback)事务</strong>的能力。并且，InnoDB 默认使用的 <strong>REPEATABLE-READ（可重读）隔离级别</strong>是可以<strong>解决幻读</strong>问题发生的（基于 MVCC 和 Next-Key Lock）。</p></li><li><p><strong>是否支持外键</strong></p><p><strong>MyISAM 不支持，而 InnoDB 支持。</strong></p><ul><li>外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗。</li><li>一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据你的项目来决定。</li></ul></li><li><p><strong>是否支持数据库异常崩溃后的安全恢复</strong></p><p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code> 。</p></li><li><p><strong>是否支持 MVCC</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><ul><li>MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。</li></ul></li><li><p><strong>索引实现不一样</strong></p><p>MyISAM 引擎和 InnoDB 引擎都是使用 <strong>B+Tree 作为索引结构</strong>，但是两者的实现方式不一样。</p><p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。</p></li><li><p><strong>性能有差别</strong></p><p>InnoDB 的性能比 MyISAM 更强大</p></li></ol><h4 id="–-MyISAM-和-InnoDB-如何选择？"><a href="#–-MyISAM-和-InnoDB-如何选择？" class="headerlink" title="– MyISAM 和 InnoDB 如何选择？"></a>– MyISAM 和 InnoDB 如何选择？</h4><p>大多数时候使用的都是 InnoDB 存储引擎，在某些<strong>读密集的情况</strong>下，使用 MyISAM 也是合适的。不过，前提是不介意 MyISAM 不支持事务、崩溃恢复等缺点（可是~我们一般都会介意！）。</p><h3 id="【MySQL-索引】"><a href="#【MySQL-索引】" class="headerlink" title="【MySQL 索引】"></a>【MySQL 索引】</h3><h4 id="–-索引介绍"><a href="#–-索引介绍" class="headerlink" title="– 索引介绍"></a>– 索引介绍</h4><p><strong>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</strong></p><p>索引的作用就相当于书的目录。</p><p>索引底层数据结构存在很多种类型，常见的索引结构有: <strong>B 树， B+树 和 Hash、红黑树</strong>。在 MySQL 中，无论是 <strong>Innodb</strong> 还是 <strong>MyIsam</strong>，都使用了 <strong>【B+树】</strong>作为索引结构，但是，两者的实现方式不太一样。</p><h4 id="–-索引的优缺点"><a href="#–-索引的优缺点" class="headerlink" title="– 索引的优缺点"></a>– 索引的优缺点</h4><p><strong>优点</strong>：</p><ul><li>使用索引可以大大<strong>加快数据的检索速度</strong>（大大<strong>减少检索的数据量</strong>）, 这也是创建索引的最主要的原因。</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>创建索引和维护索引</strong>需要<strong>耗费</strong>许多<strong>时间</strong>。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li><li>索引需要使用物理文件存储，也会耗费一定空间。</li></ul><p><strong>使用索引一定能提高查询性能吗?</strong></p><p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p><h4 id="–-索引底层数据结构选型"><a href="#–-索引底层数据结构选型" class="headerlink" title="– 索引底层数据结构选型"></a>– 索引底层数据结构选型</h4><h5 id="Hash-表"><a href="#Hash-表" class="headerlink" title="Hash 表"></a>Hash 表</h5><p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。</p><ul><li><p><strong>为何能够通过 key 快速取出 value 呢？</strong> </p><p>原因在于 <strong>哈希算法</strong>（也叫散列算法）。通过哈希算法，我们可以快速找到 key 对应的 index，找到了 index 也就找到了对应的 value。</p><p>出现<strong>Hash 冲突</strong> ，常用的解决办法是 <strong>链地址法</strong>。</p></li><li><p><strong>为什么 MySQL 没有使用其作为索引的数据结构呢？</strong></p><p>主要是因为 Hash 索引不支持顺序和范围查询。</p></li></ul><h5 id="二叉查找树-BST"><a href="#二叉查找树-BST" class="headerlink" title="二叉查找树(BST)"></a>二叉查找树(BST)</h5><p>二叉查找树（Binary Search Tree）是一种基于二叉树的数据结构，它具有以下特点：</p><ol><li>左子树所有节点的值均小于根节点的值。</li><li>右子树所有节点的值均大于根节点的值。</li><li>左右子树也分别为二叉查找树。</li></ol><p><strong>二叉查找树的性能非常依赖于它的平衡程度，这就导致其不适合作为 MySQL 底层索引的数据结构。</strong></p><h5 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h5><p>AVL 树是最早被发明的<strong>自平衡二叉查找树</strong>，特点是保证<strong>任何节点的左右子树高度之差不超过 1</strong>，因此也被称为高度平衡二叉树，它的查找、插入和删除在平均和最坏情况下的时间复杂度都是 O(logn)。</p><p>由于 AVL 树需要频繁地进行<strong>旋转操作</strong>来保持平衡，因此会有较大的计算开销进而降低了查询性能。并且， 在使用 AVL 树时，每个树节点仅存储一个数据，而每次进行磁盘 IO 时只能读取一个节点的数据，如果需要查询的数据分布在多个节点上，那么就需要进行多次磁盘 IO。 <strong>磁盘 IO 是一项耗时的操作，在设计数据库索引时，我们需要优先考虑如何最大限度地减少磁盘 IO 操作的次数。</strong></p><p>实际应用中，AVL 树使用的并不多。</p><h5 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h5><p>红黑树是一种<strong>自平衡二叉查找树</strong>，通过在插入和删除节点时进行<strong>颜色变换</strong>和<strong>旋转操作</strong>，使得树始终保持平衡状态，它具有以下特点：</p><ol><li>每个节点非红即黑；</li><li><strong>根节点总是黑色的</strong>；</li><li>每个<strong>叶子节点都是黑色的空节点</strong>（NIL 节点）；</li><li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</li><li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</li></ol><p><strong>红黑树的应用还是比较广泛的，TreeMap、TreeSet 以及 JDK1.8 的 HashMap 底层都用到了红黑树。对于数据在内存中的这种情况来说，红黑树的表现是非常优异的。</strong></p><h5 id="B-树-B-树"><a href="#B-树-B-树" class="headerlink" title="B 树&amp; B+树"></a>B 树&amp; B+树</h5><p>B 树也称 B-树,全称为 <strong>多路平衡查找树</strong> ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 Balanced （平衡）的意思。<strong>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。</strong></p><p><strong>B 树&amp; B+树两者有何异同呢？</strong></p><ul><li><strong>B 树的所有节点既存放键(key) 也存放数据(data)<strong>，而 <strong>B+树只有叶子节点存放 key 和 data</strong>，其他</strong>内节点只存放 key</strong>。</li><li>B 树的叶子节点都是独立的;<strong>B+树的叶子节点有一条引用链指向与它相邻的叶子节点</strong>。</li><li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li><li>在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。</li></ul><p>综上，B+树与 B 树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。</p><h4 id="–-索引类型总结"><a href="#–-索引类型总结" class="headerlink" title="– 索引类型总结"></a>– 索引类型总结</h4><p>按照<strong>数据结构维度</strong>划分：</p><ul><li><strong>BTree 索引</strong>：<strong>MySQL</strong> 里<strong>默认</strong>和最常用的索引类型。只有叶子节点存储 value，非叶子节点只有指针和 key。存储引擎 MyISAM 和 InnoDB 实现 BTree 索引都是使用 <strong>B+Tree</strong>。</li><li>哈希索引：类似键值对的形式，一次即可定位。</li><li>RTree 索引：一般不会使用，仅支持 geometry 数据类型，优势在于范围查找，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li><li>全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li></ul><p>按照<strong>底层存储方式</strong>角度划分：</p><ul><li><p><strong>聚簇索引（聚集索引）</strong>：<strong>索引结构和数据一起存放的索引</strong>，InnoDB 中的<strong>主键索引</strong>就属于聚簇索引。</p><p><strong>优点</strong>：</p><ul><li><strong>查询速度非常快</strong>：定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作。</li><li><strong>对排序查找和范围查找优化</strong>：聚簇索引对于主键的排序查找和范围查找速度非常快。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>依赖于有序的数据</strong>：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li><li><strong>更新代价大</strong>：如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。</li></ul></li><li><p><strong>非聚簇索引（非聚集索引）</strong>：<strong>索引结构和数据分开存放的索引</strong>，<strong>二级索引</strong>(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。</p><p><strong>优点</strong>：</p><p>更新代价比聚簇索引要小 。非聚簇索引的叶子节点是不存放数据的</p><p><strong>缺点</strong>：</p><ul><li><strong>依赖于有序的数据</strong>:跟聚簇索引一样，非聚簇索引也依赖于有序的数据</li><li><strong>可能会二次查询(回表)</strong>:这应该是非聚簇索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li></ul></li></ul><p>按照<strong>应用维度</strong>划分：</p><ul><li><p>主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。</p></li><li><p>普通索引：仅加速查询。</p></li><li><p>唯一索引：加速查询 + 列值唯一（可以有 NULL）。</p></li><li><p>覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。</p><p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</strong></p></li><li><p>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。</p></li><li><p>全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</p></li></ul><p>MySQL 8.x 中实现的索引新特性：</p><ul><li>隐藏索引：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置）。</li><li>降序索引：之前的版本就支持通过 desc 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引。另外，在 MySQL 8.x 版本中，不再对 GROUP BY 语句进行隐式排序。</li><li>函数索引：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。</li></ul><h4 id="–-非聚簇索引一定回表查询吗-覆盖索引"><a href="#–-非聚簇索引一定回表查询吗-覆盖索引" class="headerlink" title="– 非聚簇索引一定回表查询吗(覆盖索引)?"></a>– 非聚簇索引一定回表查询吗(覆盖索引)?</h4><p><strong>非聚簇索引不一定回表查询。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">试想一种情况，用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引。</span><br><span class="line">那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。</span><br><span class="line">即使是 MYISAM 也是这样，虽然 MYISAM 的主键索引确实需要回表，因为它的主键索引的叶子节点存放的是指针。但是！如果 SQL 查的就是主键呢?</span><br><span class="line">主键索引本身的 key 就是主键，查到返回就行了。这种情况就称之为覆盖索引了。</span><br></pre></td></tr></table></figure><h4 id="–-最左前缀匹配原则-☆"><a href="#–-最左前缀匹配原则-☆" class="headerlink" title="– 最左前缀匹配原则 ☆"></a>– 最左前缀匹配原则 ☆</h4><p>在使用联合索引时，<strong>MySQL</strong> 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 <strong><code>&gt;</code><strong>、</strong><code>&lt;</code></strong> ）才会停止匹配。对于 <strong><code>&gt;=</code><strong>、</strong><code>&lt;=</code><strong>、</strong><code>BETWEEN</code><strong>、</strong><code>like</code></strong> 前缀匹配的范围查询，并不会停止匹配。所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。</p><h4 id="–-索引下推"><a href="#–-索引下推" class="headerlink" title="– 索引下推"></a>– 索引下推</h4><p>MySQL 5.6 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。</p><h4 id="–-正确使用索引"><a href="#–-正确使用索引" class="headerlink" title="– 正确使用索引"></a>– 正确使用索引</h4><h4 id="–-什么是慢查询？如何优化？"><a href="#–-什么是慢查询？如何优化？" class="headerlink" title="– 什么是慢查询？如何优化？"></a>– 什么是慢查询？如何优化？</h4><h3 id="【MySQL-查询缓存（不实用）】"><a href="#【MySQL-查询缓存（不实用）】" class="headerlink" title="【MySQL 查询缓存（不实用）】"></a>【MySQL 查询缓存（不实用）】</h3><p>执行查询语句的时候，会先查询缓存。不过，MySQL 8.0 版本后移除，因为这个功能不太实用。</p><p>开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果。</p><p>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。 </p><h3 id="【MySQL-日志】"><a href="#【MySQL-日志】" class="headerlink" title="【MySQL 日志】"></a>【MySQL 日志】</h3><ul><li>MySQL 中常见的日志有哪些？</li><li>慢查询日志有什么用？</li><li>binlog 主要记录了什么？</li><li>redo log 如何保证事务的持久性？</li><li>页修改之后为什么不直接刷盘呢？</li><li>binlog 和 redolog 有什么区别？</li><li>undo log 如何保证事务的原子性？</li></ul><h3 id="【MySQL-事务】"><a href="#【MySQL-事务】" class="headerlink" title="【MySQL 事务】"></a>【MySQL 事务】</h3><h4 id="–-何谓事务？"><a href="#–-何谓事务？" class="headerlink" title="– 何谓事务？"></a>– 何谓事务？</h4><ul><li><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></li></ul><h4 id="–-何谓数据库事务？"><a href="#–-何谓数据库事务？" class="headerlink" title="– 何谓数据库事务？"></a>– 何谓数据库事务？</h4><ul><li>如果没有特指分布式事务，往往指的就是数据库事务。</li></ul><h5 id="那数据库事务有什么作用呢？"><a href="#那数据库事务有什么作用呢？" class="headerlink" title="那数据库事务有什么作用呢？"></a>那数据库事务有什么作用呢？</h5><ul><li><p>可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。</p></li><li><p>数据库操作遵循：<strong>要么全部执行成功,要么全部不执行</strong> 。</p></li><li><p>另外，关系型数据库（例如：MySQL、SQL Server、Oracle 等）事务都有 <strong>ACID 特性</strong>：</p><ul><li><strong>原子性</strong>（<code>Atomicity</code>）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性</strong>（<code>Consistency</code>）：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li><strong>隔离性</strong>（<code>Isolation</code>）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性</strong>（<code>Durability</code>）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ul></li><li><p><strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</strong></p></li></ul><h4 id="–-并发事务带来了哪些问题-☆"><a href="#–-并发事务带来了哪些问题-☆" class="headerlink" title="– 并发事务带来了哪些问题?☆"></a>– 并发事务带来了哪些问题?☆</h4><p>多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。</p><ul><li><p><strong>脏读（Dirty read）</strong></p><p>读未提交。一个事务读取数据并进行了修改，<strong>还未提交，其他事务就能读到</strong>，读到的就是脏数据。</p></li><li><p><strong>丢失修改（Lost to modify）</strong></p><p>一个事务读取一个数据时，另外一个事务也访问了该数据，那么在<strong>第一个事务修改了这个数据后，第二个事务也修改了这个数据。第一个事务内的修改结果就被丢失</strong>，因此称为丢失修改。</p></li><li><p><strong>不可重复读（Unrepeatable read）</strong></p><p>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于<strong>第二个事务的修改导致第一个事务两次读取的数据可能不太一样</strong>。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p></li><li><p><strong>幻读（Phantom read）</strong></p><p>一个事务读取了几行数据，接着<strong>另一个并发事务插入了一些数据</strong>时。在随后的查询中，<strong>第一个事务就会发现多了一些原本不存在的记录</strong>，就好像发生了幻觉一样，所以称为幻读。</p></li></ul><h4 id="–-不可重复读和幻读有什么区别？"><a href="#–-不可重复读和幻读有什么区别？" class="headerlink" title="– 不可重复读和幻读有什么区别？"></a>– 不可重复读和幻读有什么区别？</h4><p>幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。</p><ul><li><strong>不可重复读</strong>的重点是<strong>内容修改或者记录减少</strong>比如多次读取一条记录发现其中某些记录的值被修改；</li><li><strong>幻读</strong>的重点在于<strong>记录新增</strong>比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</li></ul><h4 id="–并发事务的控制方式有哪些？★"><a href="#–并发事务的控制方式有哪些？★" class="headerlink" title="–并发事务的控制方式有哪些？★"></a>–并发事务的控制方式有哪些？★</h4><p>两种：<strong>锁</strong> 和 <strong>MVCC</strong></p><ol><li><p><strong>锁</strong> 控制方式下会通过锁来<strong>显示控制共享资源</strong>而不是通过调度手段，MySQL 中主要是通过 <strong>读写锁</strong> 来实现并发控制。</p><ul><li><strong>共享锁（S 锁）</strong>：又称<strong>读锁</strong>，事务在读取记录的时候获取共享锁，<strong>允许多个事务同时获取</strong>（锁兼容）。</li><li><strong>排他锁（X 锁）</strong>：又称<strong>写锁&#x2F;独占锁</strong>，事务在修改记录的时候获取排他锁，<strong>不允许多个事务同时获取</strong>。如果一个记录已经被加了排他锁，那<strong>其他事务不能再对这条记录加任何类型的锁</strong>（锁不兼容）。</li><li>读写锁可以做到读读并行，但是无法做到写读、写写并行。另外，根据根据锁粒度的不同，又被分为 <strong>表级锁(table-level locking)</strong> 和 <strong>行级锁(row-level locking)</strong> 。</li><li>InnoDB 不光支持表级锁，还支持行级锁，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类。</li></ul></li><li><p><strong>MVCC</strong> 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。</p><p>[乐观锁和 MVCC 的区别？-CSDN博客](<a href="https://blog.csdn.net/dekejiao5921/article/details/102430442#:~:text=MVCC%EF%BC%88Multi-Version">https://blog.csdn.net/dekejiao5921/article/details/102430442#:~:text=MVCC（Multi-Version</a> Concurrent,Control），基于快照隔离机制 (Snapshot Isolations)进行多版本并发控制，是一种以乐观锁为理论基础的，用来解决读-写冲突的无锁并发控制。)</p><p>MVCC 在 MySQL 中实现所依赖的手段主要是: <strong>隐藏字段、read view、undo log</strong>。</p><ul><li>undo log : undo log 用于记录某行数据的多个版本的数据。</li><li>read view 和 隐藏字段 : 用来判断当前版本数据的可见性。</li></ul></li></ol><h4 id="–-SQL-标准定义了哪些事务隔离级别"><a href="#–-SQL-标准定义了哪些事务隔离级别" class="headerlink" title="– SQL 标准定义了哪些事务隔离级别?"></a>– SQL 标准定义了哪些事务隔离级别?</h4><ol><li><strong>READ-UNCOMMITTED(读取未提交)</strong> ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致<strong>脏读、幻读或不可重复读</strong>。</li><li><strong>READ-COMMITTED(读取已提交)</strong> ：允许读取并发事务已经提交的数据，可以<strong>阻止脏读</strong>，但是幻读或不可重复读仍有可能发生。</li><li><strong>REPEATABLE-READ(可重复读)</strong> ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以<strong>阻止脏读和不可重复读</strong>，但幻读仍有可能发生。</li><li><strong>SERIALIZABLE(可串行化)</strong> ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以<strong>防止脏读、不可重复读以及幻读</strong>。</li></ol><h4 id="–-MySQL-的隔离级别是基于锁实现的吗？"><a href="#–-MySQL-的隔离级别是基于锁实现的吗？" class="headerlink" title="– MySQL 的隔离级别是基于锁实现的吗？"></a>– MySQL 的隔离级别是基于锁实现的吗？</h4><p>MySQL 的隔离级别<strong>基于锁和 MVCC 机制共同实现</strong>的。</p><p>SERIALIZABLE 隔离级别是通过锁来实现的，READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于 MVCC 实现的。不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。</p><h4 id="–-MySQL-的默认隔离级别是什么"><a href="#–-MySQL-的默认隔离级别是什么" class="headerlink" title="– MySQL 的默认隔离级别是什么?"></a>– MySQL 的默认隔离级别是什么?</h4><p><strong>REPEATABLE-READ（可重读）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通过 SELECT @@tx_isolation; 命令来查看</span><br><span class="line"></span><br><span class="line">MySQL 8.0 该命令改为 SELECT @@transaction_isolation;</span><br></pre></td></tr></table></figure><h3 id="【MySQL-锁】"><a href="#【MySQL-锁】" class="headerlink" title="【MySQL 锁】"></a>【MySQL 锁】</h3><p><strong>锁</strong>是一种常见的<strong>并发事务的控制方式</strong>。</p><h4 id="–-表级锁和行级锁了解吗？有什么区别？"><a href="#–-表级锁和行级锁了解吗？有什么区别？" class="headerlink" title="– 表级锁和行级锁了解吗？有什么区别？"></a>– 表级锁和行级锁了解吗？有什么区别？</h4><ul><li><p><strong>MyISAM</strong> 仅仅支持表级锁(table-level locking)，一<strong>锁就锁整张表</strong>，这在并发写的情况下性非常差。</p><p><strong>InnoDB</strong> 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。</p></li><li><p>行级锁的<strong>粒度更小</strong>，仅<strong>对相关的记录上锁即可</strong>（对一行或者多行记录加锁），所以对于<strong>并发写入操作</strong>来说， InnoDB 的性能更高。</p></li><li><p><strong>表级锁和行级锁对比</strong>：</p><ul><li><p><strong>表级锁：</strong> MySQL 中<strong>锁定粒度最大</strong>的一种锁（全局锁除外），是针对<strong>非索引字段加的锁</strong>，对当前操作的<strong>整张表加锁</strong>，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。</p></li><li><p><strong>行级锁：</strong> MySQL 中锁<strong>定粒度最小</strong>的一种锁，是 <strong>针对索引字段加的锁</strong> ，只针对当前操作的行记录进行加锁。 行级锁能大大<strong>减少数据库操作的冲突</strong>。其加锁粒度最小，<strong>并发度高</strong>，但<strong>加锁的开销也最大，加锁慢，会出现死锁</strong>。行级锁和存储引擎有关，是在存储引擎层面实现的。</p></li></ul></li></ul><h4 id="–-行级锁的使用有什么注意事项？？"><a href="#–-行级锁的使用有什么注意事项？？" class="headerlink" title="– 行级锁的使用有什么注意事项？？"></a>– 行级锁的使用有什么注意事项？？</h4><p>当我们执行 <code>UPDATE</code>、<code>DELETE</code> 语句时，如果 <code>WHERE</code>条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。</p><p>不过，很多时候即使用了索引也有可能会走全表扫描，这是因为 MySQL 优化器的原因。</p><h4 id="–-InnoDB-有哪几类行锁？"><a href="#–-InnoDB-有哪几类行锁？" class="headerlink" title="– InnoDB 有哪几类行锁？"></a>– InnoDB 有哪几类行锁？</h4><p>InnoDB <strong>行锁</strong>是<strong>通过对索引数据页上的记录加锁实现</strong>的，MySQL InnoDB 支持三种行锁定方式：</p><p><strong>记录锁（Record Lock）</strong>：也被称为记录锁，属于<strong>单个行记录</strong>上的锁。</p><p><strong>间隙锁（Gap Lock）</strong>：锁定一个<strong>范围</strong>，不包括记录本身。</p><p><strong>临键锁（Next-Key Lock）</strong>：Record Lock+Gap Lock，<strong>锁定一个范围，包含记录本</strong>身，主要目的是<strong>为了解决幻读</strong>问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</p><p><strong>在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。</strong></p><h4 id="–-共享锁和排他锁呢？"><a href="#–-共享锁和排他锁呢？" class="headerlink" title="– 共享锁和排他锁呢？"></a>– 共享锁和排他锁呢？</h4><p>不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：</p><ul><li><strong>共享锁（S 锁）</strong>：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li><li><strong>排他锁（X 锁）</strong>：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。</li></ul><h4 id="–-意向锁有什么作用？"><a href="#–-意向锁有什么作用？" class="headerlink" title="– 意向锁有什么作用？"></a>– 意向锁有什么作用？</h4><p>需要用到表锁的时，判断表中的记录有没有行锁。</p><p>意向锁，<strong>快速判断是否可以对某个表使用表锁</strong>。</p><ul><li><strong>意向共享锁（Intention Shared Lock，IS 锁）</strong>：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。</li><li><strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。</li></ul><p>意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享&#x2F;排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。</p><ul><li>意向锁之间是互相兼容的。</li><li>意向锁和共享锁和排它锁互斥（这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥）。</li></ul><h4 id="–-当前读和快照读有什么区别？"><a href="#–-当前读和快照读有什么区别？" class="headerlink" title="– 当前读和快照读有什么区别？"></a>– 当前读和快照读有什么区别？</h4><ul><li><p><strong>快照读</strong>（一致性非锁定读）就是单纯的 <code>SELECT</code> 语句。</p><p>快照即记录的历史版本，每行记录可能存在多个历史版本（多版本技术）。</p></li><li><p><strong>当前读</strong> （一致性锁定读）就是给行记录加 X 锁或 S 锁。</p></li></ul><h4 id="–-自增锁有了解吗？"><a href="#–-自增锁有了解吗？" class="headerlink" title="– 自增锁有了解吗？"></a>– 自增锁有了解吗？</h4><p>InnoDB 中的自增主键会涉及一种比较特殊的表级锁— <strong>自增锁（AUTO-INC Locks）</strong> 。</p><p>更准确点来说，不仅仅是自增主键，<code>AUTO_INCREMENT</code>的列都会涉及到自增锁，毕竟非主键也可以设置自增长。</p><h3 id="【MySQL-性能优化】"><a href="#【MySQL-性能优化】" class="headerlink" title="【MySQL 性能优化】"></a>【MySQL 性能优化】</h3><h4 id="–-能用-MySQL-直接存储文件（比如图片）吗？"><a href="#–-能用-MySQL-直接存储文件（比如图片）吗？" class="headerlink" title="– 能用 MySQL 直接存储文件（比如图片）吗？"></a>– 能用 MySQL 直接存储文件（比如图片）吗？</h4><p>可以但不建议。会严重影响数据库性能，消耗过多存储空间。</p><p>可以选择使用云服务厂商提供的开箱即用的文件存储服务。MinIO（推荐）</p><p><strong>数据库只存储文件地址信息，文件由文件存储服务负责存储。</strong></p><h4 id="–-MySQL-如何存储-IP-地址？"><a href="#–-MySQL-如何存储-IP-地址？" class="headerlink" title="– MySQL 如何存储 IP 地址？"></a>– MySQL 如何存储 IP 地址？</h4><p>可以将 <strong>IP 地址转换成整形数据存储</strong>，<strong>性能更好，占用空间也更小</strong>。</p><p>MySQL 提供了两个方法来处理 ip 地址</p><ul><li><code>INET_ATON()</code>：把 ip 转为无符号整型 (4-8 位)</li><li><code>INET_NTOA()</code> :把整型的 ip 转为地址</li></ul><p>插入数据前，先用 <code>INET_ATON()</code> 把 ip 地址转为整型，显示数据时，使用 <code>INET_NTOA()</code> 把整型的 ip 地址转为地址显示即可</p><h4 id="–-有哪些常见的-SQL-优化手段？★"><a href="#–-有哪些常见的-SQL-优化手段？★" class="headerlink" title="– 有哪些常见的 SQL 优化手段？★"></a>– 有哪些常见的 SQL 优化手段？★</h4><h4 id="–-如何分析-SQL-的性能？☆"><a href="#–-如何分析-SQL-的性能？☆" class="headerlink" title="– 如何分析 SQL 的性能？☆"></a>– 如何分析 SQL 的性能？☆</h4><p>使用 <code>EXPLAIN</code> 命令来分析 SQL 的 <strong>执行计划</strong> 。执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化会后，具体的执行方式。</p><p><code>EXPLAIN</code> 并不会真的去执行相关的语句，而是通过 <strong>查询优化器</strong> 对语句进行分析，找出最优的查询方案，并显示对应的信息。</p><p><code>EXPLAIN</code> 适用于 <code>SELECT</code>, <code>DELETE</code>, <code>INSERT</code>, <code>REPLACE</code>, 和 <code>UPDATE</code>语句，我们一般分析 <code>SELECT</code> 查询较多。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT `score`,`name` FROM `cus_order` ORDER BY `score` DESC;</span><br><span class="line">+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+</span><br><span class="line">| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra          |</span><br><span class="line">+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+</span><br><span class="line">|  1 | SIMPLE      | cus_order | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 997572 |   100.00 | Using filesort |</span><br><span class="line">+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="–-读写分离和分库分表了解吗？"><a href="#–-读写分离和分库分表了解吗？" class="headerlink" title="– 读写分离和分库分表了解吗？"></a>– 读写分离和分库分表了解吗？</h4><h4 id="–-深度分页如何优化？"><a href="#–-深度分页如何优化？" class="headerlink" title="– 深度分页如何优化？"></a>– 深度分页如何优化？</h4><h4 id="–-数据冷热分离如何做？"><a href="#–-数据冷热分离如何做？" class="headerlink" title="– 数据冷热分离如何做？"></a>– 数据冷热分离如何做？</h4><h4 id="–-常见的数据库优化方法有哪些？★"><a href="#–-常见的数据库优化方法有哪些？★" class="headerlink" title="– 常见的数据库优化方法有哪些？★"></a>– 常见的数据库优化方法有哪些？★</h4><ul><li><a href="https://javaguide.cn/database/mysql/mysql-index.html">索引优化</a></li><li><a href="https://javaguide.cn/high-performance/read-and-write-separation-and-library-subtable.html">读写分离和分库分表</a></li><li><a href="https://javaguide.cn/high-performance/data-cold-hot-separation.html">数据冷热分离</a></li><li><a href="https://javaguide.cn/high-performance/sql-optimization.html">SQL 优化</a></li><li><a href="https://javaguide.cn/high-performance/deep-pagination-optimization.html">深度分页优化</a></li><li>适当冗余数据</li><li>使用更高的硬件配置</li></ul><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;持续补充…&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://sunrisel135.github.io/blog_lyl/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="面试" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>字符集</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/13/%E5%AD%97%E7%AC%A6%E9%9B%86/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/13/%E5%AD%97%E7%AC%A6%E9%9B%86/</id>
    <published>2024-03-13T01:56:47.000Z</published>
    <updated>2024-03-13T02:07:00.008Z</updated>
    
    <content type="html"><![CDATA[<p>详解请查看全文…</p><span id="more"></span><h4 id="字符集是什么？"><a href="#字符集是什么？" class="headerlink" title="字符集是什么？"></a>字符集是什么？</h4><p><strong>字符</strong>是各种文字和符号的统称，包括各个国家文字、标点符号、表情、数字等等。</p><p> <strong>字符集</strong> 就是一系列字符的集合。</p><h4 id="计算机只能存储二进制的数据，那英文、汉字、表情等字符应该如何存储呢？"><a href="#计算机只能存储二进制的数据，那英文、汉字、表情等字符应该如何存储呢？" class="headerlink" title="计算机只能存储二进制的数据，那英文、汉字、表情等字符应该如何存储呢？"></a>计算机只能存储二进制的数据，那英文、汉字、表情等字符应该如何存储呢？</h4><p>将这些字符和二进制的数据一一对应起来。</p><h5 id="字符编码、字符解码"><a href="#字符编码、字符解码" class="headerlink" title="字符编码、字符解码"></a>字符编码、字符解码</h5><p>将字符对应二进制数据的过程称为”<strong>字符编码</strong>“，反之，二进制数据解析成字符的过程称为“<strong>字符解码</strong>”。</p><h4 id="字符编码是什么？"><a href="#字符编码是什么？" class="headerlink" title="字符编码是什么？"></a>字符编码是什么？</h4><p>字符编码是一种将字符集中的<strong>字符与计算机中的二进制数据相互转换的方法</strong>，可以看作是一种映射规则。也就是说，字符编码的目的是为了让计算机能够存储和传输各种文字信息。</p><p>每种字符集都有自己的字符编码规则，常用的字符集编码规则有 ASCII 编码、 GB2312 编码、GBK 编码、GB18030 编码、Big5 编码、UTF-8 编码、UTF-16 编码等。</p><h4 id="有哪些常见的字符集？"><a href="#有哪些常见的字符集？" class="headerlink" title="有哪些常见的字符集？"></a>有哪些常见的字符集？</h4><p>不同的字符集的主要区别在于：</p><ul><li>可以表示的字符范围</li><li>编码方式</li></ul><h5 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h5><p>是一套主要用于现代美国英语的字符集（这也是 ASCII 字符集的局限性所在）。</p><h5 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h5><p>很多国家都捣鼓了一个适合自己国家语言的字符集。</p><h5 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h5><p>GBK 字符集可以看作是 GB2312 字符集的扩展，兼容 GB2312 字符集，共收录了 20000 多个汉字。</p><p>GBK 中 K 是汉语拼音 Kuo Zhan（扩展）中的“Kuo”的首字母。</p><h5 id="GB18030"><a href="#GB18030" class="headerlink" title="GB18030"></a>GB18030</h5><p>完全兼容 GB2312 和 GBK 字符集，纳入中国国内少数民族的文字，且收录了日韩汉字，是目前为止最全面的汉字字符集，共收录汉字 70000 多个。</p><h5 id="BIG5"><a href="#BIG5" class="headerlink" title="BIG5"></a>BIG5</h5><p>主要针对的是繁体中文，收录了 13000 多个汉字。</p><h5 id="Unicode-UTF-8"><a href="#Unicode-UTF-8" class="headerlink" title="Unicode &amp; UTF-8"></a>Unicode &amp; UTF-8</h5><p>了不同的字符集可以表示的字符范围以及编码规则存在差异。这就导致了一个非常严重的问题：<strong>使用错误的编码方式查看一个包含字符的文件就会产生乱码现象。</strong></p><p>乱码的本质：<strong>编码和解码时用了不同或者不兼容的字符集</strong> 。</p><p><strong>Unicode 字符集</strong>中包含了世界上几乎所有已知的字符。不过，Unicode 字符集并没有规定如何存储这些字符（也就是如何使用二进制数据表示这些字符）。</p><p>然后，就有了 <strong>UTF-8</strong>（<strong>8</strong>-bit <strong>U</strong>nicode <strong>T</strong>ransformation <strong>F</strong>ormat）。类似的还有 UTF-16、 UTF-32。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;详解请查看全文…&lt;/p&gt;</summary>
    
    
    
    <category term="字符集详解" scheme="https://sunrisel135.github.io/blog_lyl/categories/%E5%AD%97%E7%AC%A6%E9%9B%86%E8%AF%A6%E8%A7%A3/"/>
    
    
    <category term="知识点" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Java面试-JVM</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/12/Java%E9%9D%A2%E8%AF%95-JVM/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/12/Java%E9%9D%A2%E8%AF%95-JVM/</id>
    <published>2024-03-12T01:26:50.000Z</published>
    <updated>2024-03-12T08:12:42.286Z</updated>
    
    <content type="html"><![CDATA[<p>持续更新…</p><span id="more"></span><h2 id="JVM的组织架构"><a href="#JVM的组织架构" class="headerlink" title="JVM的组织架构"></a>JVM的组织架构</h2><p>大致划分为三个部分：<strong>类加载器</strong>、<strong>运行时数据区</strong>和<strong>执行引擎</strong>。</p><ol><li><p><strong>类加载器</strong></p><p>负责从文件系统、网络或其他来源加载 Class 文件，<strong>将 Class 文件中的二进制数据读入到内存当中</strong>。</p></li><li><p><strong>运行时数据区</strong></p><p>JVM 在执行 Java 程序时，需要在内存中分配空间来处理各种数据，这些内存区域主要包括<strong>方法区</strong>、<strong>堆</strong>、<strong>栈</strong>、<strong>程序计数器</strong>和<strong>本地方法栈</strong>。</p></li><li><p><strong>执行引擎</strong></p><p>负责<strong>执行字节码</strong>。它包括一个<strong>虚拟处理器</strong>，还包括<strong>即时编译器</strong>（<strong>JIT</strong> Compiler）和<strong>垃圾回收器</strong>（Garbage Collector）。</p></li></ol><img src="C:\Users\lyl\Desktop\总结复习\JVM组织架构.png" style="zoom: 67%;" /><h2 id="Java内存区域详解（重点）"><a href="#Java内存区域详解（重点）" class="headerlink" title="Java内存区域详解（重点）"></a>Java内存区域详解（重点）</h2><p>常见面试题：</p><ul><li>介绍下 Java 内存区域（运行时数据区）</li><li>Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）</li><li>对象的访问定位的两种方式（句柄和直接指针两种方式）</li></ul><h3 id="【运行时数据区域】"><a href="#【运行时数据区域】" class="headerlink" title="【运行时数据区域】"></a>【运行时数据区域】</h3><p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。</p><h4 id="运行时数据区域（JDK1-7）"><a href="#运行时数据区域（JDK1-7）" class="headerlink" title="运行时数据区域（JDK1.7）:"></a><strong>运行时数据区域（JDK1.7）:</strong></h4><ol><li><strong>线程共享</strong>：<strong>堆</strong>(Heep) {<strong>字符串常量池</strong>(String Constant Pool)} + <strong>方法区</strong>(Method Area) {<strong>运行时常量池</strong>(Runtime Constant Pool)}</li><li><strong>线程私有</strong>：线程(Thread)1 {<strong>虚拟机栈</strong>(VM Stack) + <strong>本地方法栈</strong>(Native Method Stack) + <strong>程序计数器</strong>(Program Counter Register)}</li><li><strong>本地内存</strong>{ <strong>直接内存</strong>(Direct Memory ) }</li></ol><h4 id="运行时数据区域（JDK1-8）"><a href="#运行时数据区域（JDK1-8）" class="headerlink" title="运行时数据区域（JDK1.8）:"></a><strong>运行时数据区域（JDK1.8）:</strong></h4><ol><li><p><strong>线程共享</strong>：<strong>堆</strong> {<strong>字符串常量池</strong> }</p></li><li><p><strong>线程私有</strong>：线程1 {<strong>虚拟机栈</strong> + <strong>本地方法栈</strong> + <strong>程序计数器</strong> }</p></li><li><p><strong>本地内存</strong> { <strong>元空间</strong>(MetaSpace) { <strong>运行时常量池</strong> } +  <strong>直接内存</strong> }</p></li></ol><p><strong>线程私有的：</strong></p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p><strong>线程共享的：</strong></p><ul><li>堆</li><li>方法区</li><li>直接内存 (非运行时数据区的一部分)</li></ul><h4 id="–-能说一下-JVM-的内存区域吗？"><a href="#–-能说一下-JVM-的内存区域吗？" class="headerlink" title="– 能说一下 JVM 的内存区域吗？"></a>– 能说一下 JVM 的内存区域吗？</h4><p>JVM 内存分为线程私有区和线程共享区，其中<code>方法区</code>和<code>堆</code>是线程共享区，<code>虚拟机栈</code>、<code>本地方法栈</code>和<code>程序计数器</code>是线程隔离的数据区。</p><h4 id="–-程序计数器"><a href="#–-程序计数器" class="headerlink" title="– 程序计数器"></a>– 程序计数器</h4><p>是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。</p><ul><li><strong>字节码解释器</strong>通过改变程序计数器来依次读取指令，从而<strong>实现代码的流程控制</strong>，如：顺序执行、选择、循环、异常处理。</li><li>在<strong>多线程</strong>的情况下，程序计数器用于<strong>记录当前线程执行的位置</strong>，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ul><p>⚠️ 注意：程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的<strong>生命周期随着线程</strong>的创建而创建，随着线程的结束而死亡。</p><h4 id="–-Java虚拟机栈"><a href="#–-Java虚拟机栈" class="headerlink" title="– Java虚拟机栈"></a>– Java虚拟机栈</h4><p>除了一些 <strong>Native 方法</strong>调用是通过<strong>本地方法栈</strong>实现的(后面会提到)，<strong>其他所有的 Java 方法调用</strong>都是通过<strong>栈</strong>来实现的（也需要和其他运行时数据区域比如程序计数器<strong>配合</strong>）。</p><ul><li>方法调用的数据需要通过栈进行传递，每一次<strong>方法</strong>调用都会有一个对应的<strong>栈帧</strong>被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。</li><li>栈由一个个栈帧组成，而每个<strong>栈帧</strong>中都拥有：<strong>局部变量表、操作数栈、动态链接、方法返回地址</strong>。<strong>先进后出</strong>的数据结构，只支持出栈和入栈两种操作。</li><li>生命周期和线程相同。</li><li><strong>栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。</strong></li></ul><p><strong>局部变量表</strong> ：主要存放<strong>编译期可知的</strong>各种<strong>基本数据类型</strong>、<strong>对象引用</strong>（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p><p><strong>操作数栈</strong> ：主要作为<strong>方法调用的中转站</strong>，用于<strong>存放方法执行过程中产生的中间计算结果</strong>。另外，计算过程中产生的临时变量也会放在操作数栈中。</p><p><strong>动态链接</strong>：主要<strong>服务一个方法需要调用其他方法的场景</strong>。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的<strong>作用就是为了将符号引用转换为调用方法的直接引用</strong>，这个过程也被称为 <strong>动态连接</strong> 。</p><h4 id="–-本地方法栈"><a href="#–-本地方法栈" class="headerlink" title="– 本地方法栈"></a>– 本地方法栈</h4><p><strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong>在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p><ul><li>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</li></ul><h4 id="–-堆"><a href="#–-堆" class="headerlink" title="– 堆"></a>– 堆</h4><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有<strong>线程共享</strong>的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p><ul><li><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。</p></li><li><p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p><ol><li>新生代内存(Young Generation)</li><li>老生代(Old Generation)</li><li>永久代(Permanent Generation</li></ol></li><li><p><strong>JDK 8 版本之后 PermGen(永久代) 已被 Metaspace(元空间) 取代，元空间使用的是本地内存。</strong></p></li></ul><h4 id="–-方法区"><a href="#–-方法区" class="headerlink" title="– 方法区"></a>– 方法区</h4><p>当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</p><ul><li><p>方法区属于是 JVM 运行时数据区域的一块<strong>逻辑区域</strong>，是<strong>各个线程共享</strong>的内存区域。</p></li><li><p><strong>永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式</strong>。并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。</p><p>方法区（<strong>抽象概念&#x2F;规范</strong>） -&gt; 元空间（<strong>具体实现</strong>）</p><p>​ -&gt; 永久代（具体实现）</p></li></ul><p><strong>为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</strong></p><ul><li>整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</li></ul><h4 id="–-运行时常量池"><a href="#–-运行时常量池" class="headerlink" title="– 运行时常量池"></a>– 运行时常量池</h4><p>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于<strong>存放编译期生成的</strong>各种<strong>字面量</strong>（Literal）和<strong>符号引用</strong>（Symbolic Reference）的 <strong>常量池表(Constant Pool Table)</strong> 。</p><ul><li><strong>字面量</strong>是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量。</li><li>常见的<strong>符号引用</strong>包括类符号引用、字段符号引用、方法符号引用、接口方法符号。</li></ul><h4 id="–-字符串常量池"><a href="#–-字符串常量池" class="headerlink" title="– 字符串常量池"></a>– 字符串常量池</h4><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗<strong>针对字符串</strong>（String 类）专门开辟的一块区域，主要目的是为了<strong>避免字符串的重复创建</strong>。</p><ul><li>JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。</li></ul><p><strong>JDK 1.7 为什么要将字符串常量池移动到堆中？</strong></p><p>因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运行时常量池、方法区、字符串常量池这些都是不随虚拟机实现而改变的逻辑概念，是公共且抽象的，元空间(Metaspace)、堆(Heap) 是与具体某种虚拟机实现相关的物理概念，是私有且具体的。</span><br></pre></td></tr></table></figure><h4 id="–-直接内存"><a href="#–-直接内存" class="headerlink" title="– 直接内存"></a>– 直接内存</h4><p>直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。</p><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 <code>OutOfMemoryError</code> 错误出现。</p><p><strong>NIO（Non-Blocking I&#x2F;O，也被称为 New I&#x2F;O）</strong>，引入了一种基于**通道（Channel）与缓存区（Buffer）的 I&#x2F;O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为**避免了在 Java 堆和 Native 堆之间来回复制数据**。</p><h3 id="【HotSpot-虚拟机对象探秘】"><a href="#【HotSpot-虚拟机对象探秘】" class="headerlink" title="【HotSpot 虚拟机对象探秘】"></a>【HotSpot 虚拟机对象探秘】</h3><h4 id="–-对象的创建过程"><a href="#–-对象的创建过程" class="headerlink" title="– 对象的创建过程"></a>– 对象的创建过程</h4><ol><li><strong>类加载检查</strong><ul><li>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</li></ul></li><li><strong>分配内存</strong><ul><li><strong>类加载检查</strong>通过后，虚拟机将为新生对象<strong>分配内存</strong>。</li><li><strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</li></ul></li><li><strong>初始化零值</strong><ul><li>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li></ul></li><li><strong>设置对象头</strong><ul><li><strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li></ul></li><li><strong>执行 init 方法</strong><ul><li>从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行<strong>初始化</strong>，这样一个真正可用的对象才算完全产生出来。</li></ul></li></ol><h4 id="–-对象在内存中的布局"><a href="#–-对象在内存中的布局" class="headerlink" title="– 对象在内存中的布局"></a>– 对象在内存中的布局</h4><p> Hotspot 虚拟机中，对象在内存中的布局：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><ul><li><strong>对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li><li><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</li><li><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong></li></ul><h4 id="–-对象的访问定位"><a href="#–-对象的访问定位" class="headerlink" title="– 对象的访问定位"></a>– 对象的访问定位</h4><p> Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：<strong>使用句柄</strong>、<strong>直接指针</strong>。</p><ul><li><strong>句柄</strong>： Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。</li><li><strong>直接指针</strong>：reference 中存储的直接就是对象的地址。</li></ul><h2 id="JVM垃圾回收详解（重点）"><a href="#JVM垃圾回收详解（重点）" class="headerlink" title="JVM垃圾回收详解（重点）"></a>JVM垃圾回收详解（重点）</h2><p>常见面试题：</p><ul><li>如何判断对象是否死亡（两种方法）。</li><li>简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。</li><li>如何判断一个常量是废弃常量</li><li>如何判断一个类是无用的类</li><li>垃圾收集有哪些算法，各自的特点？</li><li>HotSpot 为什么要分为新生代和老年代？</li><li>常见的垃圾回收器有哪些？</li><li>介绍一下 CMS,G1 收集器。</li><li>Minor Gc 和 Full GC 有什么不同呢？</li></ul><h3 id="【堆空间的基本结构】"><a href="#【堆空间的基本结构】" class="headerlink" title="【堆空间的基本结构】"></a>【堆空间的基本结构】</h3><h3 id="【JVM-的垃圾回收机制】"><a href="#【JVM-的垃圾回收机制】" class="headerlink" title="【JVM 的垃圾回收机制】"></a>【JVM 的垃圾回收机制】</h3><p>垃圾回收（Garbage Collection，GC），顾名思义就是释放垃圾占用的空间，防止内存爆掉。有效的使用可以使用的内存，<strong>对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收</strong>。</p><h4 id="–-JVM-在垃圾回收之前，判断谁是垃圾，即垃圾判断算法"><a href="#–-JVM-在垃圾回收之前，判断谁是垃圾，即垃圾判断算法" class="headerlink" title="– JVM 在垃圾回收之前，判断谁是垃圾，即垃圾判断算法"></a>– JVM 在垃圾回收之前，判断谁是垃圾，即垃圾判断算法</h4><p>通常有引用技术算法、可达性分析算法。</p><ul><li><strong>引用计数算法</strong>是通过在对象头中分配一个空间来保存该<strong>对象被引用的次数</strong>。</li><li><strong>可达性分析算法</strong>的基本思路是，通过一些被称为引用链（GC Roots）的对象作为起点，然后向下搜索，搜索走过的路径被称为（Reference Chain），当<strong>一个对象到 GC Roots 之间没有任何引用相连时</strong>，即从 GC Roots 到该对象节点不可达，则证明该对象是需要垃圾收集的。</li></ul><h4 id="–-确定了哪些垃圾可以被回收后，垃圾收集器如何高效地进行垃圾回收呢？？"><a href="#–-确定了哪些垃圾可以被回收后，垃圾收集器如何高效地进行垃圾回收呢？？" class="headerlink" title="– 确定了哪些垃圾可以被回收后，垃圾收集器如何高效地进行垃圾回收呢？？"></a>– 确定了哪些垃圾可以被回收后，垃圾收集器如何高效地进行垃圾回收呢？？</h4><ul><li><strong>标记清除算法</strong>，分为 2 部分，先把内存区域中的这些对象进行标记，哪些属于可回收的标记出来，然后把这些垃圾拎出来清理掉。</li><li><strong>复制算法</strong>，在标记清除算法上演化而来的，用于解决标记清除算法的内存碎片问题。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。</li><li><strong>标记整理算法</strong>，标记过程仍然与标记清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，再清理掉端边界以外的内存区域。</li><li><strong>分代收集算法</strong>，在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用<strong>复制算法</strong>，只需要付出少量存活对象的复制成本就可以完成收集。老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用<strong>标记清理或者标记整理算法</strong>来进行回收。</li></ul><h4 id="–-垃圾回收器"><a href="#–-垃圾回收器" class="headerlink" title="– 垃圾回收器"></a>– 垃圾回收器</h4><p>JVM 提供了多种垃圾回收器，不同的垃圾回收器适用于不同的场景和需求，包括 <code>CMS GC、G1 GC、ZGC</code> 等。</p><ol><li><strong>CMS</strong> 是第一个关注 GC 停顿时间（STW 的时间）的垃圾收集器，JDK 1.5 时引入，JDK9 被标记弃用，JDK14 被移除。</li><li><strong>G1</strong>（Garbage-First Garbage Collector）在 JDK 1.7 时引入，在 <strong>JDK 9</strong> 时取代 CMS 成为了<strong>默认</strong>的垃圾收集器。</li><li><strong>ZGC</strong> 是 JDK11 推出的一款低延迟垃圾收集器，适用于<strong>大内存低延迟</strong>服务的内存管理和回收，SPEC jbb 2015 基准测试，在 128G 的大堆下，最大停顿时间才 1.68 ms，停顿时间远胜于 G1 和 CMS。</li></ol><h2 id="类加载过程详解"><a href="#类加载过程详解" class="headerlink" title="类加载过程详解"></a>类加载过程详解</h2><h3 id="【类的生命周期】"><a href="#【类的生命周期】" class="headerlink" title="【类的生命周期】"></a>【类的生命周期】</h3><p>7 个阶段：</p><ol><li>加载（Loading）</li><li>验证（Verification）</li><li>准备（Preparation）</li><li>解析（Resolution）</li><li>初始化（Initialization）</li><li>使用（Using）</li><li>卸载（Unloading）</li></ol><p>其中，验证、准备和解析这三个阶段可以统称为连接（Linking）。</p><h3 id="【类加载过程】"><a href="#【类加载过程】" class="headerlink" title="【类加载过程】"></a>【类加载过程】</h3><p><strong>Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？</strong></p><p>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;持续更新…&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://sunrisel135.github.io/blog_lyl/categories/JVM/"/>
    
    
    <category term="面试" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java面试-IO</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/10/Java%E9%9D%A2%E8%AF%95-IO/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/10/Java%E9%9D%A2%E8%AF%95-IO/</id>
    <published>2024-03-10T01:42:29.000Z</published>
    <updated>2024-03-10T01:43:38.106Z</updated>
    
    <content type="html"><![CDATA[<p>持续补充！</p><span id="more"></span><h3 id="【Java-IO基础】"><a href="#【Java-IO基础】" class="headerlink" title="【Java IO基础】"></a>【Java IO基础】</h3><h4 id="–-IO流"><a href="#–-IO流" class="headerlink" title="– IO流"></a>– IO流</h4><p>即 <code>Input/Output</code>，输入和输出。</p><ul><li>输入-数据输入到计算机内存的过程。</li><li>输出-输出到外部存储（比如数据库，文件，远程主机）的过程。</li></ul><p>可分为：</p><ul><li>输入流和输出流 </li><li>字节流和字符流 (根据数据的处理方式)</li></ul><p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li><code>InputStream</code> (字节输入流) &#x2F; <code>Reader</code> (字符输入流) : 所有输入流的基类</li><li><code>OutputStream</code> (字节输出流) &#x2F; <code>Writer</code> (字符输出流) : 所有输出流的基类。</li></ul><h4 id="–-字节流"><a href="#–-字节流" class="headerlink" title="– 字节流"></a>– 字节流</h4><h5 id="InputStream（字节输入流）"><a href="#InputStream（字节输入流）" class="headerlink" title="InputStream（字节输入流）"></a>InputStream（字节输入流）</h5><ol><li><p><code>InputStream</code>用于从源头 (通常是文件) 读取数据 (字节信息) 到内存中，<code>java.io.InputStream</code>抽象类是所有字节输入流的父类。</p></li><li><p><code>FileInputStream</code> 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。</p><p>不过，一般我们是不会直接单独使用 FileInputStream ，通常会配合 <code>BufferedInputStream</code>（字节缓冲输入流）来使用。</p></li><li><p><code>DataInputStream</code> 用于读取指定类型数据，不能单独使用，必须结合其它流，比如 <code>FileInputStream</code> 。</p></li><li><p><code>ObjectInputStream</code> 用于从输入流中读取 Java 对象（<strong>反序列化</strong>），<code>ObjectOutputStream</code> 用于将对象写入到输出流(<strong>序列化</strong>)。</p><p>用于序列化和反序列化的类必须实现 <code>Serializable</code> 接口，对象中如果有属性不想被序列化，使用 <code>transient</code> 修饰。</p></li></ol><h5 id="OutputStream（字节输出流）"><a href="#OutputStream（字节输出流）" class="headerlink" title="OutputStream（字节输出流）"></a>OutputStream（字节输出流）</h5><ol><li><code>OutputStream</code>用于将数据 (字节信息) 写入到目的地 (通常是文件)，<code>java.io.OutputStream</code>抽象类是所有字节输出流的父类。</li><li><code>FileOutputStream</code> 是最常用的字节输出流对象，可直接指定文件路径，可以直接输出单字节数据，也可以输出指定的字节数组。</li><li><code>DataOutputStream</code> 用于写入指定类型数据，不能单独使用，必须结合其它流，比如 <code>FileOutputStream</code> 。</li><li><code>ObjectOutputStream</code>，将对象写入到输出流(序列化)。</li></ol><h4 id="–-字符流"><a href="#–-字符流" class="headerlink" title="– 字符流"></a>– 字符流</h4><ul><li>不管是文件读写还是网络发送接收，信息的<strong>最小存储单元</strong>都是<strong>字节</strong>。</li></ul><h5 id="那为什么-I-O-流操作要分为字节流操作和字符流操作呢？"><a href="#那为什么-I-O-流操作要分为字节流操作和字符流操作呢？" class="headerlink" title="那为什么 I&#x2F;O 流操作要分为字节流操作和字符流操作呢？"></a>那为什么 I&#x2F;O 流操作要分为字节流操作和字符流操作呢？</h5><ul><li>字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时。</li><li>使用字节流时，如果我们<strong>不知道编码类型</strong>就<strong>很容易出现乱码问题</strong>。（中文）</li><li>因此，I&#x2F;O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。</li><li>如果<strong>音频文件、图片</strong>等<strong>媒体文件</strong>用<strong>字节流</strong>比较好，如果涉及到<strong>字符</strong>的话使用<strong>字符流</strong>比较好。</li></ul><h5 id="Reader（字符输入流）"><a href="#Reader（字符输入流）" class="headerlink" title="Reader（字符输入流）"></a>Reader（字符输入流）</h5><ol><li><p><code>Reader</code>用于从源头（通常是文件）读取数据（字符信息）到内存中，<code>java.io.Reader</code>抽象类是所有字符输入流的父类。</p><p><code>Reader</code> 用于读取文本， <code>InputStream</code> 用于读取原始字节。</p></li><li><p><strong>InputStreamReader</strong> 是字节流转换为字符流的<strong>桥梁</strong>，其<strong>子类</strong> <code>FileReader</code> 是基于该基础上的封装，可以直接操作字符文件。</p></li></ol><h5 id="Writer（字符输出流）"><a href="#Writer（字符输出流）" class="headerlink" title="Writer（字符输出流）"></a>Writer（字符输出流）</h5><ol><li><code>Writer</code>用于将数据（字符信息）写入到目的地（通常是文件），<code>java.io.Writer</code>抽象类是所有字符输出流的父类。</li><li><code>OutputStreamWriter</code> 是字符流转换为字节流的桥梁，其子类 <code>FileWriter</code> 是基于该基础上的封装，可以直接将字符写入到文件。</li></ol><h4 id="–-缓冲流"><a href="#–-缓冲流" class="headerlink" title="– 缓冲流"></a>– 缓冲流</h4><ul><li>IO 操作是很消耗<strong>性能</strong>的，缓冲流将数据加载至缓冲区，<strong>一次性读取&#x2F;写入多个字节</strong>，从而避免频繁的 IO 操作，提高流的<strong>传输效率</strong>。</li><li>字节缓冲流这里采用了<strong>装饰器模式</strong>来<strong>增强 <code>InputStream</code> 和<code>OutputStream</code>子类对象</strong>的功能。</li><li>字节流和字节缓冲流的性能差别主要体现在我们使用两者的时候都是调用 write(int b) 和 read() 这两个一次只读取一个字节的方法的时候。由于字节缓冲流内部有缓冲区（字节数组），因此，字节缓冲流会先将读取到的字节存放在缓存区，大幅减少 IO 次数，提高读取效率。</li></ul><h5 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h5><ol><li><p><strong>BufferedInputStream（字节缓冲输入流）</strong></p><ul><li><p><code>BufferedInputStream</code> 从源头（通常是文件）读取数据（字节信息）到内存的过程中不会一个字节一个字节的读取，而是会<strong>先将读取到的字节存放在缓存区，并从内部缓冲区中单独读取字节</strong>。这样大幅减少了 IO 次数，提高了读取效率。</p></li><li><p><code>BufferedInputStream</code> 内部维护了一个<strong>缓冲区</strong>，这个缓冲区实际就是一个<strong>字节数组</strong>。</p></li></ul></li><li><p><strong>BufferedOutputStream（字节缓冲输出流）</strong></p><ul><li><code>BufferedOutputStream</code> 将数据（字节信息）写入到目的地（通常是文件）的过程中不会一个字节一个字节的写入，而是会先将要写入的字节存放在缓存区，并从内部缓冲区中单独写入字节。这样大幅减少了 IO 次数，提高了读取效率</li></ul></li></ol><h5 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h5><p><code>BufferedReader</code> （<strong>字符缓冲输入流</strong>）和 <code>BufferedWriter</code>（<strong>字符缓冲输出流</strong>）类似于 <code>BufferedInputStream</code>（字节缓冲输入流）和<code>BufferedOutputStream</code>（字节缓冲输入流），内部都维护了一个字节数组作为缓冲区。不过，前者主要是用来操作字符信息。</p><h4 id="–-打印流"><a href="#–-打印流" class="headerlink" title="– 打印流"></a>– 打印流</h4><ul><li><code>System.out</code> 实际是用于获取一个 PrintStream 对象，print方法实际调用的是 PrintStream 对象的 write 方法。</li><li><code>PrintStream</code> 属于<strong>字节打印流</strong>，与之对应的是 <code>PrintWriter</code> （<strong>字符打印流</strong>）。PrintStream 是 OutputStream 的子类，PrintWriter 是 Writer 的子类。</li></ul><h4 id="–-随机访问流"><a href="#–-随机访问流" class="headerlink" title="– 随机访问流"></a>– 随机访问流</h4><ul><li>支持<strong>随意跳转到文件的任意位置进行读写</strong>的 <code>RandomAccessFile</code> 。</li><li><code>RandomAccessFile</code> 比较常见的一个应用就是实现大文件的 <strong>断点续传</strong> 。</li><li><strong>断点续传？</strong>简单来说就是上传文件中途暂停或失败（比如遇到网络问题）之后，不需要重新上传，只需要上传那些未成功上传的文件分片即可。<strong>分片</strong>（先将文件切分成多个文件分片）<strong>上传</strong>是断点续传的基础。</li></ul><h3 id="【Java-IO-设计模式】"><a href="#【Java-IO-设计模式】" class="headerlink" title="【Java IO 设计模式】"></a>【Java IO 设计模式】</h3><h4 id="–-装饰器模式"><a href="#–-装饰器模式" class="headerlink" title="– 装饰器模式"></a>– 装饰器模式</h4><p>详解：<a href="https://zhuanlan.zhihu.com/p/444298983">https://zhuanlan.zhihu.com/p/444298983</a></p><ul><li>装饰器（Decorator）模式 指<strong>在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的</strong>模式，它属于对象结构型模式。</li><li>装饰器模式<strong>通过组合替代继承来扩展原始类的功能</strong>，在一些继承关系比较复杂的场景（IO 这一场景各种类的继承关系就比较复杂）更加实用。</li><li>例如，<code>InputStream</code> 的子类 <code>FilterInputStream</code>，<code>Reader</code> 的子类 <code>BufferedReader</code> 以及 <code>FilterReader</code>，还有 <code>Writer</code> 的子类 <code>BufferedWriter、FilterWriter</code> 以及 <code>PrintWriter</code> 等，它们都是抽象装饰类。</li></ul><ol><li>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</li><li>具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。</li><li>抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li><li>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li><li>代码</li></ol><h4 id="–-适配器模式"><a href="#–-适配器模式" class="headerlink" title="– 适配器模式"></a>– 适配器模式</h4><p>详解：<a href="https://segmentfault.com/a/1190000040524953">java - 一文彻底弄懂适配器模式(Adapter Pattern) - 个人文章 - SegmentFault 思否</a></p><ul><li>适配器（Adapter Pattern）模式 是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。</li><li>适配器模式中存在被适配的对象或者类称为 <strong>适配者(Adaptee)</strong> ，作用于适配者的对象或者类称为<strong>适配器(Adapter)</strong> 。适配器分为<strong>对象适配器</strong>和<strong>类适配器</strong>。类适配器使用<strong>继承关系</strong>来实现，对象适配器使用<strong>组合关系</strong>来实现。</li><li>IO 流中的<strong>字符流和字节流</strong>的接口不同，它们<strong>之间</strong>可以<strong>协调工作</strong>就是基于适配器模式来做的，更准确点来说是对象适配器。通过适配器，我们可以将字节流对象适配成一个字符流对象。</li><li><strong><code>InputStreamReader</code></strong> 和 <strong><code>OutputStreamWriter</code></strong> 就是两个适配器(Adapter)， 同时，它们两个也是字节流和字符流之间的桥梁。</li><li>代码</li></ul><h4 id="–-适配器模式和装饰器模式有什么区别呢？"><a href="#–-适配器模式和装饰器模式有什么区别呢？" class="headerlink" title="– 适配器模式和装饰器模式有什么区别呢？"></a>– 适配器模式和装饰器模式有什么区别呢？</h4><ul><li><strong>装饰器模式</strong> 更侧重于动态地增强原始类的功能，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。并且，装饰器模式支持对原始类嵌套使用多个装饰器。</li><li><strong>适配器模式</strong> 更侧重于让接口不兼容而不能交互的类可以一起工作，当我们调用适配器对应的方法时，适配器内部会调用适配者类或者和适配类相关的类的方法，这个过程透明的。</li></ul><h4 id="–-工厂模式"><a href="#–-工厂模式" class="headerlink" title="– 工厂模式"></a>– 工厂模式</h4><p>详解：<a href="https://blog.csdn.net/qq_42804736/article/details/115168313">java工厂模式：简单工厂、工厂方法、抽象工厂（通俗易懂）_java 抽象工厂模式-CSDN博客</a></p><p>工厂模式用于<strong>创建对象</strong>，NIO 中大量用到了工厂模式，</p><ol><li>比如 <code>Files</code> 类的 <code>newInputStream</code> 方法用于创建 <code>InputStream</code> 对象（<strong>静态工厂</strong>）</li><li>Paths 类的 get 方法创建 Path 对象（静态工厂）</li><li>ZipFileSystem 类（sun.nio包下的类，属于 java.nio 相关的一些内部实现）的 getPath 的方法创建 Path 对象（<strong>简单工厂</strong>）</li></ol><h4 id="–-观察者模式"><a href="#–-观察者模式" class="headerlink" title="– 观察者模式"></a>– 观察者模式</h4><p>详解：<a href="https://segmentfault.com/a/1190000040530952">java - 一文彻底搞懂观察者模式(Observer Pattern) - 个人文章 - SegmentFault 思否</a></p><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><p>NIO 中的文件目录监听服务使用到了观察者模式。</p><ul><li>NIO 中的文件目录监听服务基于 WatchService 接口和 Watchable 接口。WatchService 属于观察者，Watchable 属于被观察者。</li><li>Watchable 接口定义了一个用于将对象注册到 WatchService（监控服务） 并绑定监听事件的方法 register 。</li></ul><h3 id="【Java-IO-模型】"><a href="#【Java-IO-模型】" class="headerlink" title="【Java IO 模型】"></a>【Java IO 模型】</h3><p><a href="https://www.javabetter.cn/sidebar/sanfene/javase.html#_44-bio">https://www.javabetter.cn/sidebar/sanfene/javase.html#_44-bio</a></p><p>三种IO</p><ul><li><p><strong>BIO(blocking I&#x2F;O)</strong> ： 就是传统的 IO，<strong>同步阻塞</strong>，服务器实现模式为一个连接一个线程，即<strong>客户端有连接请求时服务器端就需要启动一个线程进行处理</strong>，如果这个连接不做任何事情会造成不必要的线程开销，可以通过连接池机制改善(实现多个客户连接服务器)。</p><p>BIO 方式适用于<strong>连接数目比较小且固定的架构</strong>，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，程序简单易理解。</p></li><li><p><strong>NIO</strong> ：全称 java non-blocking IO，是指 JDK 提供的新 API。从 JDK1.4 开始，Java 提供了一系列改进的输入&#x2F;输出的新特性，被统称为 NIO(即 New IO)。</p><p>NIO 是<strong>同步非阻塞</strong>的，服务器端<strong>用一个线程处理多个连接</strong>，客户端发送的<strong>连接请求会注册到多路复用器上</strong>，<strong>多路复用器轮询到连接有 IO 请求就进行处理</strong>。</p><p>NIO 的数据是面向<strong>缓冲区 Buffer</strong>的，必须从 Buffer 中读取或写入。</p></li><li><p><strong>AIO</strong>：JDK 7 引入了 Asynchronous I&#x2F;O，是<strong>异步不阻塞</strong>的 IO。在进行 I&#x2F;O 编程中，常用到两种模式：Reactor 和 Proactor。Java 的 NIO 就是 Reactor，<strong>当有事件触发时，服务器端得到通知，进行相应的处理，完成后才通知服务端程序启动线程去处理</strong>，一般适用于<strong>连接数较多且连接时间较长</strong>的应用。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;持续补充！&lt;/p&gt;</summary>
    
    
    
    <category term="Java IO" scheme="https://sunrisel135.github.io/blog_lyl/categories/Java-IO/"/>
    
    
    <category term="面试" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java面试-集合</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/10/Java%E9%9D%A2%E8%AF%95-%E9%9B%86%E5%90%88/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/10/Java%E9%9D%A2%E8%AF%95-%E9%9B%86%E5%90%88/</id>
    <published>2024-03-10T01:40:11.000Z</published>
    <updated>2024-03-11T02:07:03.074Z</updated>
    
    <content type="html"><![CDATA[<p>Java集合框架总结…</p><span id="more"></span><h3 id="【集合概述】"><a href="#【集合概述】" class="headerlink" title="【集合概述】"></a>【集合概述】</h3><h4 id="–-Java集合"><a href="#–-Java集合" class="headerlink" title="– Java集合"></a>– Java集合</h4><p>Java 集合， 也叫作容器，主要是由两大接口派生而来：</p><ol><li><code>Collection</code>接口，主要用于存放<strong>单一元素</strong>；</li><li><code>Map</code> 接口，主要用于存放<strong>键值对</strong>。</li></ol><h4 id="–-说说-List-Set-Queue-Map-四者的区别？"><a href="#–-说说-List-Set-Queue-Map-四者的区别？" class="headerlink" title="– 说说 List, Set, Queue, Map 四者的区别？"></a>– 说说 List, Set, Queue, Map 四者的区别？</h4><ul><li><code>List</code>(<em>对付顺序的好帮手</em>): 存储的元素是<strong>有序的</strong>、<strong>可重复</strong>的。</li><li><code>Set</code>(<em>注重独一无二的性质</em>): 存储的元素<strong>不可重复</strong>的。</li><li><code>Queue</code>(<em>实现排队功能的叫号机</em>): 按特定的<strong>排队</strong>规则来确定先后顺序，存储的元素是<strong>有序</strong>的、<strong>可重复</strong>的。</li><li><code>Map</code>(<em>用 key 来搜索的专家</em>): 使用<strong>键值对（key-value）</strong>存储，<strong>key 是无序的、不可重复的</strong>，<strong>value 是无序的、可重复的</strong>，<strong>每个键最多映射到一个值</strong>。</li></ul><h4 id="–-集合框架底层数据结构总结"><a href="#–-集合框架底层数据结构总结" class="headerlink" title="– 集合框架底层数据结构总结"></a>– 集合框架底层数据结构总结</h4><ul><li><strong>Collection</strong><ul><li><code>List</code><ul><li><code>ArrayList</code>：**<code>Object[]</code> 数组**。详细可以查看：<a href="">ArrayList 源码分析</a>。</li><li><code>Vector</code>：<code>Object[]</code> 数组。</li><li><code>LinkedList</code>：<strong>双向链表</strong> (JDK1.6 之前为循环链表，JDK1.7 取消了循环)。详细可以查看：<a href="">LinkedList 源码分析</a>。</li></ul></li><li><code>Set</code><ul><li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 HashMap 来保存元素。</li><li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 LinkedHashMap 来实现的。</li><li><code>TreeSet</code>(有序，唯一): <strong>红黑树</strong>(自平衡的排序二叉树)</li></ul></li><li><strong>Queue</strong><ul><li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现小顶堆。详细可以查看：<a href="">PriorityQueue 源码分析</a>。</li><li><code>DelayQueue</code>:<code>PriorityQueue</code>。详细可以查看：<a href="">DelayQueue 源码分析</a>。</li><li><code>ArrayDeque</code>: 可扩容动态双向数组。</li></ul></li></ul></li><li><strong>Map</strong><ul><li><code>HashMap</code>：<strong>JDK1.8 之前</strong> <code>HashMap</code> 由<strong>数组+链表</strong>组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。<strong>JDK1.8 以后</strong>在解决哈希冲突时有了较大的变化，<strong>当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树</strong>，以减少搜索时间。详细可以查看：<a href="">HashMap 源码分析</a>。</li><li><code>LinkedHashMap</code>：<code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于<strong>拉链式散列结构即由数组和链表或红黑树组成</strong>。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条<strong>双向链表</strong>，使得上面的结构可以保持键值对的插入顺序。</li><li><code>Hashtable</code>：<strong>数组+链表</strong>组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的。</li><li><code>TreeMap</code>：红黑树（自平衡的排序二叉树）。</li></ul></li></ul><h4 id="–-如何选用集合"><a href="#–-如何选用集合" class="headerlink" title="– 如何选用集合?"></a>– 如何选用集合?</h4><ul><li>根据<strong>键值</strong>获取到元素值时就选用 <code>Map</code> 接口下的集合<ul><li>需要<strong>排序</strong>时选择 <code>TreeMap</code></li><li>不需要排序时就选择 <code>HashMap</code></li><li>需要保证<strong>线程安全</strong>就选用 <code>ConcurrentHashMap</code></li></ul></li><li>只需要存放<strong>元素值</strong>时，就选择实现<code>Collection</code> 接口的集合，<ul><li>需要<strong>保证元素唯一</strong>时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code>，</li><li>不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code>，然后再根据实现这些接口的集合的特点来选用。</li></ul></li></ul><h4 id="–-为什么要使用集合？"><a href="#–-为什么要使用集合？" class="headerlink" title="– 为什么要使用集合？"></a>– 为什么要使用集合？</h4><ul><li>数组：存储一组类型相同的数据</li><li>集合：存储的数据类型多种多样且数量不确定</li><li>Java 集合提高了数据的存储和处理灵活性，可以更好地适应现代软件开发中多样化的数据需求，并支持高质量的代码编写</li></ul><h4 id="【List】"><a href="#【List】" class="headerlink" title="【List】"></a>【List】</h4><h4 id="–-ArrayList-和-Array（数组）的区别？"><a href="#–-ArrayList-和-Array（数组）的区别？" class="headerlink" title="– ArrayList 和 Array（数组）的区别？"></a>– ArrayList 和 Array（数组）的区别？</h4><p><code>ArrayList</code> 动态数组，比 Array（静态数组） 使用起来更加灵活：</p><ul><li><code>ArrayList</code>会<strong>动态地扩容或缩容</strong>，而 <code>Array</code> 创建后就无法改变长度。</li><li><code>ArrayList</code> 可使用<strong>泛型</strong>来确保类型安全，<code>Array</code> 则不行。</li><li><code>ArrayList</code> 中<strong>只能存储对象</strong>。对于基本类型数据，需要使用其对应的<strong>包装类</strong>（如 Integer、Double 等）。<code>Array</code> 则是都可以存储。</li><li><code>ArrayList</code> 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度的数组，<strong>只能按照下标访问其中的元素，不具备动态添加、删除元素的能力</strong>。</li><li><code>ArrayList</code><strong>创建时不需要指定大小</strong>，而<code>Array</code>创建时<strong>必须指定大小</strong>。</li></ul><h4 id="–-ArrayList-和-Vector-的区别-（了解即可）"><a href="#–-ArrayList-和-Vector-的区别-（了解即可）" class="headerlink" title="– ArrayList 和 Vector 的区别?（了解即可）"></a>– ArrayList 和 Vector 的区别?（了解即可）</h4><ul><li><code>ArrayList</code> 是 List 的主要实现类，底层使用 Object[]存储，适用于频繁的查找工作，线程不安全 </li><li><code>Vector</code> 是 List 的古老实现类，底层使用Object[] 存储，<strong>线程安全</strong></li></ul><h4 id="–-Vector-和-Stack-的区别-（了解即可）"><a href="#–-Vector-和-Stack-的区别-（了解即可）" class="headerlink" title="– Vector 和 Stack 的区别?（了解即可）"></a>– Vector 和 Stack 的区别?（了解即可）</h4><ul><li><code>Vector</code> 和 Stack 两者都是线程安全的，都是使用 synchronized 关键字进行同步处理。</li><li><code>Stack</code> 继承自 Vector，是一个后进先出的栈，而 Vector 是一个列表。</li></ul><p>随着 Java 并发编程的发展，Vector 和 Stack 已经被淘汰，推荐使用并发集合类（例如 <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code> 等）或者手动实现线程安全的方法来提供安全的多线程操作支持。</p><h4 id="–-ArrayList-可以添加-null-值吗？"><a href="#–-ArrayList-可以添加-null-值吗？" class="headerlink" title="– ArrayList 可以添加 null 值吗？"></a>– ArrayList 可以添加 null 值吗？</h4><p><code>ArrayList</code> 中可以<strong>存储任何类型的对象</strong>，包括 null 值。</p><p>不建议向ArrayList 中添加 null 值， null 值无意义，会让代码难以维护比如忘记做判空处理就会导致空指针异常。</p><h4 id="–-ArrayList-插入和删除元素的时间复杂度？"><a href="#–-ArrayList-插入和删除元素的时间复杂度？" class="headerlink" title="– ArrayList 插入和删除元素的时间复杂度？"></a>– ArrayList 插入和删除元素的时间复杂度？</h4><p><strong>对于插入：</strong></p><ul><li><p><strong>头插：</strong>需将所有元素依次向后移一个位置，所以<strong>O(n)</strong></p></li><li><p><strong>尾插</strong>：<code>ArrayList</code> 的容量未达到极限时，**O(1)**，只需在数组末尾添加元素；</p><p>容量已达到极限需要扩容时，需要执行一次 <strong>O(n)</strong> 的操作将原数组复制到新的更大的数组中，然后<strong>再</strong>执行 <strong>O(1)</strong> 的操作添加元素。</p></li><li><p><strong>指定位置插入：</strong>目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n&#x2F;2 个元素，因此时间复杂度为 **O(n)**。</p></li></ul><p><strong>对于删除：</strong></p><ul><li>头部删除：需将所有元素依次向前移动一个位置，**O(n)**。</li><li>尾部删除：**O(1)**。</li><li>指定位置删除：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 **O(n)**。</li></ul><h4 id="–-LinkedList-插入和删除元素的时间复杂度？"><a href="#–-LinkedList-插入和删除元素的时间复杂度？" class="headerlink" title="– LinkedList 插入和删除元素的时间复杂度？"></a>– LinkedList 插入和删除元素的时间复杂度？</h4><ul><li>头部插入&#x2F;删除：只需修改头结点的指针即可，时间复杂度为 **O(1)**。</li><li>尾部插入&#x2F;删除：只需修改尾结点的指针即可，时间复杂度为 **O(1)**。</li><li>指定位置插入&#x2F;删除：需<strong>先移动</strong>到指定位置，<strong>再修改</strong>指定节点的指针完成插入&#x2F;删除，因此需移动平均 n&#x2F;2 个元素，时间复杂度为 **O(n)**。</li></ul><h4 id="–-RandomAccess-接口？LinkedList-为什么不能实现-RandomAccess-接口？"><a href="#–-RandomAccess-接口？LinkedList-为什么不能实现-RandomAccess-接口？" class="headerlink" title="– RandomAccess 接口？LinkedList 为什么不能实现 RandomAccess 接口？"></a>– RandomAccess 接口？LinkedList 为什么不能实现 RandomAccess 接口？</h4><p>★<code>RandomAccess</code> 是一个<strong>标记接口</strong>，用来<strong>表明实现该接口的类支持随机访问（即可以通过索引快速访问元素）</strong>。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</p><p>在 <code>binarySearch（)</code> 方法中，它要判断传入的 list 是否 <code>RandomAccess</code> 的实例，如果是，调用<code>indexedBinarySearch()</code>方法，如果不是，那么调用<code>iteratorBinarySearch()</code>方法</p><p><code>LinkedList</code> 底层数据结构是链表，内存地址不连续，<strong>只能通过指针来定位</strong>，<strong>不支持随机快速访问</strong>，所以不能实现 <code>RandomAccess</code> 接口。</p><h4 id="–-ArrayList-与-LinkedList-区别"><a href="#–-ArrayList-与-LinkedList-区别" class="headerlink" title="– ArrayList 与 LinkedList 区别?"></a>– ArrayList 与 LinkedList 区别?</h4><ul><li><p><strong>是否保证线程安全</strong>：<code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也<strong>就</strong>是<strong>不保证线程安全</strong>；</p></li><li><p><strong>底层数据结构</strong>：<code>ArrayList</code> 底层使用的是 <code>Object</code> <strong>数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。）</p></li><li><p><strong>插入和删除是否受元素位置的影响：</strong></p><p><code>ArrayList</code> 采用<strong>数组存储</strong>，插入和删除元素的时间复杂度受元素位置的影响；</p><p><code>add(E e)</code>方法， <code>ArrayList</code> 会默认追加到列表的末尾。</p><p><code>LinkedList</code> 采用<strong>链表存储</strong>，在<strong>头尾插入或者删除元素</strong>不受元素位置的影响<code>LinkedList</code> 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响。<strong>指定位置</strong>需要先移动到指定位置再插入和删除。</p></li><li><p><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code>（实现了 <code>RandomAccess</code> 接口） 支持。</p></li><li><p><strong>内存空间占用：</strong> <code>ArrayList</code> 的空间浪费主要体现在在 list 列表的结尾会<strong>预留</strong>一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p></li></ul><h4 id="–-双向链表和双向循环链表"><a href="#–-双向链表和双向循环链表" class="headerlink" title="– 双向链表和双向循环链表"></a>– 双向链表和双向循环链表</h4><ul><li><strong>双向链表：</strong> 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。</li><li><strong>双向循环链表：</strong> 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。</li></ul><h4 id="–-说一说-ArrayList-的扩容机制吧"><a href="#–-说一说-ArrayList-的扩容机制吧" class="headerlink" title="– 说一说 ArrayList 的扩容机制吧"></a>– 说一说 ArrayList 的扩容机制吧</h4><h3 id="【Set】"><a href="#【Set】" class="headerlink" title="【Set】"></a>【Set】</h3><h4 id="–-Comparable-和-Comparator-的区别"><a href="#–-Comparable-和-Comparator-的区别" class="headerlink" title="– Comparable 和 Comparator 的区别"></a>– Comparable 和 Comparator 的区别</h4><p>都是 Java 中用于排序的接口。</p><p>需要对一个集合使用自定义排序时，我们就要重写<code>compareTo()</code>方法或<code>compare()</code>方法。</p><p>需要对某一个集合实现两种排序方式时，可以重写compareTo()方法和使用自制的Comparator方法或者以两个 Comparator 来实现。</p><ul><li><code>Comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li><li><code>Comparator</code>接口实际上是出自 <code>java.util</code> 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序。<code>Comparator</code> <strong>定制排序</strong>。</li></ul><h4 id="–-无序性和不可重复性的含义是什么"><a href="#–-无序性和不可重复性的含义是什么" class="headerlink" title="– 无序性和不可重复性的含义是什么"></a>– 无序性和不可重复性的含义是什么</h4><ul><li><strong>无序性</strong>不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的<strong>顺序</strong>添加 ，而是根据数据的哈希值决定的。</li><li><strong>不可重复性</strong>是指添加的元素按照 <code>equals()</code> 判断时 ，返回 false，需要同时重写 <code>equals()</code> 方法和 <code>hashCode()</code> 方法。</li></ul><h4 id="–-比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#–-比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="– 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>– 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h4><ul><li>都是 <code>Set</code> 接口的实现类，都能保证<strong>元素唯一</strong>，并且都<strong>不</strong>是<strong>线程安全</strong>的。</li><li><strong>底层数据结构：</strong><code>HashSet</code> 的底层数据结构是<strong>哈希表</strong>（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是<strong>链表和哈希表</strong>，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是<strong>红黑树</strong>，元素是有序的，排序的方式有<strong>自然排序</strong>和<strong>定制排序</strong>。</li><li><strong>应用场景：</strong><code>HashSet</code> <strong>不</strong>能保证元素插入和取出的<strong>有序</strong>，<code>LinkedHashSet</code> 用于保证元素的插入和取出<strong>顺序</strong>满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素<strong>自定义排序规则</strong>的场景。</li></ul><h3 id="【Queue】"><a href="#【Queue】" class="headerlink" title="【Queue】"></a>【Queue】</h3><h4 id="–-Queue-与-Deque-的区别"><a href="#–-Queue-与-Deque-的区别" class="headerlink" title="– Queue 与 Deque 的区别"></a>– Queue 与 Deque 的区别</h4><ul><li><p><code>Queue</code> 是单端队列，只能从<strong>一端插</strong>入元素，<strong>另一端删除</strong>元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p><p> 扩展了 <code>Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p></li><li><p><code>Deque</code> 是双端队列，扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法</p><p>同样根据失败后处理方式的不同分为两类。事实上，Deque 还提供有 push() 和 pop() 等其他方法，可用于模拟栈。</p></li></ul><h4 id="–-ArrayDeque-与-LinkedList-的区别"><a href="#–-ArrayDeque-与-LinkedList-的区别" class="headerlink" title="– ArrayDeque 与 LinkedList 的区别"></a>– ArrayDeque 与 LinkedList 的区别</h4><p>都实现了 <code>Deque</code> 接口，两者都具有队列的功能。</p><ul><li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li><li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li><li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li><li>从<strong>性能</strong>的角度上，选用 <code>ArrayDeque</code> 来实现队列更好。<code>ArrayDeque</code> 也可以用于实现栈。</li></ul><h3 id="【Map】"><a href="#【Map】" class="headerlink" title="【Map】"></a>【Map】</h3><h4 id="–-HashMap-和-Hashtable-的区别"><a href="#–-HashMap-和-Hashtable-的区别" class="headerlink" title="– HashMap 和 Hashtable 的区别"></a>– HashMap 和 Hashtable 的区别</h4><ul><li><p><strong>线程是否安全：</strong><code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</p></li><li><p><code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰；</p></li><li><p><code>HashMap</code>的key可以存储1个null，value可以有多个； Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</p></li><li><p><strong>初始容量大小和每次扩充容量大小的不同</strong>：</p><ul><li><p><code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1</p></li><li><p>创建时如果给定了容量初始值，那么 <code>Hashtable</code> 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <strong><code>HashMap</code> 总是使用 2 的幂作为哈希表的大小</strong>,后面会介绍到为什么是 2 的幂次方。</p></li></ul></li><li><p><strong>底层数据结构</strong></p><p><code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间。<code>Hashtable</code> 没有这样的机制。</p></li></ul><h4 id="–-HashMap-和-HashSet-区别"><a href="#–-HashMap-和-HashSet-区别" class="headerlink" title="– HashMap 和 HashSet 区别"></a>– HashMap 和 HashSet 区别</h4><p><code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。</p><ul><li><code>HashMap</code>实现了 <code>Map</code> 接口，存储键值对，调用 <code>put()</code>向 map 中添加元素，HashMap<code>使用键（Key）计算</code>hashcode。</li><li><code>HashSet</code>实现 <code>Set</code> 接口，仅存储对象，调用 <code>add()</code>方法向 <code>Set</code> 中添加元素，使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</li></ul><h4 id="–-HashMap-和-TreeMap-区别"><a href="#–-HashMap-和-TreeMap-区别" class="headerlink" title="– HashMap 和 TreeMap 区别"></a>– HashMap 和 TreeMap 区别</h4><p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p><ul><li>相比于<code>HashMap</code>来说 <code>TreeMap</code> 主要多了对集合中的元素根据键<strong>排序</strong>的能力以及<strong>对集合内元素的搜索</strong>的能力。</li></ul><h4 id="–-HashSet-如何检查重复-★"><a href="#–-HashSet-如何检查重复-★" class="headerlink" title="– HashSet 如何检查重复? ★"></a>– HashSet 如何检查重复? ★</h4><p>对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p><h4 id="–-HashMap-的底层实现-★"><a href="#–-HashMap-的底层实现-★" class="headerlink" title="– HashMap 的底层实现 ★"></a>– HashMap 的底层实现 ★</h4><ul><li><p><strong>JDK1.8 之前</strong> <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 <code>hashcode</code> 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p></li><li><p>所谓扰动函数指的就是 HashMap 的 <code>hash</code> 方法。使用 <code>hash</code> 方法也就是扰动函数是为了防止一些实现比较差的 <code>hashCode()</code> 方法 换句话说使用扰动函数之后可以减少碰撞。</p></li><li><p><strong>JDK1.8 之后</strong>在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p></li><li><p><strong>拉链法”</strong> ：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p></li></ul><h4 id="–-HashMap-的长度为什么是-2-的幂次方"><a href="#–-HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="– HashMap 的长度为什么是 2 的幂次方"></a>– HashMap 的长度为什么是 2 的幂次方</h4><p>为了<strong>加快哈希计算</strong>以及<strong>减少哈希冲突</strong>。</p><p><strong>“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。”</strong> 并且 <strong>采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。</strong></p><h4 id="–-HashMap-多线程操作导致死循环问题"><a href="#–-HashMap-多线程操作导致死循环问题" class="headerlink" title="– HashMap 多线程操作导致死循环问题"></a>– HashMap 多线程操作导致死循环问题</h4><p>JDK1.7 及之前版本的 <code>HashMap</code> 在多线程环境下<strong>扩容操作</strong>可能存在死循环问题，这是由于当一个桶位中有多个元素需要进行扩容时，多个线程同时<strong>对链表进行操作</strong>，<strong>头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束</strong>。</p><p>JDK1.8 版本的 <code>HashMap</code> 采用了<strong>尾插法</strong>而不是头插法来避免链表倒置，使得<strong>插入的节点永远都是放在链表的末尾，避免了链表中的环形结构</strong>。</p><p>并发环境下，推荐使用 <code>ConcurrentHashMap</code> 。</p><h4 id="–-HashMap-为什么线程不安全？"><a href="#–-HashMap-为什么线程不安全？" class="headerlink" title="– HashMap 为什么线程不安全？"></a>– HashMap 为什么线程不安全？</h4><p>JDK1.7 及之前版本，在多线程环境下，<code>HashMap</code> 扩容时会造成死循环和数据丢失的问题。</p><p>JDK 1.8 后，在 <code>HashMap</code> 中，多个键值对可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。多个线程对 <code>HashMap</code> 的 <code>put</code> 操作会导致线程不安全，具体来说会有数据覆盖的风险。</p><h4 id="–-HashMap-常见的遍历方式"><a href="#–-HashMap-常见的遍历方式" class="headerlink" title="– HashMap 常见的遍历方式?"></a>– HashMap 常见的遍历方式?</h4><p><strong>存在阻塞时 parallelStream 性能最高, 非阻塞时 parallelStream 性能最低</strong> 。</p><h4 id="–-ConcurrentHashMap-和-Hashtable-的区别"><a href="#–-ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="– ConcurrentHashMap 和 Hashtable 的区别"></a>– ConcurrentHashMap 和 Hashtable 的区别</h4><p>区别主要体现在<strong>实现线程安全的方式</strong>上不同。</p><ul><li><p><strong>底层数据结构：</strong></p><ul><li><code>ConcurrentHashMap</code>，JDK1.7采用分段的数组+链表，JDK1.8采用数组+链表&#x2F;红黑二叉树。</li><li><code>Hashtable</code>，<strong>数组+链表</strong></li></ul></li><li><p><strong>实现线程安全的方式（重要）：</strong></p><ul><li>JDK1.7，<code>ConcurrentHashMap</code>对整个桶数组进行了分割分段(<code>Segment</code>，<strong>分段锁</strong>)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</li><li>JDK1.8，<code>ConcurrentHashMap</code> 直接用 <code>Node</code> 数组+链表+红黑树的数据结构，并发控制使用 <code>synchronized</code> 和 <strong>CAS</strong> 来操作。（JDK1.6 以后 <code>synchronized</code> 锁做了很多优化） 存在旧的东西就是为了<strong>向下兼容</strong>版本。</li><li><strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。</li></ul></li></ul><h4 id="–-ConcurrentHashMap-线程安全的具体实现方式-底层具体实现"><a href="#–-ConcurrentHashMap-线程安全的具体实现方式-底层具体实现" class="headerlink" title="– ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现"></a>– ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现</h4><h4 id="–-JDK-1-7-和-JDK-1-8-的-ConcurrentHashMap-实现有什么不同？"><a href="#–-JDK-1-7-和-JDK-1-8-的-ConcurrentHashMap-实现有什么不同？" class="headerlink" title="– JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？"></a>– JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？</h4><ul><li><strong>线程安全实现方式</strong>：JDK 1.7 ， <code>Segment</code> 分段锁， <code>Segment</code> 继承自 <code>ReentrantLock</code>。JDK1.8 ，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</li><li><strong>Hash 碰撞解决方法</strong> : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树</li><li><strong>并发度</strong>：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</li></ul><h4 id="–-ConcurrentHashMap-为什么-key-和-value-不能为-null？"><a href="#–-ConcurrentHashMap-为什么-key-和-value-不能为-null？" class="headerlink" title="– ConcurrentHashMap 为什么 key 和 value 不能为 null？"></a>– ConcurrentHashMap 为什么 key 和 value 不能为 null？</h4><p>避免二义性，</p><p>用 null 作为键，那么你就无法区分这个键是否存在于 <code>ConcurrentHashMap</code> 中，还是根本没有这个键。同样，</p><p>用 null 作为值，那么你就无法区分这个值是否是真正存储在 <code>ConcurrentHashMap</code> 中的，还是因为找不到对应的键而返回的。</p><h4 id="–-ConcurrentHashMap-能保证复合操作的原子性吗？"><a href="#–-ConcurrentHashMap-能保证复合操作的原子性吗？" class="headerlink" title="– ConcurrentHashMap 能保证复合操作的原子性吗？"></a>– ConcurrentHashMap 能保证复合操作的原子性吗？</h4><p>不一定！</p><ul><li><code>ConcurrentHashMap</code> 是线程安全的，可以保证多个线程同时对它进行读写操作时，不会出现数据不一致的情况和死循环问题。</li><li>复合操作是指由多个基本操作(如<code>put</code>、<code>get</code>、<code>remove</code>、<code>containsKey</code>等)组成的操作。这种操作在执行过程中可能会<strong>被其他线程打断</strong>，导致结果不符合预期。</li></ul><p><strong>那如何保证 <code>ConcurrentHashMap</code> 复合操作的原子性呢？</strong></p><p><code>ConcurrentHashMap</code> 提供了一些原子性的复合操作，如 <code>putIfAbsent</code>、<code>compute</code>、<code>computeIfAbsent</code> 、<code>computeIfPresent</code>、<code>merge</code>等。这些<strong>方法</strong>都可以接受一个函数作为参数，根据给定的 key 和 value 来计算一个新的 value，并且将其更新到 map 中。</p><h3 id="【Collections-工具类（不重要）】"><a href="#【Collections-工具类（不重要）】" class="headerlink" title="【Collections 工具类（不重要）】"></a>【Collections 工具类（不重要）】</h3><p><strong><code>Collections</code> 工具类常用方法</strong>:</p><ul><li>排序</li><li>查找,替换操作</li><li>同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)</li></ul><h3 id="【其他-注意项】"><a href="#【其他-注意项】" class="headerlink" title="【其他 注意项】"></a>【其他 注意项】</h3><h4 id="–-集合判空"><a href="#–-集合判空" class="headerlink" title="– 集合判空"></a>– 集合判空</h4><p>判断所有集合内部的元素是否为空，使用 <code>isEmpty()</code> 方法，而不是 <code>size()==0</code> 的方式。</p><p>这是因为 **isEmpty() 方法的可读性更好，并且时间复杂度为 O(1)**。</p><h4 id="–-集合转-Map"><a href="#–-集合转-Map" class="headerlink" title="– 集合转 Map"></a>– 集合转 Map</h4><p>在使用 <code>java.util.stream.Collectors</code> 类的 <code>toMap()</code> 方法转为 <code>Map</code> 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。</p><h4 id="–-集合遍历"><a href="#–-集合遍历" class="headerlink" title="– 集合遍历"></a>– 集合遍历</h4><p>不要在 <code>foreach</code> 循环里进行元素的 <code>remove/add</code> 操作。<code>remove</code> 元素请使用 <code>Iterator</code> 方式，如果并发操作，需要对 <code>Iterator</code> 对象加锁。</p><ul><li>foreach 语法底层其实还是依赖 <code>Iterator</code> 。不过， <code>remove/add</code> 操作直接调用的是集合自己的方法，而不是 <code>Iterator</code> 的 <code>remove/add</code>方法。这就导致 <code>Iterator</code> 莫名其妙地发现自己有元素被 <code>remove/add</code> ，然后，它就会抛出一个 <code>ConcurrentModificationException</code> 来提示用户发生了并发修改异常。这就是单线程状态下产生的 <strong>fail-fast 机制</strong>。</li><li><strong>fail-fast 机制</strong>：多个线程对 fail-fast 集合进行修改的时候，可能会抛出<code>ConcurrentModificationException</code>。 即使是单线程下也有可能会出现这种情况，上面已经提到过。</li></ul><h4 id="–-集合去重"><a href="#–-集合去重" class="headerlink" title="– 集合去重"></a>– 集合去重</h4><p>可以利用 <strong><code>Set</code></strong> 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 <code>List</code> 的 <code>contains()</code> 进行遍历去重或者判断包含操作。</p><h4 id="–-集合转数组"><a href="#–-集合转数组" class="headerlink" title="– 集合转数组"></a>– 集合转数组</h4><p>使用集合转数组的方法，必须使用集合的 <strong><code>toArray(T[] array)</code><strong>，</strong>传入的是类型完全一致、长度为 0 的空数组</strong>。</p><h4 id="–-数组转集合"><a href="#–-数组转集合" class="headerlink" title="– 数组转集合"></a>– 数组转集合</h4><p>使用工具类 <code>Arrays.asList()</code> 把数组转换成集合时，不能使用其修改集合相关的方法， 它的 <code>add/remove/clear</code> 方法会抛出 <code>UnsupportedOperationException</code> 异常。</p><ul><li><code>Arrays.asList()</code>是泛型方法，传递的数组必须是对象数组，而不是基本类型。</li><li>使用集合的修改方法: <code>add()</code>、<code>remove()</code>、<code>clear()</code>会抛出异常。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java集合框架总结…&lt;/p&gt;</summary>
    
    
    
    <category term="Java集合" scheme="https://sunrisel135.github.io/blog_lyl/categories/Java%E9%9B%86%E5%90%88/"/>
    
    
    <category term="面试" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java面试-并发编程</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/08/Java%E9%9D%A2%E8%AF%95-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/08/Java%E9%9D%A2%E8%AF%95-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</id>
    <published>2024-03-08T05:45:56.000Z</published>
    <updated>2024-03-08T07:51:13.415Z</updated>
    
    <content type="html"><![CDATA[<p>常看常新，持续更新…</p><span id="more"></span><h3 id="【线程】"><a href="#【线程】" class="headerlink" title="【线程】"></a>【线程】</h3><h4 id="–-什么是线程和进程"><a href="#–-什么是线程和进程" class="headerlink" title="– 什么是线程和进程?"></a>– 什么是线程和进程?</h4><h5 id="进程？"><a href="#进程？" class="headerlink" title="进程？"></a>进程？</h5><ul><li><strong>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。</strong></li><li>系统运行一个程序即是一个进程从创建，运行到消亡的过程。</li><li>Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</li></ul><h5 id="线程"><a href="#线程" class="headerlink" title="线程?"></a>线程?</h5><ul><li><strong>与进程相似，线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。</strong></li><li>与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</li></ul><h5 id="用户线程、内核线程？"><a href="#用户线程、内核线程？" class="headerlink" title="用户线程、内核线程？"></a>用户线程、内核线程？</h5><ul><li>用户线程 (jdk1.2前)：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）。<br>内核线程 (jdk1.2及以后)：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）。</li><li>现在的 Java 线程的本质其实就是操作系统的线程。</li></ul><h4 id="–-线程与进程的关系-区别及优缺点？"><a href="#–-线程与进程的关系-区别及优缺点？" class="headerlink" title="– 线程与进程的关系,区别及优缺点？"></a>– 线程与进程的关系,区别及优缺点？</h4><p>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p><h4 id="–-并发与并行的区别"><a href="#–-并发与并行的区别" class="headerlink" title="– 并发与并行的区别"></a>– 并发与并行的区别</h4><ul><li><strong>并发</strong>：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li><li><strong>并行</strong>：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li></ul><p>最关键的点是：是否是 <strong>同时</strong> 执行。</p><h4 id="–-同步和异步的区别"><a href="#–-同步和异步的区别" class="headerlink" title="– 同步和异步的区别"></a>– 同步和异步的区别</h4><ul><li>同步：发出一个调用之后，在<strong>没有得到结果之前</strong>， 该调用就不可以返回，<strong>一直等待</strong>。</li><li>异步：调用在发出之后，<strong>不用等待返回结果</strong>，该调用直接返回。</li></ul><h4 id="–-为什么要使用多线程"><a href="#–-为什么要使用多线程" class="headerlink" title="– 为什么要使用多线程?"></a>– 为什么要使用多线程?</h4><ul><li>线程是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li><li>可以大大提高系统整体的并发能力以及性能。</li></ul><h4 id="–-使用多线程可能带来什么问题"><a href="#–-使用多线程可能带来什么问题" class="headerlink" title="– 使用多线程可能带来什么问题?"></a>– 使用多线程可能带来什么问题?</h4><p>并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：<strong>内存泄漏、死锁、线程不安全</strong>等。</p><h4 id="–-如何理解线程安全？"><a href="#–-如何理解线程安全？" class="headerlink" title="– 如何理解线程安全？"></a>– 如何理解线程安全？</h4><p><strong>多线程环境下对于同一份数据的访问是否能够保证其正确性和一致性。</strong></p><p>线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。</p><h4 id="–-线程的生命周期和状态-★"><a href="#–-线程的生命周期和状态-★" class="headerlink" title="– 线程的生命周期和状态? ★"></a>– 线程的生命周期和状态? ★</h4><p>六种状态：</p><ul><li><strong>NEW: 初始状态</strong>，线程被创建出来但没有被调用 <code>start()</code> 。</li><li><strong>RUNNABLE: 运行状态</strong>，线程被调用了 <code>start()</code>等待运行的状态。</li><li><strong>BLOCKED：阻塞状态</strong>，需要等待锁释放。</li><li><strong>WAITING：等待状态</strong>，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</li><li><strong>TIME_WAITING：超时等待状态</strong>，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</li><li><strong>TERMINATED：终止状态</strong>，表示该线程已经运行完毕。</li></ul><ol><li>线程创建之后它将处于 NEW（新建） 状态，调用 start() 方法后开始运行，线程这时候处于 READY（可运行） 状态。</li><li>可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 RUNNING（运行） 状态。</li><li>当线程执行 wait()方法之后，线程进入 WAITING（等待） 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。</li><li>TIMED_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制，比如通过 sleep（long millis）方法或 wait（long millis）方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。</li><li>当线程进入 synchronized 方法&#x2F;块或者调用 wait 后（被 notify）重新进入 synchronized 方法&#x2F;块，但是锁被其它线程占有，这个时候线程就会进入 BLOCKED（阻塞） 状态。</li><li>线程在执行完了 run()方法之后之后将会进入到 TERMINATED（终止） 状态。</li></ol><h4 id="–-什么是线程上下文切换"><a href="#–-什么是线程上下文切换" class="headerlink" title="– 什么是线程上下文切换?"></a>– 什么是线程上下文切换?</h4><p>当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p><ul><li>主动让出 CPU，比如调用了 sleep(), wait() 等。</li><li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li><li>被终止或结束运行</li></ul><p>这其中前三种都会发生线程切换，<strong>线程切换</strong>意味着<strong>需要保存当前线程的上下文</strong>，<strong>待线程下次占用 CPU 的时候恢复</strong>现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 上下文切换。</p><p>因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p><h4 id="–-什么是线程死锁-如何避免死锁"><a href="#–-什么是线程死锁-如何避免死锁" class="headerlink" title="– 什么是线程死锁?如何避免死锁?"></a>– 什么是线程死锁?如何避免死锁?</h4><h5 id="什么是死锁："><a href="#什么是死锁：" class="headerlink" title="什么是死锁："></a>什么是死锁：</h5><ul><li><strong>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。</strong>由于线程被无限期地阻塞，因此程序不可能正常终止。</li><li>线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</li></ul><h5 id="产生死锁的四个必要条件："><a href="#产生死锁的四个必要条件：" class="headerlink" title="产生死锁的四个必要条件："></a>产生死锁的四个必要条件：</h5><ol><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。如何预防和避</li></ol><h5 id="预防和避免线程死锁："><a href="#预防和避免线程死锁：" class="headerlink" title="预防和避免线程死锁："></a>预防和避免线程死锁：</h5><p>破坏死锁的产生的必要条件即可：</p><ol><li>破坏请求与保持条件：一次性申请所有的资源。</li><li>破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li>破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li></ol><p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态</p><h4 id="–-sleep-方法和-wait-方法对比"><a href="#–-sleep-方法和-wait-方法对比" class="headerlink" title="– sleep() 方法和 wait() 方法对比"></a>– sleep() 方法和 wait() 方法对比</h4><p><strong>共同点</strong>：两者都可以暂停线程的执行。</p><p><strong>区别</strong>: </p><ul><li><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁 。</li><li><code>wait()</code> 通常被用于线程间交互&#x2F;通信，<code>sleep()</code>通常被用于暂停执行。</li><li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li><li><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法（因为wait要释放当前线程占有的对象锁，操作的对象自然是Object）。</li></ul><h4 id="–-可以直接调用-Thread-类的-run-方法吗？"><a href="#–-可以直接调用-Thread-类的-run-方法吗？" class="headerlink" title="– 可以直接调用 Thread 类的 run 方法吗？"></a>– 可以直接调用 Thread 类的 run 方法吗？</h4><p><strong>调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。</strong></p><h3 id="【volatile-关键字】"><a href="#【volatile-关键字】" class="headerlink" title="【volatile 关键字】"></a>【volatile 关键字】</h3><h4 id="–-volatile总结"><a href="#–-volatile总结" class="headerlink" title="– volatile总结"></a>– volatile总结</h4><ul><li>volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。</li><li>防止 JVM 的指令重排序。</li></ul><h4 id="–-保证变量的可见性？"><a href="#–-保证变量的可见性？" class="headerlink" title="– 保证变量的可见性？"></a>– 保证变量的可见性？</h4><p>将变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JMM(Java内存模型): </span><br><span class="line">线程1 &lt;-&gt; 本地内存(共享变量副本) &lt;--&gt; 主内存-共享变量</span><br><span class="line">强制在主内存中进行读取:</span><br><span class="line">线程1 &lt;-&gt; 本地内存(共享变量副本) &lt;--&gt; 主内存-共享变量</span><br><span class="line"> &lt;---------------------&gt; 主内存-共享变量</span><br></pre></td></tr></table></figure><h4 id="–-volatile-可以保证原子性么？"><a href="#–-volatile-可以保证原子性么？" class="headerlink" title="– volatile 可以保证原子性么？"></a>– volatile 可以保证原子性么？</h4><p>不能。</p><ul><li><p>线程 1 对 inc 进行读取操作之后，还未对其进行修改。线程 2 又读取了 inc的值并对其进行修改（+1），再将inc 的值写回内存。</p><p>线程 2 操作完毕后，线程 1 对 inc的值进行修改（+1），再将inc 的值写回内存。</p><p>这也就导致两个线程分别对 inc 进行了一次自增操作后，inc 实际上只增加了 1。</p></li><li><p>如果想要保证上面的代码运行正确也非常简单，利用 synchronized、Lock或者AtomicInteger都可以。</p></li></ul><h4 id="–-禁止指令重排序？"><a href="#–-禁止指令重排序？" class="headerlink" title="– 禁止指令重排序？"></a>– 禁止指令重排序？</h4><p>将变量声明为 volatile ，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。</p><h4 id="–-指令重排序"><a href="#–-指令重排序" class="headerlink" title="– 指令重排序"></a>– 指令重排序</h4><ul><li><p>为了提升执行速度&#x2F;性能，计算机在执行程序代码的时候，会对指令进行重排序。</p></li><li><p>系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行</p></li><li><p>常见的指令重排序有下面 2 种情况：</p><ul><li><p>编译器优化重排：编译器（包括 JVM、JIT 编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序。</p></li><li><p>指令并行重排：现代处理器采用了指令级并行技术(Instruction-Level Parallelism，ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p></li></ul></li><li><p>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致 ，所以在多线程下，指令重排序可能会导致一些问题。</p></li></ul><h4 id="–-乐观锁和悲观锁"><a href="#–-乐观锁和悲观锁" class="headerlink" title="– 乐观锁和悲观锁"></a>– 乐观锁和悲观锁</h4><h5 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h5><ul><li>总是假设最坏的情况。<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。</strong></li><li>synchronized 和 ReentrantLock 等<strong>独占锁</strong>就是悲观锁思想的实现。</li></ul><h5 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h5><ul><li>总是假设最好的情况。</li><li>共享资源每次被访问的时候不会出现问题，<strong>线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源</strong>（也就是数据）<strong>是否被其它线程修改了</strong>（具体方法可以使用<strong>版本号机制</strong>或 <strong>CAS 算法</strong>）。</li></ul><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul><li>悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。如果乐观锁解决了频繁失败和重试这个问题的话（比如LongAdder），也是可以考虑使用乐观锁的，要视实际情况而定。</li><li>乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。主要针对的对象是单个共享变量。</li></ul><h5 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h5><p>在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。</p><h5 id="CAS算法-乐观锁使用更多"><a href="#CAS算法-乐观锁使用更多" class="headerlink" title="CAS算法(乐观锁使用更多)"></a>CAS算法(乐观锁使用更多)</h5><p>用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</p><h3 id="【synchronized-关键字】"><a href="#【synchronized-关键字】" class="headerlink" title="【synchronized 关键字】"></a>【synchronized 关键字】</h3><ul><li>Java 中的一个关键字，主要解决的是<strong>多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行</strong>。</li><li>Java 6 进行了<strong>优化</strong></li><li><strong>修饰实例方法、修饰静态方法、修饰代码块</strong></li></ul><h4 id="–-构造方法可以用-synchronized-修饰么？"><a href="#–-构造方法可以用-synchronized-修饰么？" class="headerlink" title="– 构造方法可以用 synchronized 修饰么？"></a>– 构造方法可以用 synchronized 修饰么？</h4><p>构造方法本身就属于线程安全的，不存在同步的构造方法一说。</p><h4 id="–-synchronized-和-volatile-有什么区别？"><a href="#–-synchronized-和-volatile-有什么区别？" class="headerlink" title="– synchronized 和 volatile 有什么区别？"></a>– synchronized 和 volatile 有什么区别？</h4><p>互补。</p><ul><li>volatile 关键字是线程同步的轻量级实现，所以 volatile性能肯定比synchronized关键字要好 。但是 volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块 。</li><li>volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。</li><li>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。</li></ul><h3 id="【ReentrantLock】"><a href="#【ReentrantLock】" class="headerlink" title="【ReentrantLock】"></a>【ReentrantLock】</h3><h4 id="–-ReentrantLock-是什么？"><a href="#–-ReentrantLock-是什么？" class="headerlink" title="– ReentrantLock 是什么？"></a>– ReentrantLock 是什么？</h4><ul><li>实现了 <strong><code>Lock</code></strong> 接口，是一个<strong>可重入且独占式的锁</strong>，和 synchronized 关键字类似。不过，ReentrantLock 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</li><li>ReentrantLock 默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁。</li></ul><h4 id="–-公平锁和非公平锁有什么区别？"><a href="#–-公平锁和非公平锁有什么区别？" class="headerlink" title="– 公平锁和非公平锁有什么区别？"></a>– 公平锁和非公平锁有什么区别？</h4><ul><li><strong>公平锁</strong> : 锁被释放之后，<strong>先申请的线程先得到锁</strong>。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</li><li>非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</li></ul><h4 id="–-synchronized-和-ReentrantLock-有什么区别？"><a href="#–-synchronized-和-ReentrantLock-有什么区别？" class="headerlink" title="– synchronized 和 ReentrantLock 有什么区别？"></a>– synchronized 和 ReentrantLock 有什么区别？</h4><ul><li><strong>两者都是可重入锁</strong><ul><li>可重入锁 也叫递归锁，指的是线程<strong>可以再次获取自己的内部锁</strong>。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</li><li>JDK 提供的所有现成的 Lock 实现类，包括 synchronized 关键字锁都是可重入的。</li></ul></li><li><strong>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</strong></li><li><strong>相比synchronized，ReentrantLock增加了一些高级功能</strong><ul><li>等待可中断</li><li>可实现公平锁</li><li>可实现选择性通知（锁可以绑定多个条件）</li></ul></li></ul><h4 id="–-可中断锁和不可中断锁有什么区别？"><a href="#–-可中断锁和不可中断锁有什么区别？" class="headerlink" title="– 可中断锁和不可中断锁有什么区别？"></a>– 可中断锁和不可中断锁有什么区别？</h4><ul><li>可中断锁：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。ReentrantLock 就属于是可中断锁。</li><li>不可中断锁：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 synchronized 就属于是不可中断锁。</li></ul><h3 id="【ThreadLocal】"><a href="#【ThreadLocal】" class="headerlink" title="【ThreadLocal】"></a>【ThreadLocal】</h3><h4 id="–-ThreadLocal-有什么用？"><a href="#–-ThreadLocal-有什么用？" class="headerlink" title="– ThreadLocal 有什么用？"></a>– ThreadLocal 有什么用？</h4><ul><li>ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以<strong>存储每个线程的私有数据</strong>。</li><li>创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，可以使用 get() 和 set() 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</li></ul><h4 id="–-ThreadLocal-原理了解吗？"><a href="#–-ThreadLocal-原理了解吗？" class="headerlink" title="– ThreadLocal 原理了解吗？"></a>– ThreadLocal 原理了解吗？</h4><ul><li>最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。</li><li>每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为 key ，Object 对象为 value 的键值对。</li></ul><h4 id="–-ThreadLocal-内存泄露问题是怎么导致的？"><a href="#–-ThreadLocal-内存泄露问题是怎么导致的？" class="headerlink" title="– ThreadLocal 内存泄露问题是怎么导致的？"></a>– ThreadLocal 内存泄露问题是怎么导致的？</h4><ul><li>ThreadLocalMap 中使用的 key 为 ThreadLocal 的<strong>弱引用</strong>，而 value 是<strong>强引用</strong>。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</li><li><strong>使用完 ThreadLocal方法后最好手动调用remove()方法</strong></li><li><strong>弱引用</strong>：在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</li></ul><h3 id="【线程池】"><a href="#【线程池】" class="headerlink" title="【线程池】"></a>【线程池】</h3><h4 id="–-线程池？"><a href="#–-线程池？" class="headerlink" title="– 线程池？"></a>– 线程池？</h4><ul><li>管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</li><li>使用线程池的好处：<ul><li>降低资源消耗</li><li>提高响应速度</li><li>提高线程的可管理性</li></ul></li></ul><h4 id="–-如何创建线程池？"><a href="#–-如何创建线程池？" class="headerlink" title="– 如何创建线程池？"></a>– 如何创建线程池？</h4><p>方式一：通过**<code>ThreadPoolExecutor</code>**构造函数来创建（推荐）</p><p>方式二：通过 <strong>Executor 框架</strong>的工具类 <strong>Executors</strong> 来创建。</p><h4 id="–-线程池常见参数有哪些？"><a href="#–-线程池常见参数有哪些？" class="headerlink" title="– 线程池常见参数有哪些？"></a>– 线程池常见参数有哪些？</h4><ul><li><p>ThreadPoolExecutor 3 个最重要的参数：</p><ul><li><strong>corePoolSize</strong> : 任务队列未达到队列容量时，<strong>最大可以同时运行的线程数量</strong>。</li><li><strong>maximumPoolSize</strong> : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong>workQueue:</strong> 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul></li><li><p>ThreadPoolExecutor其他常见参数 :</p><ul><li><p>keepAliveTime:线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，多余的空闲线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁，线程池回收线程时，会对核心线程和非核心线程一视同仁，直到线程池中线程的数量等于 corePoolSize ，回收过程才会停止</p></li><li><p>unit : keepAliveTime 参数的时间单位</p></li><li><p>threadFactory :executor 创建新线程的时候会用到</p></li><li><p>handler :<strong>饱和策略</strong></p></li></ul></li></ul><h4 id="–-线程池的饱和策略有哪些？"><a href="#–-线程池的饱和策略有哪些？" class="headerlink" title="– 线程池的饱和策略有哪些？"></a>– 线程池的饱和策略有哪些？</h4><ul><li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。(spring默认策略)</li><li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li><li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li><li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。</li></ul><h4 id="–-线程池常用的阻塞队列有哪些？"><a href="#–-线程池常用的阻塞队列有哪些？" class="headerlink" title="– 线程池常用的阻塞队列有哪些？"></a>– 线程池常用的阻塞队列有哪些？</h4><p>新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</p><ul><li>容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue（无界队列）</li><li>SynchronousQueue（同步队列）</li><li>DelayedWorkQueue（延迟阻塞队列）</li></ul><h4 id="–-线程池处理任务的流程了解吗？"><a href="#–-线程池处理任务的流程了解吗？" class="headerlink" title="– 线程池处理任务的流程了解吗？"></a>– 线程池处理任务的流程了解吗？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">提交任务 -》 核心线程池是否已满 -Y-》等待队列是否已满 -Y-》线程池是否已满 -Y-》按照策略处理</span><br><span class="line">   -N 》创建线程   - N-》创建队列 -N-》创建线程</span><br></pre></td></tr></table></figure><h3 id="【Future】"><a href="#【Future】" class="headerlink" title="【Future】"></a>【Future】</h3><h4 id="–-Future-类有什么用？"><a href="#–-Future-类有什么用？" class="headerlink" title="– Future 类有什么用？"></a>– Future 类有什么用？</h4><ul><li><p>当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 Future 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p></li><li><p>多线程中经典的 Future 模式，你可以将其看作是一种设计模式，核心思想是异步调用</p></li><li><p>Future 类只是一个泛型接口，位于 java.util.concurrent 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p><ul><li><p>取消任务；</p></li><li><p>判断任务是否被取消;</p></li><li><p>判断任务是否已经执行完成;</p></li><li><p>获取任务执行结果。</p></li></ul></li></ul><h3 id="【AQS】"><a href="#【AQS】" class="headerlink" title="【AQS】"></a>【AQS】</h3><h4 id="–-AQS-是什么？"><a href="#–-AQS-是什么？" class="headerlink" title="– AQS 是什么？"></a>– AQS 是什么？</h4><ul><li>AQS 的全称为 AbstractQueuedSynchronizer ，翻译过来的意思就是抽象队列同步器。</li><li>AQS 就是一个抽象类，主要用来构建锁和同步器。</li><li>AQS 为构建锁和同步器提供了一些通用功能的实现，因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue等等皆是基于 AQS 的。</li></ul><h3 id="【虚拟线程】"><a href="#【虚拟线程】" class="headerlink" title="【虚拟线程】"></a>【虚拟线程】</h3><h3 id="【JMM-Java内存模型-】"><a href="#【JMM-Java内存模型-】" class="headerlink" title="【JMM (Java内存模型)】"></a>【JMM (Java内存模型)】</h3><p><strong>抽象线程和主内存之间的关系</strong></p><h4 id="–-Java-内存区域和-JMM-有何区别？"><a href="#–-Java-内存区域和-JMM-有何区别？" class="headerlink" title="– Java 内存区域和 JMM 有何区别？"></a>– Java 内存区域和 JMM 有何区别？</h4><ul><li>JVM 内存结构和 Java 虚拟机的运行时区域相关，定义了 JVM 在运行时如何分区存储程序数据，就比如说堆主要用于存放对象实例。</li><li>Java 内存模型和 Java 的并发编程相关，抽象了线程和主内存之间的关系就比如说线程之间的共享变量必须存储在主内存中，规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。</li></ul><h3 id="–-并发编程三个重要特性"><a href="#–-并发编程三个重要特性" class="headerlink" title="– 并发编程三个重要特性"></a>– 并发编程三个重要特性</h3><ul><li><p>原子性：一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。</p></li><li><p>可见性：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。</p></li><li><p>有序性：由于指令重排序问题，代码的执行顺序未必就是编写代码时候的顺序。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;常看常新，持续更新…&lt;/p&gt;</summary>
    
    
    
    <category term="并发编程" scheme="https://sunrisel135.github.io/blog_lyl/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="面试" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot3与druid-无法自动装配问题</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/07/SpringBoot3%E4%B8%8Edruid-%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E9%97%AE%E9%A2%98/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/07/SpringBoot3%E4%B8%8Edruid-%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E9%97%AE%E9%A2%98/</id>
    <published>2024-03-07T12:08:30.000Z</published>
    <updated>2024-03-07T12:13:04.660Z</updated>
    
    <content type="html"><![CDATA[<p>SpringBoot3与druid，因为druid版本问题，无法在spring boot中自动装配。</p><span id="more"></span><ul><li><p>解决方式1：</p><p>通过源码分析，druid-spring-boot-3-starter目前最新版本是1.2.18，虽然适配了SpringBoot3，但缺少自动装配的配置文件。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">需要手动在resources目录下创建META-INF/spring  (注意创建时要使用/)</span><br><span class="line">文件：org.springframework.boot.autoconfigure.AutoConfiguration.imports，文件内容如下：</span><br><span class="line">com.alibaba.druid.spring.boot3.autoconfigure.DruidDataSourceAutoConfigure</span><br></pre></td></tr></table></figure><ul><li><p>解决方式2：</p><p>使用 druid1.2.20 版本</p></li></ul><p></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-3-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;SpringBoot3与druid，因为druid版本问题，无法在spring boot中自动装配。&lt;/p&gt;</summary>
    
    
    
    <category term="SpringBoot" scheme="https://sunrisel135.github.io/blog_lyl/categories/SpringBoot/"/>
    
    
    <category term="问题" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Spring从配置文件获取到的值与实际值不一致问题</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/07/Spring%E4%BB%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%8E%B7%E5%8F%96%E5%88%B0%E7%9A%84%E5%80%BC%E4%B8%8E%E5%AE%9E%E9%99%85%E5%80%BC%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/07/Spring%E4%BB%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%8E%B7%E5%8F%96%E5%88%B0%E7%9A%84%E5%80%BC%E4%B8%8E%E5%AE%9E%E9%99%85%E5%80%BC%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/</id>
    <published>2024-03-07T07:51:41.000Z</published>
    <updated>2024-03-07T07:52:33.123Z</updated>
    
    <content type="html"><![CDATA[<p>使用Spring框架对druid数据库连接池配置时，value&#x3D;${username}获取到的值并非配置文件中的值。。。</p><span id="more"></span><ul><li><p>参考链接: <a href="https://blog.csdn.net/qq_46274901/article/details/123835512">https://blog.csdn.net/qq_46274901/article/details/123835512</a></p></li><li><p>原因：</p><p>使用Spring框架对druid数据库连接池配置时，value&#x3D;${username}获取到的值并非配置文件中的值，而是获取的windows系统用户的值，也就是我的名字。从而导致配置信息错误，无法连接数据库。</p></li><li><p>解决：</p><p>将配置文件的username改名为user，将spring中的value配置信息改为value&#x3D;${user}.避免重名即可。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用Spring框架对druid数据库连接池配置时，value&amp;#x3D;${username}获取到的值并非配置文件中的值。。。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="https://sunrisel135.github.io/blog_lyl/categories/Spring/"/>
    
    
    <category term="问题" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>实例化对象方式</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/07/%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%E6%96%B9%E5%BC%8F/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/07/%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%E6%96%B9%E5%BC%8F/</id>
    <published>2024-03-07T07:15:31.000Z</published>
    <updated>2024-03-07T07:38:50.430Z</updated>
    
    <content type="html"><![CDATA[<p>实例化对象的几种方式总结。</p><span id="more"></span><ul><li>构造函数实例化<ul><li>无参构造函数</li><li>有参构造函数</li></ul></li><li>工厂模式实例化<ul><li>静态工厂</li><li>非静态工厂</li></ul></li><li>反射</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;实例化对象的几种方式总结。&lt;/p&gt;</summary>
    
    
    
    <category term="Java基础" scheme="https://sunrisel135.github.io/blog_lyl/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="知识点" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>子、父类加载顺序</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/06/%E5%AD%90%E3%80%81%E7%88%B6%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/06/%E5%AD%90%E3%80%81%E7%88%B6%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/</id>
    <published>2024-03-06T12:58:55.000Z</published>
    <updated>2024-03-13T01:57:43.784Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接: <a href="https://blog.csdn.net/j_love93/article/details/77693230">https://blog.csdn.net/j_love93/article/details/77693230</a></p><p>详解请查看全文…</p><span id="more"></span><h5 id="1-在没有子类的情况下"><a href="#1-在没有子类的情况下" class="headerlink" title="1.在没有子类的情况下"></a>1.在没有子类的情况下</h5><p>**在初始化类时候，首先加载类的静态变量和静态语句块（按照代码上下顺序执行），然后加载类的非静态变量和非静态语句块（按照代码上下顺序执行），最后加载类的构造函数。 </p><p>至于类的静态方法和非静态方法只有主动调用的时候才会执行,区别在于静态方法可以直接用类名直接调用(实例化对象也可以),而非静态方法只能先实例化对象后才能调用。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS:不管是父类还是子类加载（静态变量和静态语句块）都只能加载一次。</span><br><span class="line"></span><br><span class="line">总结：静态 -&gt; 非静态 -&gt; 构造函数</span><br></pre></td></tr></table></figure><h5 id="2-在有子类的情况下"><a href="#2-在有子类的情况下" class="headerlink" title="2.在有子类的情况下"></a>2.在有子类的情况下</h5><p>在初始化子类的时候，首先加载父类的静态变量和静态语句块（按照代码上下顺序执行），然后加载子类的静态变量和静态语句块（按照代码上下顺序执行），然后加载父类的非静态变量和非静态语句块（按照代码上下顺序执行），再加载父类的构造函数。然后加载子类的非静态变量和非静态语句块（按照代码上下顺序执行），最后加载子类的构造函数。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 父类的静态变量和静态语句块（按照代码上下顺序执行）</span><br><span class="line">2. 子类的静态变量和静态语句块（按照代码上下顺序执行）</span><br><span class="line">3. 父类的非静态变量和非静态语句块（按照代码上下顺序执行）</span><br><span class="line">4. 父类的构造函数</span><br><span class="line">5. 子类的非静态变量和非静态语句块（按照代码上下顺序执行）</span><br><span class="line">6. 子类的构造函数</span><br><span class="line"></span><br><span class="line">总结：父类静态--子类静态--父类非静态--父类构造--子类非静态--子类构造</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;参考链接: &lt;a href=&quot;https://blog.csdn.net/j_love93/article/details/77693230&quot;&gt;https://blog.csdn.net/j_love93/article/details/77693230&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;详解请查看全文…&lt;/p&gt;</summary>
    
    
    
    <category term="Java基础" scheme="https://sunrisel135.github.io/blog_lyl/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="知识点" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Java面试-Java基础</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/05/Java%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/05/Java%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/</id>
    <published>2024-03-05T02:21:45.000Z</published>
    <updated>2024-03-09T13:26:51.010Z</updated>
    
    <content type="html"><![CDATA[<p>持续更新。。。</p><span id="more"></span><h2 id="Java基础常见面试题-上"><a href="#Java基础常见面试题-上" class="headerlink" title="Java基础常见面试题(上)"></a>Java基础常见面试题(上)</h2><h3 id="【基础概念与常识】"><a href="#【基础概念与常识】" class="headerlink" title="【基础概念与常识】"></a>【基础概念与常识】</h3><h4 id="–Java-语言有哪些特点"><a href="#–Java-语言有哪些特点" class="headerlink" title="–Java 语言有哪些特点?"></a>–Java 语言有哪些特点?</h4><ul><li>面向对象（封装，继承，多态）</li><li>平台无关性（ Java 虚拟机实现平台无关性）</li><li>支持多线程</li><li>可靠性（具备异常处理和自动内存管理机制）</li><li>安全性（Java 语言本身的设计就提供了多重安全防护机制如访问权限修饰符、限制程序直接访问操作系统资源）</li><li>编译与解释并存</li></ul><h4 id="–Java-SE-vs-Java-EE"><a href="#–Java-SE-vs-Java-EE" class="headerlink" title="–Java SE vs Java EE"></a>–Java SE vs Java EE</h4><p>简单来说，Java SE 是 Java 的基础版本，Java EE 是 Java 的高级版本。Java SE 更适合开发桌面应用程序或简单的服务器应用程序，Java EE 更适合开发复杂的企业级应用程序或 Web 应用程序。</p><p>Java ME 是 Java 的微型版本，主要用于开发嵌入式消费电子设备的应用程序。</p><h4 id="–JVM-vs-JDK-vs-JRE"><a href="#–JVM-vs-JDK-vs-JRE" class="headerlink" title="–JVM vs JDK vs JRE"></a>–JVM vs JDK vs JRE</h4><ul><li><p><strong>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机</strong>。</p><p>JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“<strong>一次编译，随处可以运行</strong>”的关键所在。</p></li><li><p><strong>JRE（Java Runtime Environment） 是 Java 运行时环境。</strong></p><p>它是运行已编译 Java 程序所需的所有内容的集合，主要包括 <strong>Java 虚拟机（JVM）</strong>、<strong>Java 基础类库（Class Library）</strong>。</p></li><li><p><strong>JDK（Java Development Kit），它是功能齐全的 Java SDK，是提供给开发者使用，能够创建和编译 Java 程序的开发套件</strong>。</p><p>它包含了 <strong>JRE</strong>，同时还包含了<strong>编译 java 源码的编译器 javac 以及一些其他工具</strong>比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等。</p></li></ul><h4 id="–什么是字节码-采用字节码的好处是什么"><a href="#–什么是字节码-采用字节码的好处是什么" class="headerlink" title="–什么是字节码?采用字节码的好处是什么?"></a>–什么是字节码?采用字节码的好处是什么?</h4><p><strong>JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），只面向虚拟机。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java 程序从源代码到运行的过程：</span><br><span class="line">.java -&gt; javac 编译 -&gt; .class -&gt; 热点代码？ NO-&gt; 解释器 -&gt; 机器可理解的代码</span><br><span class="line">     YES-&gt; JIT -&gt; 机器可理解的代码</span><br></pre></td></tr></table></figure><p> <strong>JIT</strong>（Just in Time Compilation） <strong>编译器</strong>，而 JIT 属于<strong>运行时编译</strong>。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</p><h4 id="–-为什么说-Java-语言“编译与解释并存”？"><a href="#–-为什么说-Java-语言“编译与解释并存”？" class="headerlink" title="– 为什么说 Java 语言“编译与解释并存”？"></a>– 为什么说 Java 语言“编译与解释并存”？</h4><ul><li><strong>编译型：</strong>编译型语言open in new window 会通过编译器open in new window将源代码<strong>一次性</strong>翻译成可被该平台执行的机器码。一般情况下，编译语言的<strong>执行速度比较快</strong>，开发效率比较低。</li><li><strong>解释型：</strong>解释型语言open in new window会通过解释器open in new window<strong>一句一句</strong>的将代码解释（interpret）为机器代码后再执行。解释型语言<strong>开发效率比较快</strong>，执行速度比较慢。</li><li>因为 Java 程序要经过先编译，后解释两个步骤，<strong>由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</strong></li></ul><h4 id="–-AOT-VS-JIT"><a href="#–-AOT-VS-JIT" class="headerlink" title="– AOT VS JIT ?"></a>– AOT VS JIT ?</h4><ul><li>新的编译模式 <code>AOT</code>(Ahead of Time Compilation) </li><li><code>AOT</code>会在程序被<strong>执行前就将其编译成机器码</strong>，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）</li><li>而 <code>JIT</code> 属于<strong>运行时编译</strong>。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</li><li><code>AOT</code> 的主要优势在于启动时间、内存占用和打包体积。<code>JIT</code> 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。</li><li><code>AOT</code> 更适合当下的云原生场景，对微服务架构的支持也比较友好。无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等。然而，很多框架和库（如 Spring、CGLIB）都用到了这些特性。如果只使用 AOT 编译，那就没办法使用这些框架和库了，或者说需要针对性地去做适配和优化。</li></ul><h4 id="–-Oracle-JDK-vs-OpenJDK"><a href="#–-Oracle-JDK-vs-OpenJDK" class="headerlink" title="– Oracle JDK vs OpenJDK"></a>– Oracle JDK vs OpenJDK</h4><ol><li>是否开源</li><li>是否免费</li><li>功能性：Oracle JDK 在 OpenJDK 的基础上添加了一些特有的功能和工具</li><li>稳定性</li><li>协议</li></ol><h4 id="–-Java-和-C-的区别"><a href="#–-Java-和-C-的区别" class="headerlink" title="– Java 和 C++ 的区别?"></a>– Java 和 C++ 的区别?</h4><ul><li>都是面向对象的语言，都支持封装、继承和多态</li></ul><ol><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li><li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li><li>……</li></ol><h3 id="【基本语法】"><a href="#【基本语法】" class="headerlink" title="【基本语法】"></a>【基本语法】</h3><h4 id="–-注释有哪几种形式？"><a href="#–-注释有哪几种形式？" class="headerlink" title="– 注释有哪几种形式？"></a>– 注释有哪几种形式？</h4><ol><li><strong>单行注释</strong>：通常用于解释方法内某单行代码的作用。</li><li><strong>多行注释</strong>：通常用于解释一段代码的作用。</li><li><strong>文档注释</strong>：通常用于生成 Java 开发文档。</li></ol><h4 id="–-标识符和关键字的区别是什么？"><a href="#–-标识符和关键字的区别是什么？" class="headerlink" title="– 标识符和关键字的区别是什么？"></a>– 标识符和关键字的区别是什么？</h4><ul><li>在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了 <strong>标识符</strong> 。简单来说， <strong>标识符就是一个名字</strong> 。</li><li><strong>关键字是被赋予特殊含义的标识符</strong> 。</li><li>Tips：所有的关键字都是小写的，在 IDE 中会以特殊颜色显示。</li></ul><h4 id="–-自增自减运算符"><a href="#–-自增自减运算符" class="headerlink" title="– 自增自减运算符"></a>– 自增自减运算符</h4><p>自增运算符（++)和自减运算符（–）</p><h4 id="–-移位运算符"><a href="#–-移位运算符" class="headerlink" title="– 移位运算符"></a>– 移位运算符</h4><ul><li><code>&lt;&lt;</code> :左移运算符，向左移若干位，高位丢弃，低位补零。<code>x &lt;&lt; 1</code>,相当于 x 乘以 2(不溢出的情况下)。</li><li><code>&gt;&gt;</code> :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。<code>x &gt;&gt; 1</code>,相当于 x 除以 2。</li><li><code>&gt;&gt;&gt;</code> :无符号右移，忽略符号位，空位都以 0 补齐。</li><li>移位操作符实际上支持的类型只有<code>int</code>和<code>long</code>，编译器在对short、byte、char类型进行移位前，都会将其转换为int类型再操作。</li></ul><h4 id="–-continue、break-和-return-的区别是什么？"><a href="#–-continue、break-和-return-的区别是什么？" class="headerlink" title="– continue、break 和 return 的区别是什么？"></a>– continue、break 和 return 的区别是什么？</h4><ol><li><code>continue</code>：指跳出当前的这一次循环，继续下一次循环。</li><li><code>break</code>：指跳出整个循环体，继续执行循环下面的语句。</li><li><code>return</code> 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：<ul><li><code>return;</code>：直接使用 return 结束方法执行，用于没有返回值函数的方法</li><li><code>return value;</code>：return 一个特定值，用于有返回值函数的方法</li></ul></li></ol><h3 id="【基本数据类型】"><a href="#【基本数据类型】" class="headerlink" title="【基本数据类型】"></a>【基本数据类型】</h3><h4 id="–-Java-中有-8-种基本数据类型"><a href="#–-Java-中有-8-种基本数据类型" class="headerlink" title="– Java 中有 8 种基本数据类型"></a>– Java 中有 8 种基本数据类型</h4><ul><li>6 种数字类型：<ul><li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>2 种浮点型：<code>float</code>、<code>double</code></li></ul></li><li>1 种字符类型：<code>char</code></li><li>1 种布尔型：<code>boolean</code>。</li></ul><h4 id="–-基本类型和包装类型的区别？"><a href="#–-基本类型和包装类型的区别？" class="headerlink" title="– 基本类型和包装类型的区别？"></a>– 基本类型和包装类型的区别？</h4><p>八种基本类型都有对应的包装类分别为：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</p><ul><li><p>除了定义一些常量和局部变量之外，我们在其他地方比如<strong>方法参数、对象属性</strong>中很少会使用基本类型<strong>来定义变量</strong>。并且，<strong>包装类型</strong>可<strong>用于泛型</strong>，而基本类型不可以。</p></li><li><p><strong>基本数据类型</strong>：<strong>局部变量</strong>存放在JVM<strong>栈</strong>的局部变量表中，<strong>成员变量</strong>存放在<strong>堆</strong>中。</p><p><strong>包装类型</strong>属于<strong>对象</strong>类型，我们知道几乎所有对象实例都存在于<strong>堆</strong>中。</p></li><li><p><strong>占用空间</strong>：基本数据类型占用的空间往往非常小。</p></li><li><p><strong>默认值</strong>：成员变量<strong>包装类</strong>型不赋值就是 <strong>null</strong> ，而<strong>基本类型有默认值</strong>且不是 null。</p></li><li><p><strong>比较方式</strong>：基本数据类型 <code>==</code>，整型包装类对象 <code>equals()</code></p></li></ul><h4 id="–-包装类型的缓存机制了解么？"><a href="#–-包装类型的缓存机制了解么？" class="headerlink" title="– 包装类型的缓存机制了解么？"></a>– 包装类型的缓存机制了解么？</h4><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p><h4 id="–-自动装箱与拆箱了解吗？原理是什么？"><a href="#–-自动装箱与拆箱了解吗？原理是什么？" class="headerlink" title="– 自动装箱与拆箱了解吗？原理是什么？"></a>– 自动装箱与拆箱了解吗？原理是什么？</h4><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来； <code>valueOf()</code>方法</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型； <code>xxxValue()</code>方法</li><li><code>Integer i = 10 等价于 Integer i = Integer.valueOf(10)</code><br><code>int n = i 等价于 int n = i.intValue();</code></li><li>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</li></ul><h4 id="–-为什么浮点数运算的时候会有精度丢失的风险？"><a href="#–-为什么浮点数运算的时候会有精度丢失的风险？" class="headerlink" title="– 为什么浮点数运算的时候会有精度丢失的风险？"></a>– 为什么浮点数运算的时候会有精度丢失的风险？</h4><p>计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。</p><h4 id="–-如何解决浮点数运算的精度丢失问题？"><a href="#–-如何解决浮点数运算的精度丢失问题？" class="headerlink" title="– 如何解决浮点数运算的精度丢失问题？"></a>– 如何解决浮点数运算的精度丢失问题？</h4><p><code>BigDecimal</code></p><h4 id="–-超过-long-整型的数据应该如何表示？"><a href="#–-超过-long-整型的数据应该如何表示？" class="headerlink" title="– 超过 long 整型的数据应该如何表示？"></a>– 超过 long 整型的数据应该如何表示？</h4><p><code>BigInteger</code></p><h3 id="【变量】"><a href="#【变量】" class="headerlink" title="【变量】"></a>【变量】</h3><h4 id="–-成员变量与局部变量的区别？"><a href="#–-成员变量与局部变量的区别？" class="headerlink" title="– 成员变量与局部变量的区别？"></a>– 成员变量与局部变量的区别？</h4><ul><li><p><strong>语法形式</strong>：</p><p>成员变量是<strong>属于类</strong>的，而局部变量是<strong>在代码块或方法中定义的变量或是方法的参数</strong>；</p><p>成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</p></li><li><p><strong>存储方式</strong>：</p><p>如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而<strong>对象存在于堆内存，局部变量则存在于栈内存</strong>。</p></li><li><p><strong>生存时间</strong>：</p><p>成员变量是对象的一部分，它<strong>随着对象的创建而存在</strong>，</p><p>而局部变量随着方法的调用而自动生成，<strong>随着方法的调用结束而消亡</strong>。</p></li><li><p><strong>默认值</strong>：</p><p>成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值 (一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值) ；</p><p>而<strong>局部变量则不会自动赋值</strong>；</p></li></ul><h4 id="–-字符型常量和字符串常量的区别"><a href="#–-字符型常量和字符串常量的区别" class="headerlink" title="– 字符型常量和字符串常量的区别?"></a>– 字符型常量和字符串常量的区别?</h4><ul><li><p>形式 : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。</p></li><li><p>含义 : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。</p></li><li><p>占内存大小：字符常量只占 2 个字节; 字符串常量占若干个字节。</p></li><li><p>注意 char 在 Java 中占两个字节。</p></li></ul><h3 id="【方法】"><a href="#【方法】" class="headerlink" title="【方法】"></a>【方法】</h3><h4 id="–-静态方法为什么不能调用非静态成员"><a href="#–-静态方法为什么不能调用非静态成员" class="headerlink" title="– 静态方法为什么不能调用非静态成员?"></a>– 静态方法为什么不能调用非静态成员?</h4><ul><li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li><li>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li></ul><h4 id="–-静态方法和实例方法有何不同？"><a href="#–-静态方法和实例方法有何不同？" class="headerlink" title="– 静态方法和实例方法有何不同？"></a>– 静态方法和实例方法有何不同？</h4><ol><li><strong>调用方式</strong>：在外部调用静态方法时，可以使用 类名.方法名 的方式，也可以使用 对象.方法名 的方式，而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象 。</li><li><strong>访问类成员是否存在限制</strong> ：静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</li></ol><h4 id="–-重载和重写有什么区别？"><a href="#–-重载和重写有什么区别？" class="headerlink" title="– 重载和重写有什么区别？"></a>– 重载和重写有什么区别？</h4><ul><li><p><strong>重载</strong></p><p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p></li><li><p><strong>重写</strong></p><p>发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><ol><li><p>方法名、参数列表必须相同，子类方法<strong>返回值类型</strong>应比父类方法返回值类型<strong>更小或相等</strong>，抛出的<strong>异常范围小于等于</strong>父类，<strong>访问修饰符范围大于等于</strong>父类。</p><p>如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p></li><li><p>如果父类方法访问修饰符为 <strong><code>private/final/static</code></strong> 则子类就<strong>不能重写</strong>该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</p></li><li><p>构造方法无法被重写</p></li></ol><p><strong>方法的重写要遵循“两同两小一大</strong></p></li></ul><h4 id="–-什么是可变长参数？"><a href="#–-什么是可变长参数？" class="headerlink" title="– 什么是可变长参数？"></a>– 什么是可变长参数？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">   <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这样方法就可以接受 0 个或者多个参数</li><li>可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。</li><li>方法重载会优先匹配固定参数</li></ul><h2 id="Java基础常见面试题-中"><a href="#Java基础常见面试题-中" class="headerlink" title="Java基础常见面试题(中)"></a>Java基础常见面试题(中)</h2><h3 id="【面向对象基础】"><a href="#【面向对象基础】" class="headerlink" title="【面向对象基础】"></a>【面向对象基础】</h3><h4 id="–-面向对象和面向过程的区别"><a href="#–-面向对象和面向过程的区别" class="headerlink" title="– 面向对象和面向过程的区别"></a>– 面向对象和面向过程的区别</h4><p>主要区别在于<strong>解决问题的方式</strong>不同：</p><ul><li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li></ul><p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p><h4 id="–-面向过程性能比面向对象高？"><a href="#–-面向过程性能比面向对象高？" class="headerlink" title="– 面向过程性能比面向对象高？"></a>– 面向过程性能比面向对象高？</h4><p><strong>面向过程性能比面向对象高</strong>。</p><p>因为<strong>类调用时需要实例化</strong>，开销较大，<strong>比较消耗资源</strong>，所以当性能是最重要的考量因素的的时候，比如单片机、嵌入式开发、Linux&#x2F;Unix等一般采用面向过程开发。</p><p>但这并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java性能差的主要原因并不是因为它是面向对象语言，而是<strong>Java是半编译语言，最终的执行代码并不是可以直接被CPU执行的二进制机械码</strong>。</p><p>而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其他一些面向过程的脚本语言性能也<strong>并不一定</strong>比Java好。</p><h4 id="–-创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#–-创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="– 创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>– 创建一个对象用什么运算符?对象实体与对象引用有何不同?</h4><p><strong>new</strong> 运算符。</p><p>new 创建对象实例 (对象实例在堆内存中)，<strong>对象引用</strong>指向<strong>对象实例</strong> (对象引用存放在栈内存中)。</p><ul><li>一个对象引用可以指向 0 个或 1 个对象；</li><li>一个对象可以有 n 个引用指向它；</li></ul><h4 id="–-对象的相等和引用相等的区别"><a href="#–-对象的相等和引用相等的区别" class="headerlink" title="– 对象的相等和引用相等的区别"></a>– 对象的相等和引用相等的区别</h4><ul><li><strong>对象的相等</strong>一般比较的是内存中<strong>存放的内容</strong>是否相等。</li><li><strong>引用相等</strong>一般比较的是他们<strong>指向的内存地址</strong>是否相等。</li></ul><h4 id="–-如果一个类没有声明构造方法，该程序能正确执行吗"><a href="#–-如果一个类没有声明构造方法，该程序能正确执行吗" class="headerlink" title="– 如果一个类没有声明构造方法，该程序能正确执行吗?"></a>– 如果一个类没有声明构造方法，该程序能正确执行吗?</h4><p><strong>可以</strong>执行！</p><p><strong>构造方法</strong>是一种特殊的方法，主要作用是完成对象的初始化工作。</p><p>一个类即使没有声明构造方法也会有<strong>默认的不带参数的构造方法</strong>。如果我们自己添加了类的构造方法 (无论是否有参)，Java 就不会添加默认的无参数的构造方法了。</p><p>这也是为什么我们在创建对象的时候后面要加一个括号 (因为要调用无参的构造方法)。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来 (无论是否用到)，因为这可以帮助我们在创建对象的时候少踩坑。</p><h4 id="–-构造方法有哪些特点？是否可被-override"><a href="#–-构造方法有哪些特点？是否可被-override" class="headerlink" title="– 构造方法有哪些特点？是否可被 override?"></a>– 构造方法有哪些特点？是否可被 override?</h4><ul><li>名字与类名相同。</li><li>没有返回值，但不能用 void 声明构造函数。</li><li>生成类的对象时自动执行，无需调用。</li></ul><p>构造方法不能被 override (重写),但是可以 overload (重载)。</p><h3 id="【面向对象三大特征】"><a href="#【面向对象三大特征】" class="headerlink" title="【面向对象三大特征】"></a>【面向对象三大特征】</h3><h4 id="–-封装"><a href="#–-封装" class="headerlink" title="– 封装"></a>– 封装</h4><p><strong>指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。</strong>但是可以提供一些可以被外界访问的方法来操作属性。如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p><h4 id="–-继承"><a href="#–-继承" class="headerlink" title="– 继承"></a>– 继承</h4><p>不同类型的对象，相互之间经常有一定数量的共同点。同时，每一个对象还定义了额外的特性使得他们与众不同。</p><p><strong>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。</strong>通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p><p><strong>注意：</strong></p><ol><li>子类拥有父类对象所有的属性和方法 (包括私有属性和私有方法)，但是<strong>父类中的私有属性和方法子类是无法访问</strong>，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。(以后介绍)。</li></ol><h4 id="–-多态"><a href="#–-多态" class="headerlink" title="– 多态"></a>– 多态</h4><p><strong>表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</strong></p><p><strong>特点:</strong></p><ul><li>对象类型和引用类型之间具有<strong>继承</strong> (类) &#x2F; 实现(接口)的<strong>关系</strong>；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序<strong>运行期间才能确定</strong>；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li></ul><h4 id="–-接口和抽象类有什么共同点和区别？"><a href="#–-接口和抽象类有什么共同点和区别？" class="headerlink" title="– 接口和抽象类有什么共同点和区别？"></a>– 接口和抽象类有什么共同点和区别？</h4><p><strong>共同点</strong>：</p><ul><li>都不能<strong>被实例化</strong>。</li><li>都可以<strong>包含抽象方法</strong>。</li><li>都可以<strong>有默认实现的方法</strong>（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</li></ul><p><strong>区别</strong>：</p><ul><li><strong>接口</strong>主要用于对<strong>类</strong>的<strong>行为</strong>进行<strong>约束</strong>，你实现了某个接口就具有了对应的行为。<strong>抽象类</strong>主要用于<strong>代码复用</strong>，<strong>强调的是所属关系</strong>。</li><li>一个类只能继承一个类，但是可以实现多个接口 (<strong>类的单继承，接口多继承</strong>)。</li><li><strong>接口</strong>中的<strong>成员变量</strong>只能是 <code>public static final</code> 类型的，<strong>不能被修改且必须有初始值</strong>，而<strong>抽象类</strong>的<strong>成员变量</strong>默认 <code>default</code>，<strong>可在子类中被重新定义，也可被重新赋值</strong>。</li></ul><h4 id="–-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><a href="#–-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？" class="headerlink" title="– 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"></a>– 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h4><ul><li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。（父类 <code>Object</code> 的 <code>clone()</code> 方法）</li><li><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。(重写了父类<code>Object</code> 的<code>clone(</code>)方法)</li></ul><p><strong>那什么是引用拷贝呢？</strong> 简单来说，<strong>引用拷贝</strong>就是两个不同的引用指向同一个对象。</p><p><img src="C:\Users\lyl\Desktop\其他\photo\shallow&deep-copy.png"></p><h3 id="【Object】"><a href="#【Object】" class="headerlink" title="【Object】"></a>【Object】</h3><h4 id="–-Object-类的常见方法有哪些？"><a href="#–-Object-类的常见方法有哪些？" class="headerlink" title="– Object 类的常见方法有哪些？"></a>– Object 类的常见方法有哪些？</h4><p>Object 类是一个特殊的类，是<strong>所有类的父类</strong>。它主要提供了以下 11 个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;持续更新。。。&lt;/p&gt;</summary>
    
    
    
    <category term="Java基础" scheme="https://sunrisel135.github.io/blog_lyl/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="面试" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Hexo搭建博客</title>
    <link href="https://sunrisel135.github.io/blog_lyl/2024/03/04/Hexo+github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://sunrisel135.github.io/blog_lyl/2024/03/04/Hexo+github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2024-03-04T12:12:17.000Z</published>
    <updated>2024-03-07T12:06:46.629Z</updated>
    
    <content type="html"><![CDATA[<p>基于 Hexo + GithubPage 搭建博客，我的第一个博客。</p><span id="more"></span><p>参考链接: <a href="https://blog.csdn.net/redrose2100/article/details/121731468">https://blog.csdn.net/redrose2100/article/details/121731468</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;基于 Hexo + GithubPage 搭建博客，我的第一个博客。&lt;/p&gt;</summary>
    
    
    
    <category term="博客相关" scheme="https://sunrisel135.github.io/blog_lyl/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="教程" scheme="https://sunrisel135.github.io/blog_lyl/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
