<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java面试-并发编程"><meta name="keywords" content="面试"><meta name="author" content="lyl_L-,undefined"><meta name="copyright" content="lyl_L-"><title>Java面试-并发编程【lyl'blog】</title><link rel="stylesheet" href="/blog_lyl/css/fan.css"><link rel="stylesheet" href="/blog_lyl/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/blog_lyl/L.ico"><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- script(src=url_for("/js/mathjax/mathjax.js"))--><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/blog_lyl/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: {},
  valine: {},
  twikoo: {},
}</script><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/blog_lyl/atom.xml" title="lyl'blog" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E7%BA%BF%E7%A8%8B%E3%80%91"><span class="toc-number">1.</span> <span class="toc-text">【线程】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">– 什么是线程和进程?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">进程？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">线程?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E3%80%81%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.1.3.</span> <span class="toc-text">用户线程、内核线程？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB-%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">– 线程与进程的关系,区别及优缺点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">– 并发与并行的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.</span> <span class="toc-text">– 同步和异步的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.5.</span> <span class="toc-text">– 为什么要使用多线程?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%AF%E8%83%BD%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.</span> <span class="toc-text">– 使用多线程可能带来什么问题?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">– 如何理解线程安全？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81-%E2%98%85"><span class="toc-number">1.8.</span> <span class="toc-text">– 线程的生命周期和状态? ★</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">1.9.</span> <span class="toc-text">– 什么是线程上下文切换?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-number">1.10.</span> <span class="toc-text">– 什么是线程死锁?如何避免死锁?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%EF%BC%9A"><span class="toc-number">1.10.1.</span> <span class="toc-text">什么是死锁：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6%EF%BC%9A"><span class="toc-number">1.10.2.</span> <span class="toc-text">产生死锁的四个必要条件：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%84%E9%98%B2%E5%92%8C%E9%81%BF%E5%85%8D%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%EF%BC%9A"><span class="toc-number">1.10.3.</span> <span class="toc-text">预防和避免线程死锁：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-sleep-%E6%96%B9%E6%B3%95%E5%92%8C-wait-%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94"><span class="toc-number">1.11.</span> <span class="toc-text">– sleep() 方法和 wait() 方法对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8-Thread-%E7%B1%BB%E7%9A%84-run-%E6%96%B9%E6%B3%95%E5%90%97%EF%BC%9F"><span class="toc-number">1.12.</span> <span class="toc-text">– 可以直接调用 Thread 类的 run 方法吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90volatile-%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%91"><span class="toc-number">2.</span> <span class="toc-text">【volatile 关键字】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-volatile%E6%80%BB%E7%BB%93"><span class="toc-number">2.1.</span> <span class="toc-text">– volatile总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E4%BF%9D%E8%AF%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">– 保证变量的可见性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-volatile-%E5%8F%AF%E4%BB%A5%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E4%B9%88%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">– volatile 可以保证原子性么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">– 禁止指令重排序？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="toc-number">2.5.</span> <span class="toc-text">– 指令重排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">2.6.</span> <span class="toc-text">– 乐观锁和悲观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">2.6.1.</span> <span class="toc-text">悲观锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">2.6.2.</span> <span class="toc-text">乐观锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.6.3.</span> <span class="toc-text">适用场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E5%8F%B7%E6%9C%BA%E5%88%B6"><span class="toc-number">2.6.4.</span> <span class="toc-text">版本号机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CAS%E7%AE%97%E6%B3%95-%E4%B9%90%E8%A7%82%E9%94%81%E4%BD%BF%E7%94%A8%E6%9B%B4%E5%A4%9A"><span class="toc-number">2.6.5.</span> <span class="toc-text">CAS算法(乐观锁使用更多)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%91"><span class="toc-number">3.</span> <span class="toc-text">【synchronized 关键字】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E7%94%A8-synchronized-%E4%BF%AE%E9%A5%B0%E4%B9%88%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">– 构造方法可以用 synchronized 修饰么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-synchronized-%E5%92%8C-volatile-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">– synchronized 和 volatile 有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90ReentrantLock%E3%80%91"><span class="toc-number">4.</span> <span class="toc-text">【ReentrantLock】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-ReentrantLock-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">– ReentrantLock 是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">– 公平锁和非公平锁有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-synchronized-%E5%92%8C-ReentrantLock-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">– synchronized 和 ReentrantLock 有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81%E5%92%8C%E4%B8%8D%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">– 可中断锁和不可中断锁有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90ThreadLocal%E3%80%91"><span class="toc-number">5.</span> <span class="toc-text">【ThreadLocal】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-ThreadLocal-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">– ThreadLocal 有什么用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-ThreadLocal-%E5%8E%9F%E7%90%86%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">– ThreadLocal 原理了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-ThreadLocal-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98%E6%98%AF%E6%80%8E%E4%B9%88%E5%AF%BC%E8%87%B4%E7%9A%84%EF%BC%9F"><span class="toc-number">5.3.</span> <span class="toc-text">– ThreadLocal 内存泄露问题是怎么导致的？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E7%BA%BF%E7%A8%8B%E6%B1%A0%E3%80%91"><span class="toc-number">6.</span> <span class="toc-text">【线程池】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">– 线程池？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-number">6.2.</span> <span class="toc-text">– 如何创建线程池？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">6.3.</span> <span class="toc-text">– 线程池常见参数有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E9%A5%B1%E5%92%8C%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">6.4.</span> <span class="toc-text">– 线程池的饱和策略有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B8%B8%E7%94%A8%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">6.5.</span> <span class="toc-text">– 线程池常用的阻塞队列有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%B5%81%E7%A8%8B%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">6.6.</span> <span class="toc-text">– 线程池处理任务的流程了解吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Future%E3%80%91"><span class="toc-number">7.</span> <span class="toc-text">【Future】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-Future-%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">– Future 类有什么用？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90AQS%E3%80%91"><span class="toc-number">8.</span> <span class="toc-text">【AQS】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-AQS-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.1.</span> <span class="toc-text">– AQS 是什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E3%80%91"><span class="toc-number">9.</span> <span class="toc-text">【虚拟线程】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90JMM-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E3%80%91"><span class="toc-number">10.</span> <span class="toc-text">【JMM (Java内存模型)】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-Java-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%92%8C-JMM-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">10.1.</span> <span class="toc-text">– Java 内存区域和 JMM 有何区别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%93-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E4%B8%AA%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7"><span class="toc-number">11.</span> <span class="toc-text">– 并发编程三个重要特性</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/blog_lyl/images/Java.png"></div><div class="author-info-name">lyl_L-</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/SunRiseL135" target="_blank">GitHub<i class="icon-dot bg-color4"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/blog_lyl/archives"><span class="pull-top">日志</span><span class="pull-bottom">20</span></a><a class="author-info-articles-tags article-meta" href="/blog_lyl/tags"><span class="pull-top">标签</span><span class="pull-bottom">6</span></a><a class="author-info-articles-categories article-meta" href="/blog_lyl/categories"><span class="pull-top">分类</span><span class="pull-bottom">14</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/blog_lyl">首页</a><a class="menu-item" href="/blog_lyl/tags">标签</a><a class="menu-item" href="/blog_lyl/categories">分类</a><a class="menu-item" href="/blog_lyl/archives">归档</a><a class="menu-item" href="/blog_lyl/about">关于</a></nav><div class="right-info"><a class="title-name" href="/blog_lyl/">lyl'blog</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">Java面试-并发编程</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2024-03-08 | 更新于 2024-03-08</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/blog_lyl/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/blog_lyl/tags/%E9%9D%A2%E8%AF%95/">面试</a></div></div></div><div class="main-content"><p>常看常新，持续更新…</p>
<span id="more"></span>

<h3 id="【线程】"><a href="#【线程】" class="headerlink" title="【线程】"></a>【线程】</h3><h4 id="–-什么是线程和进程"><a href="#–-什么是线程和进程" class="headerlink" title="– 什么是线程和进程?"></a>– 什么是线程和进程?</h4><h5 id="进程？"><a href="#进程？" class="headerlink" title="进程？"></a>进程？</h5><ul>
<li><strong>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。</strong></li>
<li>系统运行一个程序即是一个进程从创建，运行到消亡的过程。</li>
<li>Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</li>
</ul>
<h5 id="线程"><a href="#线程" class="headerlink" title="线程?"></a>线程?</h5><ul>
<li><strong>与进程相似，线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。</strong></li>
<li>与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</li>
</ul>
<h5 id="用户线程、内核线程？"><a href="#用户线程、内核线程？" class="headerlink" title="用户线程、内核线程？"></a>用户线程、内核线程？</h5><ul>
<li>用户线程 (jdk1.2前)：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）。<br>内核线程 (jdk1.2及以后)：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）。</li>
<li>现在的 Java 线程的本质其实就是操作系统的线程。</li>
</ul>
<h4 id="–-线程与进程的关系-区别及优缺点？"><a href="#–-线程与进程的关系-区别及优缺点？" class="headerlink" title="– 线程与进程的关系,区别及优缺点？"></a>– 线程与进程的关系,区别及优缺点？</h4><p>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p>
<h4 id="–-并发与并行的区别"><a href="#–-并发与并行的区别" class="headerlink" title="– 并发与并行的区别"></a>– 并发与并行的区别</h4><ul>
<li><strong>并发</strong>：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li>
<li><strong>并行</strong>：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li>
</ul>
<p>最关键的点是：是否是 <strong>同时</strong> 执行。</p>
<h4 id="–-同步和异步的区别"><a href="#–-同步和异步的区别" class="headerlink" title="– 同步和异步的区别"></a>– 同步和异步的区别</h4><ul>
<li>同步：发出一个调用之后，在<strong>没有得到结果之前</strong>， 该调用就不可以返回，<strong>一直等待</strong>。</li>
<li>异步：调用在发出之后，<strong>不用等待返回结果</strong>，该调用直接返回。</li>
</ul>
<h4 id="–-为什么要使用多线程"><a href="#–-为什么要使用多线程" class="headerlink" title="– 为什么要使用多线程?"></a>– 为什么要使用多线程?</h4><ul>
<li>线程是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li>
<li>可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<h4 id="–-使用多线程可能带来什么问题"><a href="#–-使用多线程可能带来什么问题" class="headerlink" title="– 使用多线程可能带来什么问题?"></a>– 使用多线程可能带来什么问题?</h4><p>并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：<strong>内存泄漏、死锁、线程不安全</strong>等。</p>
<h4 id="–-如何理解线程安全？"><a href="#–-如何理解线程安全？" class="headerlink" title="– 如何理解线程安全？"></a>– 如何理解线程安全？</h4><p><strong>多线程环境下对于同一份数据的访问是否能够保证其正确性和一致性。</strong></p>
<p>线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。</p>
<h4 id="–-线程的生命周期和状态-★"><a href="#–-线程的生命周期和状态-★" class="headerlink" title="– 线程的生命周期和状态? ★"></a>– 线程的生命周期和状态? ★</h4><p>六种状态：</p>
<ul>
<li><strong>NEW: 初始状态</strong>，线程被创建出来但没有被调用 <code>start()</code> 。</li>
<li><strong>RUNNABLE: 运行状态</strong>，线程被调用了 <code>start()</code>等待运行的状态。</li>
<li><strong>BLOCKED：阻塞状态</strong>，需要等待锁释放。</li>
<li><strong>WAITING：等待状态</strong>，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</li>
<li><strong>TIME_WAITING：超时等待状态</strong>，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</li>
<li><strong>TERMINATED：终止状态</strong>，表示该线程已经运行完毕。</li>
</ul>
<ol>
<li>线程创建之后它将处于 NEW（新建） 状态，调用 start() 方法后开始运行，线程这时候处于 READY（可运行） 状态。</li>
<li>可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 RUNNING（运行） 状态。</li>
<li>当线程执行 wait()方法之后，线程进入 WAITING（等待） 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。</li>
<li>TIMED_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制，比如通过 sleep（long millis）方法或 wait（long millis）方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。</li>
<li>当线程进入 synchronized 方法&#x2F;块或者调用 wait 后（被 notify）重新进入 synchronized 方法&#x2F;块，但是锁被其它线程占有，这个时候线程就会进入 BLOCKED（阻塞） 状态。</li>
<li>线程在执行完了 run()方法之后之后将会进入到 TERMINATED（终止） 状态。</li>
</ol>
<h4 id="–-什么是线程上下文切换"><a href="#–-什么是线程上下文切换" class="headerlink" title="– 什么是线程上下文切换?"></a>– 什么是线程上下文切换?</h4><p>当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p>
<ul>
<li>主动让出 CPU，比如调用了 sleep(), wait() 等。</li>
<li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li>
<li>被终止或结束运行</li>
</ul>
<p>这其中前三种都会发生线程切换，<strong>线程切换</strong>意味着<strong>需要保存当前线程的上下文</strong>，<strong>待线程下次占用 CPU 的时候恢复</strong>现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 上下文切换。</p>
<p>因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p>
<h4 id="–-什么是线程死锁-如何避免死锁"><a href="#–-什么是线程死锁-如何避免死锁" class="headerlink" title="– 什么是线程死锁?如何避免死锁?"></a>– 什么是线程死锁?如何避免死锁?</h4><h5 id="什么是死锁："><a href="#什么是死锁：" class="headerlink" title="什么是死锁："></a>什么是死锁：</h5><ul>
<li><strong>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。</strong>由于线程被无限期地阻塞，因此程序不可能正常终止。</li>
<li>线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</li>
</ul>
<h5 id="产生死锁的四个必要条件："><a href="#产生死锁的四个必要条件：" class="headerlink" title="产生死锁的四个必要条件："></a>产生死锁的四个必要条件：</h5><ol>
<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>
<li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。如何预防和避</li>
</ol>
<h5 id="预防和避免线程死锁："><a href="#预防和避免线程死锁：" class="headerlink" title="预防和避免线程死锁："></a>预防和避免线程死锁：</h5><p>破坏死锁的产生的必要条件即可：</p>
<ol>
<li>破坏请求与保持条件：一次性申请所有的资源。</li>
<li>破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li>破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>
</ol>
<p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态</p>
<h4 id="–-sleep-方法和-wait-方法对比"><a href="#–-sleep-方法和-wait-方法对比" class="headerlink" title="– sleep() 方法和 wait() 方法对比"></a>– sleep() 方法和 wait() 方法对比</h4><p><strong>共同点</strong>：两者都可以暂停线程的执行。</p>
<p><strong>区别</strong>: </p>
<ul>
<li><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁 。</li>
<li><code>wait()</code> 通常被用于线程间交互&#x2F;通信，<code>sleep()</code>通常被用于暂停执行。</li>
<li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li>
<li><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法（因为wait要释放当前线程占有的对象锁，操作的对象自然是Object）。</li>
</ul>
<h4 id="–-可以直接调用-Thread-类的-run-方法吗？"><a href="#–-可以直接调用-Thread-类的-run-方法吗？" class="headerlink" title="– 可以直接调用 Thread 类的 run 方法吗？"></a>– 可以直接调用 Thread 类的 run 方法吗？</h4><p><strong>调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。</strong></p>
<h3 id="【volatile-关键字】"><a href="#【volatile-关键字】" class="headerlink" title="【volatile 关键字】"></a>【volatile 关键字】</h3><h4 id="–-volatile总结"><a href="#–-volatile总结" class="headerlink" title="– volatile总结"></a>– volatile总结</h4><ul>
<li>volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。</li>
<li>防止 JVM 的指令重排序。</li>
</ul>
<h4 id="–-保证变量的可见性？"><a href="#–-保证变量的可见性？" class="headerlink" title="– 保证变量的可见性？"></a>– 保证变量的可见性？</h4><p>将变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JMM(Java内存模型): </span><br><span class="line">	线程1 &lt;-&gt; 本地内存(共享变量副本) &lt;--&gt; 主内存-共享变量</span><br><span class="line">强制在主内存中进行读取:</span><br><span class="line">	线程1 &lt;-&gt; 本地内存(共享变量副本) &lt;--&gt; 主内存-共享变量</span><br><span class="line">		 &lt;---------------------&gt; 主内存-共享变量</span><br></pre></td></tr></table></figure>



<h4 id="–-volatile-可以保证原子性么？"><a href="#–-volatile-可以保证原子性么？" class="headerlink" title="– volatile 可以保证原子性么？"></a>– volatile 可以保证原子性么？</h4><p>不能。</p>
<ul>
<li><p>线程 1 对 inc 进行读取操作之后，还未对其进行修改。线程 2 又读取了 inc的值并对其进行修改（+1），再将inc 的值写回内存。</p>
<p>线程 2 操作完毕后，线程 1 对 inc的值进行修改（+1），再将inc 的值写回内存。</p>
<p>这也就导致两个线程分别对 inc 进行了一次自增操作后，inc 实际上只增加了 1。</p>
</li>
<li><p>如果想要保证上面的代码运行正确也非常简单，利用 synchronized、Lock或者AtomicInteger都可以。</p>
</li>
</ul>
<h4 id="–-禁止指令重排序？"><a href="#–-禁止指令重排序？" class="headerlink" title="– 禁止指令重排序？"></a>– 禁止指令重排序？</h4><p>将变量声明为 volatile ，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。</p>
<h4 id="–-指令重排序"><a href="#–-指令重排序" class="headerlink" title="– 指令重排序"></a>– 指令重排序</h4><ul>
<li><p>为了提升执行速度&#x2F;性能，计算机在执行程序代码的时候，会对指令进行重排序。</p>
</li>
<li><p>系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行</p>
</li>
<li><p>常见的指令重排序有下面 2 种情况：</p>
<ul>
<li><p>编译器优化重排：编译器（包括 JVM、JIT 编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序。</p>
</li>
<li><p>指令并行重排：现代处理器采用了指令级并行技术(Instruction-Level Parallelism，ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p>
</li>
</ul>
</li>
<li><p>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致 ，所以在多线程下，指令重排序可能会导致一些问题。</p>
</li>
</ul>
<h4 id="–-乐观锁和悲观锁"><a href="#–-乐观锁和悲观锁" class="headerlink" title="– 乐观锁和悲观锁"></a>– 乐观锁和悲观锁</h4><h5 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h5><ul>
<li>总是假设最坏的情况。<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。</strong></li>
<li>synchronized 和 ReentrantLock 等<strong>独占锁</strong>就是悲观锁思想的实现。</li>
</ul>
<h5 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h5><ul>
<li>总是假设最好的情况。</li>
<li>共享资源每次被访问的时候不会出现问题，<strong>线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源</strong>（也就是数据）<strong>是否被其它线程修改了</strong>（具体方法可以使用<strong>版本号机制</strong>或 <strong>CAS 算法</strong>）。</li>
</ul>
<h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul>
<li>悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。如果乐观锁解决了频繁失败和重试这个问题的话（比如LongAdder），也是可以考虑使用乐观锁的，要视实际情况而定。</li>
<li>乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。主要针对的对象是单个共享变量。</li>
</ul>
<h5 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h5><p>在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。</p>
<h5 id="CAS算法-乐观锁使用更多"><a href="#CAS算法-乐观锁使用更多" class="headerlink" title="CAS算法(乐观锁使用更多)"></a>CAS算法(乐观锁使用更多)</h5><p>用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</p>
<h3 id="【synchronized-关键字】"><a href="#【synchronized-关键字】" class="headerlink" title="【synchronized 关键字】"></a>【synchronized 关键字】</h3><ul>
<li>Java 中的一个关键字，主要解决的是<strong>多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行</strong>。</li>
<li>Java 6 进行了<strong>优化</strong></li>
<li><strong>修饰实例方法、修饰静态方法、修饰代码块</strong></li>
</ul>
<h4 id="–-构造方法可以用-synchronized-修饰么？"><a href="#–-构造方法可以用-synchronized-修饰么？" class="headerlink" title="– 构造方法可以用 synchronized 修饰么？"></a>– 构造方法可以用 synchronized 修饰么？</h4><p>构造方法本身就属于线程安全的，不存在同步的构造方法一说。</p>
<h4 id="–-synchronized-和-volatile-有什么区别？"><a href="#–-synchronized-和-volatile-有什么区别？" class="headerlink" title="– synchronized 和 volatile 有什么区别？"></a>– synchronized 和 volatile 有什么区别？</h4><p>互补。</p>
<ul>
<li>volatile 关键字是线程同步的轻量级实现，所以 volatile性能肯定比synchronized关键字要好 。但是 volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块 。</li>
<li>volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。</li>
<li>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。</li>
</ul>
<h3 id="【ReentrantLock】"><a href="#【ReentrantLock】" class="headerlink" title="【ReentrantLock】"></a>【ReentrantLock】</h3><h4 id="–-ReentrantLock-是什么？"><a href="#–-ReentrantLock-是什么？" class="headerlink" title="– ReentrantLock 是什么？"></a>– ReentrantLock 是什么？</h4><ul>
<li>实现了 <strong><code>Lock</code></strong> 接口，是一个<strong>可重入且独占式的锁</strong>，和 synchronized 关键字类似。不过，ReentrantLock 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</li>
<li>ReentrantLock 默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁。</li>
</ul>
<h4 id="–-公平锁和非公平锁有什么区别？"><a href="#–-公平锁和非公平锁有什么区别？" class="headerlink" title="– 公平锁和非公平锁有什么区别？"></a>– 公平锁和非公平锁有什么区别？</h4><ul>
<li><strong>公平锁</strong> : 锁被释放之后，<strong>先申请的线程先得到锁</strong>。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</li>
<li>非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</li>
</ul>
<h4 id="–-synchronized-和-ReentrantLock-有什么区别？"><a href="#–-synchronized-和-ReentrantLock-有什么区别？" class="headerlink" title="– synchronized 和 ReentrantLock 有什么区别？"></a>– synchronized 和 ReentrantLock 有什么区别？</h4><ul>
<li><strong>两者都是可重入锁</strong><ul>
<li>可重入锁 也叫递归锁，指的是线程<strong>可以再次获取自己的内部锁</strong>。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</li>
<li>JDK 提供的所有现成的 Lock 实现类，包括 synchronized 关键字锁都是可重入的。</li>
</ul>
</li>
<li><strong>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</strong></li>
<li><strong>相比synchronized，ReentrantLock增加了一些高级功能</strong><ul>
<li>等待可中断</li>
<li>可实现公平锁</li>
<li>可实现选择性通知（锁可以绑定多个条件）</li>
</ul>
</li>
</ul>
<h4 id="–-可中断锁和不可中断锁有什么区别？"><a href="#–-可中断锁和不可中断锁有什么区别？" class="headerlink" title="– 可中断锁和不可中断锁有什么区别？"></a>– 可中断锁和不可中断锁有什么区别？</h4><ul>
<li>可中断锁：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。ReentrantLock 就属于是可中断锁。</li>
<li>不可中断锁：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 synchronized 就属于是不可中断锁。</li>
</ul>
<h3 id="【ThreadLocal】"><a href="#【ThreadLocal】" class="headerlink" title="【ThreadLocal】"></a>【ThreadLocal】</h3><h4 id="–-ThreadLocal-有什么用？"><a href="#–-ThreadLocal-有什么用？" class="headerlink" title="– ThreadLocal 有什么用？"></a>– ThreadLocal 有什么用？</h4><ul>
<li>ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以<strong>存储每个线程的私有数据</strong>。</li>
<li>创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，可以使用 get() 和 set() 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</li>
</ul>
<h4 id="–-ThreadLocal-原理了解吗？"><a href="#–-ThreadLocal-原理了解吗？" class="headerlink" title="– ThreadLocal 原理了解吗？"></a>– ThreadLocal 原理了解吗？</h4><ul>
<li>最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。</li>
<li>每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为 key ，Object 对象为 value 的键值对。</li>
</ul>
<h4 id="–-ThreadLocal-内存泄露问题是怎么导致的？"><a href="#–-ThreadLocal-内存泄露问题是怎么导致的？" class="headerlink" title="– ThreadLocal 内存泄露问题是怎么导致的？"></a>– ThreadLocal 内存泄露问题是怎么导致的？</h4><ul>
<li>ThreadLocalMap 中使用的 key 为 ThreadLocal 的<strong>弱引用</strong>，而 value 是<strong>强引用</strong>。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</li>
<li><strong>使用完 ThreadLocal方法后最好手动调用remove()方法</strong></li>
<li><strong>弱引用</strong>：在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</li>
</ul>
<h3 id="【线程池】"><a href="#【线程池】" class="headerlink" title="【线程池】"></a>【线程池】</h3><h4 id="–-线程池？"><a href="#–-线程池？" class="headerlink" title="– 线程池？"></a>– 线程池？</h4><ul>
<li>管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</li>
<li>使用线程池的好处：<ul>
<li>降低资源消耗</li>
<li>提高响应速度</li>
<li>提高线程的可管理性</li>
</ul>
</li>
</ul>
<h4 id="–-如何创建线程池？"><a href="#–-如何创建线程池？" class="headerlink" title="– 如何创建线程池？"></a>– 如何创建线程池？</h4><p>方式一：通过**<code>ThreadPoolExecutor</code>**构造函数来创建（推荐）</p>
<p>方式二：通过 <strong>Executor 框架</strong>的工具类 <strong>Executors</strong> 来创建。</p>
<h4 id="–-线程池常见参数有哪些？"><a href="#–-线程池常见参数有哪些？" class="headerlink" title="– 线程池常见参数有哪些？"></a>– 线程池常见参数有哪些？</h4><ul>
<li><p>ThreadPoolExecutor 3 个最重要的参数：</p>
<ul>
<li><strong>corePoolSize</strong> : 任务队列未达到队列容量时，<strong>最大可以同时运行的线程数量</strong>。</li>
<li><strong>maximumPoolSize</strong> : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><strong>workQueue:</strong> 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
</li>
<li><p>ThreadPoolExecutor其他常见参数 :</p>
<ul>
<li><p>keepAliveTime:线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，多余的空闲线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁，线程池回收线程时，会对核心线程和非核心线程一视同仁，直到线程池中线程的数量等于 corePoolSize ，回收过程才会停止</p>
</li>
<li><p>unit : keepAliveTime 参数的时间单位</p>
</li>
<li><p>threadFactory :executor 创建新线程的时候会用到</p>
</li>
<li><p>handler :<strong>饱和策略</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="–-线程池的饱和策略有哪些？"><a href="#–-线程池的饱和策略有哪些？" class="headerlink" title="– 线程池的饱和策略有哪些？"></a>– 线程池的饱和策略有哪些？</h4><ul>
<li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。(spring默认策略)</li>
<li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li>
<li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li>
<li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。</li>
</ul>
<h4 id="–-线程池常用的阻塞队列有哪些？"><a href="#–-线程池常用的阻塞队列有哪些？" class="headerlink" title="– 线程池常用的阻塞队列有哪些？"></a>– 线程池常用的阻塞队列有哪些？</h4><p>新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</p>
<ul>
<li>容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue（无界队列）</li>
<li>SynchronousQueue（同步队列）</li>
<li>DelayedWorkQueue（延迟阻塞队列）</li>
</ul>
<h4 id="–-线程池处理任务的流程了解吗？"><a href="#–-线程池处理任务的流程了解吗？" class="headerlink" title="– 线程池处理任务的流程了解吗？"></a>– 线程池处理任务的流程了解吗？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">提交任务 -》 核心线程池是否已满 -Y-》等待队列是否已满 -Y-》线程池是否已满 -Y-》按照策略处理</span><br><span class="line">						   -N 》创建线程		   - N-》创建队列	 -N-》创建线程</span><br></pre></td></tr></table></figure>



<h3 id="【Future】"><a href="#【Future】" class="headerlink" title="【Future】"></a>【Future】</h3><h4 id="–-Future-类有什么用？"><a href="#–-Future-类有什么用？" class="headerlink" title="– Future 类有什么用？"></a>– Future 类有什么用？</h4><ul>
<li><p>当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 Future 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p>
</li>
<li><p>多线程中经典的 Future 模式，你可以将其看作是一种设计模式，核心思想是异步调用</p>
</li>
<li><p>Future 类只是一个泛型接口，位于 java.util.concurrent 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p>
<ul>
<li><p>取消任务；</p>
</li>
<li><p>判断任务是否被取消;</p>
</li>
<li><p>判断任务是否已经执行完成;</p>
</li>
<li><p>获取任务执行结果。</p>
</li>
</ul>
</li>
</ul>
<h3 id="【AQS】"><a href="#【AQS】" class="headerlink" title="【AQS】"></a>【AQS】</h3><h4 id="–-AQS-是什么？"><a href="#–-AQS-是什么？" class="headerlink" title="– AQS 是什么？"></a>– AQS 是什么？</h4><ul>
<li>AQS 的全称为 AbstractQueuedSynchronizer ，翻译过来的意思就是抽象队列同步器。</li>
<li>AQS 就是一个抽象类，主要用来构建锁和同步器。</li>
<li>AQS 为构建锁和同步器提供了一些通用功能的实现，因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue等等皆是基于 AQS 的。</li>
</ul>
<h3 id="【虚拟线程】"><a href="#【虚拟线程】" class="headerlink" title="【虚拟线程】"></a>【虚拟线程】</h3><h3 id="【JMM-Java内存模型-】"><a href="#【JMM-Java内存模型-】" class="headerlink" title="【JMM (Java内存模型)】"></a>【JMM (Java内存模型)】</h3><p><strong>抽象线程和主内存之间的关系</strong></p>
<h4 id="–-Java-内存区域和-JMM-有何区别？"><a href="#–-Java-内存区域和-JMM-有何区别？" class="headerlink" title="– Java 内存区域和 JMM 有何区别？"></a>– Java 内存区域和 JMM 有何区别？</h4><ul>
<li>JVM 内存结构和 Java 虚拟机的运行时区域相关，定义了 JVM 在运行时如何分区存储程序数据，就比如说堆主要用于存放对象实例。</li>
<li>Java 内存模型和 Java 的并发编程相关，抽象了线程和主内存之间的关系就比如说线程之间的共享变量必须存储在主内存中，规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。</li>
</ul>
<h3 id="–-并发编程三个重要特性"><a href="#–-并发编程三个重要特性" class="headerlink" title="– 并发编程三个重要特性"></a>– 并发编程三个重要特性</h3><ul>
<li><p>原子性：一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。</p>
</li>
<li><p>可见性：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。</p>
</li>
<li><p>有序性：由于指令重排序问题，代码的执行顺序未必就是编写代码时候的顺序。</p>
</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">lyl_L-</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://sunrisel135.github.io/blog_lyl/2024/03/08/Java%E9%9D%A2%E8%AF%95-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">https://sunrisel135.github.io/blog_lyl/2024/03/08/Java面试-并发编程/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">本文声明: </span><span class="post-copyright-info">内容均为个人总结，仅供个人参考！</span></div></div></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/blog_lyl/2024/03/10/Java%E9%9D%A2%E8%AF%95-%E9%9B%86%E5%90%88/"><i class="fas fa-angle-left">&nbsp;</i><span>Java面试-集合</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/blog_lyl/2024/03/07/SpringBoot3%E4%B8%8Edruid-%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E9%97%AE%E9%A2%98/"><span>SpringBoot3与druid-无法自动装配问题</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2024 By lyl_L-</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/copy.js"></script><!--script(src=url)--></body></html>