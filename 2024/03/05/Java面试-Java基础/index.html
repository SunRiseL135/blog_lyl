<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java面试-Java基础"><meta name="keywords" content="面试"><meta name="author" content="lyl_L-,undefined"><meta name="copyright" content="lyl_L-"><title>Java面试-Java基础【lyl'blog】</title><link rel="stylesheet" href="/blog_lyl/css/fan.css"><link rel="stylesheet" href="/blog_lyl/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/blog_lyl/L.ico"><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- script(src=url_for("/js/mathjax/mathjax.js"))--><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/blog_lyl/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: {},
  valine: {},
  twikoo: {},
}</script><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/blog_lyl/atom.xml" title="lyl'blog" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-%E4%B8%8A"><span class="toc-number">1.</span> <span class="toc-text">Java基础常见面试题(上)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86%E3%80%91"><span class="toc-number">1.1.</span> <span class="toc-text">【基础概念与常识】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93Java-%E8%AF%AD%E8%A8%80%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.1.</span> <span class="toc-text">–Java 语言有哪些特点?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93Java-SE-vs-Java-EE"><span class="toc-number">1.1.2.</span> <span class="toc-text">–Java SE vs Java EE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93JVM-vs-JDK-vs-JRE"><span class="toc-number">1.1.3.</span> <span class="toc-text">–JVM vs JDK vs JRE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81-%E9%87%87%E7%94%A8%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.4.</span> <span class="toc-text">–什么是字节码?采用字节码的好处是什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-Java-%E8%AF%AD%E8%A8%80%E2%80%9C%E7%BC%96%E8%AF%91%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%B9%B6%E5%AD%98%E2%80%9D%EF%BC%9F"><span class="toc-number">1.1.5.</span> <span class="toc-text">– 为什么说 Java 语言“编译与解释并存”？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-AOT-VS-JIT"><span class="toc-number">1.1.6.</span> <span class="toc-text">– AOT VS JIT ?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-Oracle-JDK-vs-OpenJDK"><span class="toc-number">1.1.7.</span> <span class="toc-text">– Oracle JDK vs OpenJDK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-Java-%E5%92%8C-C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.8.</span> <span class="toc-text">– Java 和 C++ 的区别?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E3%80%91"><span class="toc-number">1.2.</span> <span class="toc-text">【基本语法】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E6%B3%A8%E9%87%8A%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%BD%A2%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.2.1.</span> <span class="toc-text">– 注释有哪几种形式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E6%A0%87%E8%AF%86%E7%AC%A6%E5%92%8C%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.2.2.</span> <span class="toc-text">– 标识符和关键字的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.2.3.</span> <span class="toc-text">– 自增自减运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.2.4.</span> <span class="toc-text">– 移位运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-continue%E3%80%81break-%E5%92%8C-return-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.2.5.</span> <span class="toc-text">– continue、break 和 return 的区别是什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%91"><span class="toc-number">1.3.</span> <span class="toc-text">【基本数据类型】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-Java-%E4%B8%AD%E6%9C%89-8-%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">– Java 中有 8 种基本数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.3.2.</span> <span class="toc-text">– 基本类型和包装类型的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F"><span class="toc-number">1.3.3.</span> <span class="toc-text">– 包装类型的缓存机制了解么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.3.4.</span> <span class="toc-text">– 自动装箱与拆箱了解吗？原理是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E7%9A%84%E6%97%B6%E5%80%99%E4%BC%9A%E6%9C%89%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%A3%8E%E9%99%A9%EF%BC%9F"><span class="toc-number">1.3.5.</span> <span class="toc-text">– 为什么浮点数运算的时候会有精度丢失的风险？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E7%9A%84%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">1.3.6.</span> <span class="toc-text">– 如何解决浮点数运算的精度丢失问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E8%B6%85%E8%BF%87-long-%E6%95%B4%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA%EF%BC%9F"><span class="toc-number">1.3.7.</span> <span class="toc-text">– 超过 long 整型的数据应该如何表示？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%8F%98%E9%87%8F%E3%80%91"><span class="toc-number">1.4.</span> <span class="toc-text">【变量】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.4.1.</span> <span class="toc-text">– 成员变量与局部变量的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%B8%B8%E9%87%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.2.</span> <span class="toc-text">– 字符型常量和字符串常量的区别?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E6%96%B9%E6%B3%95%E3%80%91"><span class="toc-number">1.5.</span> <span class="toc-text">【方法】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E8%B0%83%E7%94%A8%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">1.5.1.</span> <span class="toc-text">– 静态方法为什么不能调用非静态成员?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">1.5.2.</span> <span class="toc-text">– 静态方法和实例方法有何不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.5.3.</span> <span class="toc-text">– 重载和重写有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="toc-number">1.5.4.</span> <span class="toc-text">– 什么是可变长参数？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-%E4%B8%AD"><span class="toc-number">2.</span> <span class="toc-text">Java基础常见面试题(中)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E3%80%91"><span class="toc-number">2.1.</span> <span class="toc-text">【面向对象基础】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.1.</span> <span class="toc-text">– 面向对象和面向过程的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E6%80%A7%E8%83%BD%E6%AF%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%EF%BC%9F"><span class="toc-number">2.1.2.</span> <span class="toc-text">– 面向过程性能比面向对象高？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%94%A8%E4%BB%80%E4%B9%88%E8%BF%90%E7%AE%97%E7%AC%A6-%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BD%93%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C"><span class="toc-number">2.1.3.</span> <span class="toc-text">– 创建一个对象用什么运算符?对象实体与对象引用有何不同?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9B%B8%E7%AD%89%E5%92%8C%E5%BC%95%E7%94%A8%E7%9B%B8%E7%AD%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.4.</span> <span class="toc-text">– 对象的相等和引用相等的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%B2%A1%E6%9C%89%E5%A3%B0%E6%98%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%8C%E8%AF%A5%E7%A8%8B%E5%BA%8F%E8%83%BD%E6%AD%A3%E7%A1%AE%E6%89%A7%E8%A1%8C%E5%90%97"><span class="toc-number">2.1.5.</span> <span class="toc-text">– 如果一个类没有声明构造方法，该程序能正确执行吗?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9%EF%BC%9F%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%AB-override"><span class="toc-number">2.1.6.</span> <span class="toc-text">– 构造方法有哪些特点？是否可被 override?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%E3%80%91"><span class="toc-number">2.2.</span> <span class="toc-text">【面向对象三大特征】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E5%B0%81%E8%A3%85"><span class="toc-number">2.2.1.</span> <span class="toc-text">– 封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E7%BB%A7%E6%89%BF"><span class="toc-number">2.2.2.</span> <span class="toc-text">– 继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E5%A4%9A%E6%80%81"><span class="toc-number">2.2.3.</span> <span class="toc-text">– 多态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B1%E5%90%8C%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.2.4.</span> <span class="toc-text">– 接口和抽象类有什么共同点和区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="toc-number">2.2.5.</span> <span class="toc-text">– 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Object%E3%80%91"><span class="toc-number">2.3.</span> <span class="toc-text">【Object】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-Object-%E7%B1%BB%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.3.1.</span> <span class="toc-text">– Object 类的常见方法有哪些？</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/blog_lyl/images/Java.png"></div><div class="author-info-name">lyl_L-</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/SunRiseL135" target="_blank">GitHub<i class="icon-dot bg-color8"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/blog_lyl/archives"><span class="pull-top">日志</span><span class="pull-bottom">22</span></a><a class="author-info-articles-tags article-meta" href="/blog_lyl/tags"><span class="pull-top">标签</span><span class="pull-bottom">6</span></a><a class="author-info-articles-categories article-meta" href="/blog_lyl/categories"><span class="pull-top">分类</span><span class="pull-bottom">16</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/blog_lyl">首页</a><a class="menu-item" href="/blog_lyl/tags">标签</a><a class="menu-item" href="/blog_lyl/categories">分类</a><a class="menu-item" href="/blog_lyl/archives">归档</a><a class="menu-item" href="/blog_lyl/about">关于</a></nav><div class="right-info"><a class="title-name" href="/blog_lyl/">lyl'blog</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">Java面试-Java基础</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2024-03-05 | 更新于 2024-03-09</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/blog_lyl/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/blog_lyl/tags/%E9%9D%A2%E8%AF%95/">面试</a></div></div></div><div class="main-content"><p>持续更新。。。</p>
<span id="more"></span>



<h2 id="Java基础常见面试题-上"><a href="#Java基础常见面试题-上" class="headerlink" title="Java基础常见面试题(上)"></a>Java基础常见面试题(上)</h2><h3 id="【基础概念与常识】"><a href="#【基础概念与常识】" class="headerlink" title="【基础概念与常识】"></a>【基础概念与常识】</h3><h4 id="–Java-语言有哪些特点"><a href="#–Java-语言有哪些特点" class="headerlink" title="–Java 语言有哪些特点?"></a>–Java 语言有哪些特点?</h4><ul>
<li>面向对象（封装，继承，多态）</li>
<li>平台无关性（ Java 虚拟机实现平台无关性）</li>
<li>支持多线程</li>
<li>可靠性（具备异常处理和自动内存管理机制）</li>
<li>安全性（Java 语言本身的设计就提供了多重安全防护机制如访问权限修饰符、限制程序直接访问操作系统资源）</li>
<li>编译与解释并存</li>
</ul>
<h4 id="–Java-SE-vs-Java-EE"><a href="#–Java-SE-vs-Java-EE" class="headerlink" title="–Java SE vs Java EE"></a>–Java SE vs Java EE</h4><p>简单来说，Java SE 是 Java 的基础版本，Java EE 是 Java 的高级版本。Java SE 更适合开发桌面应用程序或简单的服务器应用程序，Java EE 更适合开发复杂的企业级应用程序或 Web 应用程序。</p>
<p>Java ME 是 Java 的微型版本，主要用于开发嵌入式消费电子设备的应用程序。</p>
<h4 id="–JVM-vs-JDK-vs-JRE"><a href="#–JVM-vs-JDK-vs-JRE" class="headerlink" title="–JVM vs JDK vs JRE"></a>–JVM vs JDK vs JRE</h4><ul>
<li><p><strong>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机</strong>。</p>
<p>JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“<strong>一次编译，随处可以运行</strong>”的关键所在。</p>
</li>
<li><p><strong>JRE（Java Runtime Environment） 是 Java 运行时环境。</strong></p>
<p>它是运行已编译 Java 程序所需的所有内容的集合，主要包括 <strong>Java 虚拟机（JVM）</strong>、<strong>Java 基础类库（Class Library）</strong>。</p>
</li>
<li><p><strong>JDK（Java Development Kit），它是功能齐全的 Java SDK，是提供给开发者使用，能够创建和编译 Java 程序的开发套件</strong>。</p>
<p>它包含了 <strong>JRE</strong>，同时还包含了<strong>编译 java 源码的编译器 javac 以及一些其他工具</strong>比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等。</p>
</li>
</ul>
<h4 id="–什么是字节码-采用字节码的好处是什么"><a href="#–什么是字节码-采用字节码的好处是什么" class="headerlink" title="–什么是字节码?采用字节码的好处是什么?"></a>–什么是字节码?采用字节码的好处是什么?</h4><p><strong>JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），只面向虚拟机。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java 程序从源代码到运行的过程：</span><br><span class="line">	.java -&gt; javac 编译 -&gt; .class -&gt; 热点代码？ NO-&gt; 解释器 -&gt; 机器可理解的代码</span><br><span class="line">    										 YES-&gt; JIT	 -&gt; 机器可理解的代码</span><br></pre></td></tr></table></figure>

<p> <strong>JIT</strong>（Just in Time Compilation） <strong>编译器</strong>，而 JIT 属于<strong>运行时编译</strong>。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</p>
<h4 id="–-为什么说-Java-语言“编译与解释并存”？"><a href="#–-为什么说-Java-语言“编译与解释并存”？" class="headerlink" title="– 为什么说 Java 语言“编译与解释并存”？"></a>– 为什么说 Java 语言“编译与解释并存”？</h4><ul>
<li><strong>编译型：</strong>编译型语言open in new window 会通过编译器open in new window将源代码<strong>一次性</strong>翻译成可被该平台执行的机器码。一般情况下，编译语言的<strong>执行速度比较快</strong>，开发效率比较低。</li>
<li><strong>解释型：</strong>解释型语言open in new window会通过解释器open in new window<strong>一句一句</strong>的将代码解释（interpret）为机器代码后再执行。解释型语言<strong>开发效率比较快</strong>，执行速度比较慢。</li>
<li>因为 Java 程序要经过先编译，后解释两个步骤，<strong>由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</strong></li>
</ul>
<h4 id="–-AOT-VS-JIT"><a href="#–-AOT-VS-JIT" class="headerlink" title="– AOT VS JIT ?"></a>– AOT VS JIT ?</h4><ul>
<li>新的编译模式 <code>AOT</code>(Ahead of Time Compilation) </li>
<li><code>AOT</code>会在程序被<strong>执行前就将其编译成机器码</strong>，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）</li>
<li>而 <code>JIT</code> 属于<strong>运行时编译</strong>。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</li>
<li><code>AOT</code> 的主要优势在于启动时间、内存占用和打包体积。<code>JIT</code> 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。</li>
<li><code>AOT</code> 更适合当下的云原生场景，对微服务架构的支持也比较友好。无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等。然而，很多框架和库（如 Spring、CGLIB）都用到了这些特性。如果只使用 AOT 编译，那就没办法使用这些框架和库了，或者说需要针对性地去做适配和优化。</li>
</ul>
<h4 id="–-Oracle-JDK-vs-OpenJDK"><a href="#–-Oracle-JDK-vs-OpenJDK" class="headerlink" title="– Oracle JDK vs OpenJDK"></a>– Oracle JDK vs OpenJDK</h4><ol>
<li>是否开源</li>
<li>是否免费</li>
<li>功能性：Oracle JDK 在 OpenJDK 的基础上添加了一些特有的功能和工具</li>
<li>稳定性</li>
<li>协议</li>
</ol>
<h4 id="–-Java-和-C-的区别"><a href="#–-Java-和-C-的区别" class="headerlink" title="– Java 和 C++ 的区别?"></a>– Java 和 C++ 的区别?</h4><ul>
<li>都是面向对象的语言，都支持封装、继承和多态</li>
</ul>
<ol>
<li>Java 不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li>
<li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li>
<li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li>
<li>……</li>
</ol>
<h3 id="【基本语法】"><a href="#【基本语法】" class="headerlink" title="【基本语法】"></a>【基本语法】</h3><h4 id="–-注释有哪几种形式？"><a href="#–-注释有哪几种形式？" class="headerlink" title="– 注释有哪几种形式？"></a>– 注释有哪几种形式？</h4><ol>
<li><strong>单行注释</strong>：通常用于解释方法内某单行代码的作用。</li>
<li><strong>多行注释</strong>：通常用于解释一段代码的作用。</li>
<li><strong>文档注释</strong>：通常用于生成 Java 开发文档。</li>
</ol>
<h4 id="–-标识符和关键字的区别是什么？"><a href="#–-标识符和关键字的区别是什么？" class="headerlink" title="– 标识符和关键字的区别是什么？"></a>– 标识符和关键字的区别是什么？</h4><ul>
<li>在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了 <strong>标识符</strong> 。简单来说， <strong>标识符就是一个名字</strong> 。</li>
<li><strong>关键字是被赋予特殊含义的标识符</strong> 。</li>
<li>Tips：所有的关键字都是小写的，在 IDE 中会以特殊颜色显示。</li>
</ul>
<h4 id="–-自增自减运算符"><a href="#–-自增自减运算符" class="headerlink" title="– 自增自减运算符"></a>– 自增自减运算符</h4><p>自增运算符（++)和自减运算符（–）</p>
<h4 id="–-移位运算符"><a href="#–-移位运算符" class="headerlink" title="– 移位运算符"></a>– 移位运算符</h4><ul>
<li><code>&lt;&lt;</code> :左移运算符，向左移若干位，高位丢弃，低位补零。<code>x &lt;&lt; 1</code>,相当于 x 乘以 2(不溢出的情况下)。</li>
<li><code>&gt;&gt;</code> :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。<code>x &gt;&gt; 1</code>,相当于 x 除以 2。</li>
<li><code>&gt;&gt;&gt;</code> :无符号右移，忽略符号位，空位都以 0 补齐。</li>
<li>移位操作符实际上支持的类型只有<code>int</code>和<code>long</code>，编译器在对short、byte、char类型进行移位前，都会将其转换为int类型再操作。</li>
</ul>
<h4 id="–-continue、break-和-return-的区别是什么？"><a href="#–-continue、break-和-return-的区别是什么？" class="headerlink" title="– continue、break 和 return 的区别是什么？"></a>– continue、break 和 return 的区别是什么？</h4><ol>
<li><code>continue</code>：指跳出当前的这一次循环，继续下一次循环。</li>
<li><code>break</code>：指跳出整个循环体，继续执行循环下面的语句。</li>
<li><code>return</code> 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：<ul>
<li><code>return;</code>：直接使用 return 结束方法执行，用于没有返回值函数的方法</li>
<li><code>return value;</code>：return 一个特定值，用于有返回值函数的方法</li>
</ul>
</li>
</ol>
<h3 id="【基本数据类型】"><a href="#【基本数据类型】" class="headerlink" title="【基本数据类型】"></a>【基本数据类型】</h3><h4 id="–-Java-中有-8-种基本数据类型"><a href="#–-Java-中有-8-种基本数据类型" class="headerlink" title="– Java 中有 8 种基本数据类型"></a>– Java 中有 8 种基本数据类型</h4><ul>
<li>6 种数字类型：<ul>
<li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li>
<li>2 种浮点型：<code>float</code>、<code>double</code></li>
</ul>
</li>
<li>1 种字符类型：<code>char</code></li>
<li>1 种布尔型：<code>boolean</code>。</li>
</ul>
<h4 id="–-基本类型和包装类型的区别？"><a href="#–-基本类型和包装类型的区别？" class="headerlink" title="– 基本类型和包装类型的区别？"></a>– 基本类型和包装类型的区别？</h4><p>八种基本类型都有对应的包装类分别为：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</p>
<ul>
<li><p>除了定义一些常量和局部变量之外，我们在其他地方比如<strong>方法参数、对象属性</strong>中很少会使用基本类型<strong>来定义变量</strong>。并且，<strong>包装类型</strong>可<strong>用于泛型</strong>，而基本类型不可以。</p>
</li>
<li><p><strong>基本数据类型</strong>：<strong>局部变量</strong>存放在JVM<strong>栈</strong>的局部变量表中，<strong>成员变量</strong>存放在<strong>堆</strong>中。</p>
<p><strong>包装类型</strong>属于<strong>对象</strong>类型，我们知道几乎所有对象实例都存在于<strong>堆</strong>中。</p>
</li>
<li><p><strong>占用空间</strong>：基本数据类型占用的空间往往非常小。</p>
</li>
<li><p><strong>默认值</strong>：成员变量<strong>包装类</strong>型不赋值就是 <strong>null</strong> ，而<strong>基本类型有默认值</strong>且不是 null。</p>
</li>
<li><p><strong>比较方式</strong>：基本数据类型 <code>==</code>，整型包装类对象 <code>equals()</code></p>
</li>
</ul>
<h4 id="–-包装类型的缓存机制了解么？"><a href="#–-包装类型的缓存机制了解么？" class="headerlink" title="– 包装类型的缓存机制了解么？"></a>– 包装类型的缓存机制了解么？</h4><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<h4 id="–-自动装箱与拆箱了解吗？原理是什么？"><a href="#–-自动装箱与拆箱了解吗？原理是什么？" class="headerlink" title="– 自动装箱与拆箱了解吗？原理是什么？"></a>– 自动装箱与拆箱了解吗？原理是什么？</h4><ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来； <code>valueOf()</code>方法</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型； <code>xxxValue()</code>方法</li>
<li><code>Integer i = 10 等价于 Integer i = Integer.valueOf(10)</code><br><code>int n = i 等价于 int n = i.intValue();</code></li>
<li>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</li>
</ul>
<h4 id="–-为什么浮点数运算的时候会有精度丢失的风险？"><a href="#–-为什么浮点数运算的时候会有精度丢失的风险？" class="headerlink" title="– 为什么浮点数运算的时候会有精度丢失的风险？"></a>– 为什么浮点数运算的时候会有精度丢失的风险？</h4><p>计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。</p>
<h4 id="–-如何解决浮点数运算的精度丢失问题？"><a href="#–-如何解决浮点数运算的精度丢失问题？" class="headerlink" title="– 如何解决浮点数运算的精度丢失问题？"></a>– 如何解决浮点数运算的精度丢失问题？</h4><p><code>BigDecimal</code></p>
<h4 id="–-超过-long-整型的数据应该如何表示？"><a href="#–-超过-long-整型的数据应该如何表示？" class="headerlink" title="– 超过 long 整型的数据应该如何表示？"></a>– 超过 long 整型的数据应该如何表示？</h4><p><code>BigInteger</code></p>
<h3 id="【变量】"><a href="#【变量】" class="headerlink" title="【变量】"></a>【变量】</h3><h4 id="–-成员变量与局部变量的区别？"><a href="#–-成员变量与局部变量的区别？" class="headerlink" title="– 成员变量与局部变量的区别？"></a>– 成员变量与局部变量的区别？</h4><ul>
<li><p><strong>语法形式</strong>：</p>
<p>成员变量是<strong>属于类</strong>的，而局部变量是<strong>在代码块或方法中定义的变量或是方法的参数</strong>；</p>
<p>成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</p>
</li>
<li><p><strong>存储方式</strong>：</p>
<p>如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而<strong>对象存在于堆内存，局部变量则存在于栈内存</strong>。</p>
</li>
<li><p><strong>生存时间</strong>：</p>
<p>成员变量是对象的一部分，它<strong>随着对象的创建而存在</strong>，</p>
<p>而局部变量随着方法的调用而自动生成，<strong>随着方法的调用结束而消亡</strong>。</p>
</li>
<li><p><strong>默认值</strong>：</p>
<p>成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值 (一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值) ；</p>
<p>而<strong>局部变量则不会自动赋值</strong>；</p>
</li>
</ul>
<h4 id="–-字符型常量和字符串常量的区别"><a href="#–-字符型常量和字符串常量的区别" class="headerlink" title="– 字符型常量和字符串常量的区别?"></a>– 字符型常量和字符串常量的区别?</h4><ul>
<li><p>形式 : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。</p>
</li>
<li><p>含义 : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。</p>
</li>
<li><p>占内存大小：字符常量只占 2 个字节; 字符串常量占若干个字节。</p>
</li>
<li><p>注意 char 在 Java 中占两个字节。</p>
</li>
</ul>
<h3 id="【方法】"><a href="#【方法】" class="headerlink" title="【方法】"></a>【方法】</h3><h4 id="–-静态方法为什么不能调用非静态成员"><a href="#–-静态方法为什么不能调用非静态成员" class="headerlink" title="– 静态方法为什么不能调用非静态成员?"></a>– 静态方法为什么不能调用非静态成员?</h4><ul>
<li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li>
<li>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li>
</ul>
<h4 id="–-静态方法和实例方法有何不同？"><a href="#–-静态方法和实例方法有何不同？" class="headerlink" title="– 静态方法和实例方法有何不同？"></a>– 静态方法和实例方法有何不同？</h4><ol>
<li><strong>调用方式</strong>：在外部调用静态方法时，可以使用 类名.方法名 的方式，也可以使用 对象.方法名 的方式，而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象 。</li>
<li><strong>访问类成员是否存在限制</strong> ：静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</li>
</ol>
<h4 id="–-重载和重写有什么区别？"><a href="#–-重载和重写有什么区别？" class="headerlink" title="– 重载和重写有什么区别？"></a>– 重载和重写有什么区别？</h4><ul>
<li><p><strong>重载</strong></p>
<p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p>
</li>
<li><p><strong>重写</strong></p>
<p>发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<ol>
<li><p>方法名、参数列表必须相同，子类方法<strong>返回值类型</strong>应比父类方法返回值类型<strong>更小或相等</strong>，抛出的<strong>异常范围小于等于</strong>父类，<strong>访问修饰符范围大于等于</strong>父类。</p>
<p>如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p>
</li>
<li><p>如果父类方法访问修饰符为 <strong><code>private/final/static</code></strong> 则子类就<strong>不能重写</strong>该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</p>
</li>
<li><p>构造方法无法被重写</p>
</li>
</ol>
<p><strong>方法的重写要遵循“两同两小一大</strong></p>
</li>
</ul>
<h4 id="–-什么是可变长参数？"><a href="#–-什么是可变长参数？" class="headerlink" title="– 什么是可变长参数？"></a>– 什么是可变长参数？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">   <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这样方法就可以接受 0 个或者多个参数</li>
<li>可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。</li>
<li>方法重载会优先匹配固定参数</li>
</ul>
<h2 id="Java基础常见面试题-中"><a href="#Java基础常见面试题-中" class="headerlink" title="Java基础常见面试题(中)"></a>Java基础常见面试题(中)</h2><h3 id="【面向对象基础】"><a href="#【面向对象基础】" class="headerlink" title="【面向对象基础】"></a>【面向对象基础】</h3><h4 id="–-面向对象和面向过程的区别"><a href="#–-面向对象和面向过程的区别" class="headerlink" title="– 面向对象和面向过程的区别"></a>– 面向对象和面向过程的区别</h4><p>主要区别在于<strong>解决问题的方式</strong>不同：</p>
<ul>
<li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li>
<li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li>
</ul>
<p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p>
<h4 id="–-面向过程性能比面向对象高？"><a href="#–-面向过程性能比面向对象高？" class="headerlink" title="– 面向过程性能比面向对象高？"></a>– 面向过程性能比面向对象高？</h4><p><strong>面向过程性能比面向对象高</strong>。</p>
<p>因为<strong>类调用时需要实例化</strong>，开销较大，<strong>比较消耗资源</strong>，所以当性能是最重要的考量因素的的时候，比如单片机、嵌入式开发、Linux&#x2F;Unix等一般采用面向过程开发。</p>
<p>但这并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java性能差的主要原因并不是因为它是面向对象语言，而是<strong>Java是半编译语言，最终的执行代码并不是可以直接被CPU执行的二进制机械码</strong>。</p>
<p>而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其他一些面向过程的脚本语言性能也<strong>并不一定</strong>比Java好。</p>
<h4 id="–-创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#–-创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="– 创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>– 创建一个对象用什么运算符?对象实体与对象引用有何不同?</h4><p><strong>new</strong> 运算符。</p>
<p>new 创建对象实例 (对象实例在堆内存中)，<strong>对象引用</strong>指向<strong>对象实例</strong> (对象引用存放在栈内存中)。</p>
<ul>
<li>一个对象引用可以指向 0 个或 1 个对象；</li>
<li>一个对象可以有 n 个引用指向它；</li>
</ul>
<h4 id="–-对象的相等和引用相等的区别"><a href="#–-对象的相等和引用相等的区别" class="headerlink" title="– 对象的相等和引用相等的区别"></a>– 对象的相等和引用相等的区别</h4><ul>
<li><strong>对象的相等</strong>一般比较的是内存中<strong>存放的内容</strong>是否相等。</li>
<li><strong>引用相等</strong>一般比较的是他们<strong>指向的内存地址</strong>是否相等。</li>
</ul>
<h4 id="–-如果一个类没有声明构造方法，该程序能正确执行吗"><a href="#–-如果一个类没有声明构造方法，该程序能正确执行吗" class="headerlink" title="– 如果一个类没有声明构造方法，该程序能正确执行吗?"></a>– 如果一个类没有声明构造方法，该程序能正确执行吗?</h4><p><strong>可以</strong>执行！</p>
<p><strong>构造方法</strong>是一种特殊的方法，主要作用是完成对象的初始化工作。</p>
<p>一个类即使没有声明构造方法也会有<strong>默认的不带参数的构造方法</strong>。如果我们自己添加了类的构造方法 (无论是否有参)，Java 就不会添加默认的无参数的构造方法了。</p>
<p>这也是为什么我们在创建对象的时候后面要加一个括号 (因为要调用无参的构造方法)。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来 (无论是否用到)，因为这可以帮助我们在创建对象的时候少踩坑。</p>
<h4 id="–-构造方法有哪些特点？是否可被-override"><a href="#–-构造方法有哪些特点？是否可被-override" class="headerlink" title="– 构造方法有哪些特点？是否可被 override?"></a>– 构造方法有哪些特点？是否可被 override?</h4><ul>
<li>名字与类名相同。</li>
<li>没有返回值，但不能用 void 声明构造函数。</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ul>
<p>构造方法不能被 override (重写),但是可以 overload (重载)。</p>
<h3 id="【面向对象三大特征】"><a href="#【面向对象三大特征】" class="headerlink" title="【面向对象三大特征】"></a>【面向对象三大特征】</h3><h4 id="–-封装"><a href="#–-封装" class="headerlink" title="– 封装"></a>– 封装</h4><p><strong>指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。</strong>但是可以提供一些可以被外界访问的方法来操作属性。如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p>
<h4 id="–-继承"><a href="#–-继承" class="headerlink" title="– 继承"></a>– 继承</h4><p>不同类型的对象，相互之间经常有一定数量的共同点。同时，每一个对象还定义了额外的特性使得他们与众不同。</p>
<p><strong>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。</strong>通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<p><strong>注意：</strong></p>
<ol>
<li>子类拥有父类对象所有的属性和方法 (包括私有属性和私有方法)，但是<strong>父类中的私有属性和方法子类是无法访问</strong>，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。(以后介绍)。</li>
</ol>
<h4 id="–-多态"><a href="#–-多态" class="headerlink" title="– 多态"></a>– 多态</h4><p><strong>表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</strong></p>
<p><strong>特点:</strong></p>
<ul>
<li>对象类型和引用类型之间具有<strong>继承</strong> (类) &#x2F; 实现(接口)的<strong>关系</strong>；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序<strong>运行期间才能确定</strong>；</li>
<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
<h4 id="–-接口和抽象类有什么共同点和区别？"><a href="#–-接口和抽象类有什么共同点和区别？" class="headerlink" title="– 接口和抽象类有什么共同点和区别？"></a>– 接口和抽象类有什么共同点和区别？</h4><p><strong>共同点</strong>：</p>
<ul>
<li>都不能<strong>被实例化</strong>。</li>
<li>都可以<strong>包含抽象方法</strong>。</li>
<li>都可以<strong>有默认实现的方法</strong>（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</li>
</ul>
<p><strong>区别</strong>：</p>
<ul>
<li><strong>接口</strong>主要用于对<strong>类</strong>的<strong>行为</strong>进行<strong>约束</strong>，你实现了某个接口就具有了对应的行为。<strong>抽象类</strong>主要用于<strong>代码复用</strong>，<strong>强调的是所属关系</strong>。</li>
<li>一个类只能继承一个类，但是可以实现多个接口 (<strong>类的单继承，接口多继承</strong>)。</li>
<li><strong>接口</strong>中的<strong>成员变量</strong>只能是 <code>public static final</code> 类型的，<strong>不能被修改且必须有初始值</strong>，而<strong>抽象类</strong>的<strong>成员变量</strong>默认 <code>default</code>，<strong>可在子类中被重新定义，也可被重新赋值</strong>。</li>
</ul>
<h4 id="–-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><a href="#–-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？" class="headerlink" title="– 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"></a>– 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h4><ul>
<li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。（父类 <code>Object</code> 的 <code>clone()</code> 方法）</li>
<li><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。(重写了父类<code>Object</code> 的<code>clone(</code>)方法)</li>
</ul>
<p><strong>那什么是引用拷贝呢？</strong> 简单来说，<strong>引用拷贝</strong>就是两个不同的引用指向同一个对象。</p>
<p><img src="C:\Users\lyl\Desktop\其他\photo\shallow&deep-copy.png"></p>
<h3 id="【Object】"><a href="#【Object】" class="headerlink" title="【Object】"></a>【Object】</h3><h4 id="–-Object-类的常见方法有哪些？"><a href="#–-Object-类的常见方法有哪些？" class="headerlink" title="– Object 类的常见方法有哪些？"></a>– Object 类的常见方法有哪些？</h4><p>Object 类是一个特殊的类，是<strong>所有类的父类</strong>。它主要提供了以下 11 个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure>

</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">lyl_L-</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://sunrisel135.github.io/blog_lyl/2024/03/05/Java%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/">https://sunrisel135.github.io/blog_lyl/2024/03/05/Java面试-Java基础/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">本文声明: </span><span class="post-copyright-info">内容均为个人总结，仅供个人参考！</span></div></div></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/blog_lyl/2024/03/06/%E5%AD%90%E3%80%81%E7%88%B6%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/"><i class="fas fa-angle-left">&nbsp;</i><span>子、父类加载顺序</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/blog_lyl/2024/03/04/Hexo+github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"><span>Hexo搭建博客</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2024 By lyl_L-</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/copy.js"></script><!--script(src=url)--></body></html>