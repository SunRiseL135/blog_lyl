<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java面试-Java基础"><meta name="keywords" content="面试"><meta name="author" content="lyl_L-,undefined"><meta name="copyright" content="lyl_L-"><title>Java面试-Java基础【lyl'blog】</title><link rel="stylesheet" href="/blog_lyl/css/fan.css"><link rel="stylesheet" href="/blog_lyl/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/blog_lyl/L.ico"><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- script(src=url_for("/js/mathjax/mathjax.js"))--><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/blog_lyl/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: {},
  valine: {},
  twikoo: {},
}</script><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/blog_lyl/atom.xml" title="lyl'blog" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-%E4%B8%8A"><span class="toc-number">1.</span> <span class="toc-text">Java基础常见面试题(上)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-%E4%B8%AD"><span class="toc-number">2.</span> <span class="toc-text">Java基础常见面试题(中)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E3%80%91"><span class="toc-number">2.1.</span> <span class="toc-text">【面向对象基础】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.1.</span> <span class="toc-text">– 面向对象和面向过程的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E6%80%A7%E8%83%BD%E6%AF%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%EF%BC%9F"><span class="toc-number">2.1.2.</span> <span class="toc-text">– 面向过程性能比面向对象高？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%94%A8%E4%BB%80%E4%B9%88%E8%BF%90%E7%AE%97%E7%AC%A6-%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BD%93%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C"><span class="toc-number">2.1.3.</span> <span class="toc-text">– 创建一个对象用什么运算符?对象实体与对象引用有何不同?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9B%B8%E7%AD%89%E5%92%8C%E5%BC%95%E7%94%A8%E7%9B%B8%E7%AD%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.4.</span> <span class="toc-text">– 对象的相等和引用相等的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%B2%A1%E6%9C%89%E5%A3%B0%E6%98%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%8C%E8%AF%A5%E7%A8%8B%E5%BA%8F%E8%83%BD%E6%AD%A3%E7%A1%AE%E6%89%A7%E8%A1%8C%E5%90%97"><span class="toc-number">2.1.5.</span> <span class="toc-text">– 如果一个类没有声明构造方法，该程序能正确执行吗?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9%EF%BC%9F%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%AB-override"><span class="toc-number">2.1.6.</span> <span class="toc-text">– 构造方法有哪些特点？是否可被 override?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%E3%80%91"><span class="toc-number">2.2.</span> <span class="toc-text">【面向对象三大特征】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E5%B0%81%E8%A3%85"><span class="toc-number">2.2.1.</span> <span class="toc-text">– 封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E7%BB%A7%E6%89%BF"><span class="toc-number">2.2.2.</span> <span class="toc-text">– 继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E5%A4%9A%E6%80%81"><span class="toc-number">2.2.3.</span> <span class="toc-text">– 多态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B1%E5%90%8C%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.2.4.</span> <span class="toc-text">– 接口和抽象类有什么共同点和区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="toc-number">2.2.5.</span> <span class="toc-text">– 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-Object-%E7%B1%BB%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.2.6.</span> <span class="toc-text">– Object 类的常见方法有哪些？</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/blog_lyl/images/Le.png"></div><div class="author-info-name">lyl_L-</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/SunRiseL135" target="_blank">GitHub<i class="icon-dot bg-color5"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/blog_lyl/archives"><span class="pull-top">日志</span><span class="pull-bottom">6</span></a><a class="author-info-articles-tags article-meta" href="/blog_lyl/tags"><span class="pull-top">标签</span><span class="pull-bottom">6</span></a><a class="author-info-articles-categories article-meta" href="/blog_lyl/categories"><span class="pull-top">分类</span><span class="pull-bottom">3</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/blog_lyl">首页</a><a class="menu-item" href="/blog_lyl/tags">标签</a><a class="menu-item" href="/blog_lyl/categories">分类</a><a class="menu-item" href="/blog_lyl/archives">归档</a><a class="menu-item" href="/blog_lyl/about">关于</a></nav><div class="right-info"><a class="title-name" href="/blog_lyl/">lyl'blog</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">Java面试-Java基础</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2024-03-05 | 更新于 2024-03-07</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/blog_lyl/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/blog_lyl/tags/%E9%9D%A2%E8%AF%95/">面试</a></div></div></div><div class="main-content"><p>持续更新。。。</p>
<span id="more"></span>



<h2 id="Java基础常见面试题-上"><a href="#Java基础常见面试题-上" class="headerlink" title="Java基础常见面试题(上)"></a>Java基础常见面试题(上)</h2><h2 id="Java基础常见面试题-中"><a href="#Java基础常见面试题-中" class="headerlink" title="Java基础常见面试题(中)"></a>Java基础常见面试题(中)</h2><h3 id="【面向对象基础】"><a href="#【面向对象基础】" class="headerlink" title="【面向对象基础】"></a>【面向对象基础】</h3><h4 id="–-面向对象和面向过程的区别"><a href="#–-面向对象和面向过程的区别" class="headerlink" title="– 面向对象和面向过程的区别"></a>– 面向对象和面向过程的区别</h4><p>主要区别在于<strong>解决问题的方式</strong>不同：</p>
<ul>
<li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li>
<li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li>
</ul>
<p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p>
<h4 id="–-面向过程性能比面向对象高？"><a href="#–-面向过程性能比面向对象高？" class="headerlink" title="– 面向过程性能比面向对象高？"></a>– 面向过程性能比面向对象高？</h4><p><strong>面向过程性能比面向对象高</strong>。</p>
<p>因为<strong>类调用时需要实例化</strong>，开销较大，<strong>比较消耗资源</strong>，所以当性能是最重要的考量因素的的时候，比如单片机、嵌入式开发、Linux&#x2F;Unix等一般采用面向过程开发。</p>
<p>但这并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java性能差的主要原因并不是因为它是面向对象语言，而是<strong>Java是半编译语言，最终的执行代码并不是可以直接被CPU执行的二进制机械码</strong>。</p>
<p>而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其他一些面向过程的脚本语言性能也<strong>并不一定</strong>比Java好。</p>
<h4 id="–-创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#–-创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="– 创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>– 创建一个对象用什么运算符?对象实体与对象引用有何不同?</h4><p><strong>new</strong> 运算符。</p>
<p>new 创建对象实例 (对象实例在堆内存中)，<strong>对象引用</strong>指向<strong>对象实例</strong> (对象引用存放在栈内存中)。</p>
<ul>
<li>一个对象引用可以指向 0 个或 1 个对象；</li>
<li>一个对象可以有 n 个引用指向它；</li>
</ul>
<h4 id="–-对象的相等和引用相等的区别"><a href="#–-对象的相等和引用相等的区别" class="headerlink" title="– 对象的相等和引用相等的区别"></a>– 对象的相等和引用相等的区别</h4><ul>
<li><strong>对象的相等</strong>一般比较的是内存中<strong>存放的内容</strong>是否相等。</li>
<li><strong>引用相等</strong>一般比较的是他们<strong>指向的内存地址</strong>是否相等。</li>
</ul>
<h4 id="–-如果一个类没有声明构造方法，该程序能正确执行吗"><a href="#–-如果一个类没有声明构造方法，该程序能正确执行吗" class="headerlink" title="– 如果一个类没有声明构造方法，该程序能正确执行吗?"></a>– 如果一个类没有声明构造方法，该程序能正确执行吗?</h4><p><strong>可以</strong>执行！</p>
<p><strong>构造方法</strong>是一种特殊的方法，主要作用是完成对象的初始化工作。</p>
<p>一个类即使没有声明构造方法也会有<strong>默认的不带参数的构造方法</strong>。如果我们自己添加了类的构造方法 (无论是否有参)，Java 就不会添加默认的无参数的构造方法了。</p>
<p>这也是为什么我们在创建对象的时候后面要加一个括号 (因为要调用无参的构造方法)。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来 (无论是否用到)，因为这可以帮助我们在创建对象的时候少踩坑。</p>
<h4 id="–-构造方法有哪些特点？是否可被-override"><a href="#–-构造方法有哪些特点？是否可被-override" class="headerlink" title="– 构造方法有哪些特点？是否可被 override?"></a>– 构造方法有哪些特点？是否可被 override?</h4><ul>
<li>名字与类名相同。</li>
<li>没有返回值，但不能用 void 声明构造函数。</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ul>
<p>构造方法不能被 override (重写),但是可以 overload (重载)。</p>
<h3 id="【面向对象三大特征】"><a href="#【面向对象三大特征】" class="headerlink" title="【面向对象三大特征】"></a>【面向对象三大特征】</h3><h4 id="–-封装"><a href="#–-封装" class="headerlink" title="– 封装"></a>– 封装</h4><p><strong>指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。</strong>但是可以提供一些可以被外界访问的方法来操作属性。如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p>
<h4 id="–-继承"><a href="#–-继承" class="headerlink" title="– 继承"></a>– 继承</h4><p>不同类型的对象，相互之间经常有一定数量的共同点。同时，每一个对象还定义了额外的特性使得他们与众不同。</p>
<p><strong>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。</strong>通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<p><strong>注意：</strong></p>
<ol>
<li>子类拥有父类对象所有的属性和方法 (包括私有属性和私有方法)，但是<strong>父类中的私有属性和方法子类是无法访问</strong>，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。(以后介绍)。</li>
</ol>
<h4 id="–-多态"><a href="#–-多态" class="headerlink" title="– 多态"></a>– 多态</h4><p><strong>表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</strong></p>
<p><strong>特点:</strong></p>
<ul>
<li>对象类型和引用类型之间具有<strong>继承</strong> (类) &#x2F; 实现(接口)的<strong>关系</strong>；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序<strong>运行期间才能确定</strong>；</li>
<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
<h4 id="–-接口和抽象类有什么共同点和区别？"><a href="#–-接口和抽象类有什么共同点和区别？" class="headerlink" title="– 接口和抽象类有什么共同点和区别？"></a>– 接口和抽象类有什么共同点和区别？</h4><p><strong>共同点</strong>：</p>
<ul>
<li>都不能<strong>被实例化</strong>。</li>
<li>都可以<strong>包含抽象方法</strong>。</li>
<li>都可以<strong>有默认实现的方法</strong>（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</li>
</ul>
<p><strong>区别</strong>：</p>
<ul>
<li><strong>接口</strong>主要用于对<strong>类</strong>的<strong>行为</strong>进行<strong>约束</strong>，你实现了某个接口就具有了对应的行为。<strong>抽象类</strong>主要用于<strong>代码复用</strong>，<strong>强调的是所属关系</strong>。</li>
<li>一个类只能继承一个类，但是可以实现多个接口 (<strong>类的单继承，接口多继承</strong>)。</li>
<li><strong>接口</strong>中的<strong>成员变量</strong>只能是 <code>public static final</code> 类型的，<strong>不能被修改且必须有初始值</strong>，而<strong>抽象类</strong>的<strong>成员变量</strong>默认 <code>default</code>，<strong>可在子类中被重新定义，也可被重新赋值</strong>。</li>
</ul>
<h4 id="–-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><a href="#–-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？" class="headerlink" title="– 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"></a>– 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h4><ul>
<li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。（父类 <code>Object</code> 的 <code>clone()</code> 方法）</li>
<li><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。(重写了父类<code>Object</code> 的<code>clone(</code>)方法)</li>
</ul>
<p><strong>那什么是引用拷贝呢？</strong> 简单来说，<strong>引用拷贝</strong>就是两个不同的引用指向同一个对象。</p>
<p><img src="C:\Users\lyl\Desktop\其他\photo\shallow&deep-copy.png"></p>
<p>【Object】</p>
<h4 id="–-Object-类的常见方法有哪些？"><a href="#–-Object-类的常见方法有哪些？" class="headerlink" title="– Object 类的常见方法有哪些？"></a>– Object 类的常见方法有哪些？</h4><p>Object 类是一个特殊的类，是<strong>所有类的父类</strong>。它主要提供了以下 11 个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure>

</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">lyl_L-</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://sunrisel135.github.io/blog_lyl/2024/03/05/Java%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/">https://sunrisel135.github.io/blog_lyl/2024/03/05/Java面试-Java基础/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">本文声明: </span><span class="post-copyright-info">内容均为个人总结，仅供个人参考！</span></div></div></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/blog_lyl/2024/03/06/%E5%AD%90%E3%80%81%E7%88%B6%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/"><i class="fas fa-angle-left">&nbsp;</i><span>子、父类加载顺序</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/blog_lyl/2024/03/04/Hexo+github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"><span>Hexo搭建博客</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2024 By lyl_L-</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/copy.js"></script><!--script(src=url)--></body></html>