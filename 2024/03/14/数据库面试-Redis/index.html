<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="数据库面试-Redis"><meta name="keywords" content="面试"><meta name="author" content="lyl_L-,undefined"><meta name="copyright" content="lyl_L-"><title>数据库面试-Redis【lyl'blog】</title><link rel="stylesheet" href="/blog_lyl/css/fan.css"><link rel="stylesheet" href="/blog_lyl/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/blog_lyl/L.ico"><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- script(src=url_for("/js/mathjax/mathjax.js"))--><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/blog_lyl/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: {},
  valine: {},
  twikoo: {},
}</script><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/blog_lyl/atom.xml" title="lyl'blog" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Redis-%E5%9F%BA%E7%A1%80%E3%80%91"><span class="toc-number">1.</span> <span class="toc-text">【Redis 基础】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E4%BB%80%E4%B9%88%E6%98%AF-Redis%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">– 什么是 Redis？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-Redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">– Redis 为什么这么快？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E8%AF%B4%E4%B8%80%E4%B8%8B-Redis-%E5%92%8C-Memcached-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%85%B1%E5%90%8C%E7%82%B9"><span class="toc-number">1.3.</span> <span class="toc-text">– 说一下 Redis 和 Memcached 的区别和共同点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-Redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">– 为什么要用 Redis&#x2F;为什么要用缓存？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">– 常见的缓存读写策略有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E4%BB%80%E4%B9%88%E6%98%AF-Redis-Module%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">– 什么是 Redis Module？有什么用？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Redis-%E5%BA%94%E7%94%A8%E3%80%91"><span class="toc-number">2.</span> <span class="toc-text">【Redis 应用】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-Redis-%E9%99%A4%E4%BA%86%E5%81%9A%E7%BC%93%E5%AD%98%EF%BC%8C%E8%BF%98%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F%E2%98%85"><span class="toc-number">2.1.</span> <span class="toc-text">– Redis 除了做缓存，还能做什么？★</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8E-Redis-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">– 如何基于 Redis 实现分布式锁？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-Redis-%E5%8F%AF%E4%BB%A5%E5%81%9A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%88%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">– Redis 可以做消息队列么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-Redis-%E5%8F%AF%E4%BB%A5%E5%81%9A%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%B9%88%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">– Redis 可以做搜索引擎么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%90Redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%91"><span class="toc-number">2.5.</span> <span class="toc-text">【Redis 数据类型】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-Redis-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.6.</span> <span class="toc-text">– Redis 常用的数据类型有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-String-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.7.</span> <span class="toc-text">– String 的应用场景有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-String-%E8%BF%98%E6%98%AF-Hash-%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE%E6%9B%B4%E5%A5%BD%E5%91%A2%EF%BC%9F"><span class="toc-number">2.8.</span> <span class="toc-text">– String 还是 Hash 存储对象数据更好呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E8%B4%AD%E7%89%A9%E8%BD%A6%E4%BF%A1%E6%81%AF%E7%94%A8-String-%E8%BF%98%E6%98%AF-Hash-%E5%AD%98%E5%82%A8%E6%9B%B4%E5%A5%BD%E5%91%A2"><span class="toc-number">2.9.</span> <span class="toc-text">– 购物车信息用 String 还是 Hash 存储更好呢?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E4%BD%BF%E7%94%A8-Redis-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%8E%92%E8%A1%8C%E6%A6%9C%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-number">2.10.</span> <span class="toc-text">– 使用 Redis 实现一个排行榜怎么做？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-Redis-%E7%9A%84%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E5%BA%95%E5%B1%82%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E8%B7%B3%E8%A1%A8%EF%BC%8C%E8%80%8C%E4%B8%8D%E7%94%A8%E5%B9%B3%E8%A1%A1%E6%A0%91%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E6%88%96%E8%80%85-B-%E6%A0%91%EF%BC%9F"><span class="toc-number">2.11.</span> <span class="toc-text">– Redis 的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者 B+树？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-Set-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.12.</span> <span class="toc-text">–  Set 的应用场景是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E4%BD%BF%E7%94%A8-Set-%E5%AE%9E%E7%8E%B0%E6%8A%BD%E5%A5%96%E7%B3%BB%E7%BB%9F%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-number">2.13.</span> <span class="toc-text">– 使用 Set 实现抽奖系统怎么做？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%90Redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89%E3%80%91"><span class="toc-number">2.14.</span> <span class="toc-text">【Redis 持久化机制（重要）】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-RDB-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">2.15.</span> <span class="toc-text">– RDB 持久化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-AOF-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">2.16.</span> <span class="toc-text">– AOF 持久化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89%E3%80%91"><span class="toc-number">3.</span> <span class="toc-text">【Redis 线程模型（重要）】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-Redis-%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">– Redis 单线程模型了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-Redis6-0-%E4%B9%8B%E5%89%8D%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">– Redis6.0 之前为什么不使用多线程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-Redis6-0-%E4%B9%8B%E5%90%8E%E4%B8%BA%E4%BD%95%E5%BC%95%E5%85%A5%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">– Redis6.0 之后为何引入了多线程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-Redis-%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">3.4.</span> <span class="toc-text">– Redis 后台线程了解吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E3%80%91"><span class="toc-number">4.</span> <span class="toc-text">【Redis 内存管理】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-Redis-%E7%BB%99%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E6%9C%89%E5%95%A5%E7%94%A8%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">– Redis 给缓存数据设置过期时间有啥用？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E9%99%A4%E4%BA%86%E6%9C%89%E5%8A%A9%E4%BA%8E%E7%BC%93%E8%A7%A3%E5%86%85%E5%AD%98%E7%9A%84%E6%B6%88%E8%80%97%EF%BC%8C%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B6%E4%BB%96%E7%94%A8%E4%B9%88%EF%BC%9F"><span class="toc-number">4.1.1.</span> <span class="toc-text">过期时间除了有助于缓解内存的消耗，还有什么其他用么？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-Redis-%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E8%BF%87%E6%9C%9F%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">– Redis 是如何判断数据是否过期的呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E8%BF%87%E6%9C%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F%E2%98%86"><span class="toc-number">4.3.</span> <span class="toc-text">– 过期的数据的删除策略了解么？☆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-Redis-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">– Redis 内存淘汰机制了解么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Redis-%E4%BA%8B%E5%8A%A1%E3%80%91"><span class="toc-number">5.</span> <span class="toc-text">【Redis 事务】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E4%BB%80%E4%B9%88%E6%98%AF-Redis-%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">– 什么是 Redis 事务？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-Redis-%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%90%97%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">– Redis 事务支持原子性吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-Redis-%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81%E6%8C%81%E4%B9%85%E6%80%A7%E5%90%97%EF%BC%9F"><span class="toc-number">5.3.</span> <span class="toc-text">– Redis 事务支持持久性吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Redis-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89%E3%80%91"><span class="toc-number">6.</span> <span class="toc-text">【Redis 性能优化（重要）】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E4%BD%BF%E7%94%A8%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E5%87%8F%E5%B0%91%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93"><span class="toc-number">6.1.</span> <span class="toc-text">– 使用批量操作减少网络传输</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E5%8E%9F%E7%94%9F%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="toc-number">6.2.</span> <span class="toc-text">– 原生批量操作命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-Lua-%E8%84%9A%E6%9C%AC"><span class="toc-number">6.3.</span> <span class="toc-text">– Lua 脚本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E5%A4%A7%E9%87%8F-key-%E9%9B%86%E4%B8%AD%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98"><span class="toc-number">6.4.</span> <span class="toc-text">– 大量 key 集中过期问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-Redis-bigkey%EF%BC%88%E5%A4%A7-Key%EF%BC%89"><span class="toc-number">6.5.</span> <span class="toc-text">– Redis bigkey（大 Key）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-bigkey%EF%BC%9F"><span class="toc-number">6.5.1.</span> <span class="toc-text">什么是 bigkey？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-Redis-hotkey%EF%BC%88%E7%83%AD-Key%EF%BC%89"><span class="toc-number">6.6.</span> <span class="toc-text">– Redis hotkey（热 Key）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-hotkey%EF%BC%9F"><span class="toc-number">6.6.1.</span> <span class="toc-text">什么是 hotkey？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%8F%91%E7%8E%B0-hotkey%EF%BC%9F"><span class="toc-number">6.6.2.</span> <span class="toc-text">如何发现 hotkey？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-hotkey%EF%BC%9F"><span class="toc-number">6.6.3.</span> <span class="toc-text">如何解决 hotkey？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4%EF%BC%9F"><span class="toc-number">6.7.</span> <span class="toc-text">– 慢查询命令？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-Redis-%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87"><span class="toc-number">6.8.</span> <span class="toc-text">– Redis 内存碎片</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89-Redis-%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87"><span class="toc-number">6.8.1.</span> <span class="toc-text">什么是内存碎片?为什么会有 Redis 内存碎片?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89-Redis-%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87"><span class="toc-number">6.8.2.</span> <span class="toc-text">为什么会有 Redis 内存碎片?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B-Redis-%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E7%9A%84%E4%BF%A1%E6%81%AF%EF%BC%9F"><span class="toc-number">6.8.3.</span> <span class="toc-text">如何查看 Redis 内存碎片的信息？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%B8%85%E7%90%86-Redis-%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%EF%BC%9F"><span class="toc-number">6.8.4.</span> <span class="toc-text">如何清理 Redis 内存碎片？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Redis-%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89%E3%80%91"><span class="toc-number">7.</span> <span class="toc-text">【Redis 生产问题（重要）】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">7.1.</span> <span class="toc-text">– 缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%9F"><span class="toc-number">7.1.1.</span> <span class="toc-text">解决办法？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">7.2.</span> <span class="toc-text">– 缓存击穿</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%9F-1"><span class="toc-number">7.2.1.</span> <span class="toc-text">解决办法？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">7.3.</span> <span class="toc-text">– 缓存穿透和缓存击穿区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">7.4.</span> <span class="toc-text">– 缓存雪崩</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">7.4.1.</span> <span class="toc-text">缓存预热如何实现？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E5%92%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">7.5.</span> <span class="toc-text">– 缓存雪崩和缓存击穿有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="toc-number">7.6.</span> <span class="toc-text">– 如何保证缓存和数据库数据的一致性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%AF%BC%E8%87%B4-Redis-%E9%98%BB%E5%A1%9E%EF%BC%9F"><span class="toc-number">7.7.</span> <span class="toc-text">– 哪些情况可能会导致 Redis 阻塞？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E3%80%91"><span class="toc-number">8.</span> <span class="toc-text">【重要知识点】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-3%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5%E8%AF%A6%E8%A7%A3"><span class="toc-number">8.1.</span> <span class="toc-text">– 3种常用的缓存读写策略详解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%80%93%E5%9C%A8%E5%86%99%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%85%88%E5%88%A0%E9%99%A4-cache-%EF%BC%8C%E5%90%8E%E6%9B%B4%E6%96%B0-db-%E4%B9%88%EF%BC%9F"><span class="toc-number">8.1.1.</span> <span class="toc-text">–在写数据的过程中，可以先删除 cache ，后更新 db 么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%80%93%E5%9C%A8%E5%86%99%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%85%88%E6%9B%B4%E6%96%B0-db%EF%BC%8C%E5%90%8E%E5%88%A0%E9%99%A4-cache-%E5%B0%B1%E6%B2%A1%E6%9C%89%E9%97%AE%E9%A2%98%E4%BA%86%E4%B9%88%EF%BC%9F"><span class="toc-number">8.1.2.</span> <span class="toc-text">–在写数据的过程中，先更新 db，后删除 cache 就没有问题了么？</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/blog_lyl/images/Java.png"></div><div class="author-info-name">lyl_L-</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/SunRiseL135" target="_blank">GitHub<i class="icon-dot bg-color2"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/blog_lyl/archives"><span class="pull-top">日志</span><span class="pull-bottom">17</span></a><a class="author-info-articles-tags article-meta" href="/blog_lyl/tags"><span class="pull-top">标签</span><span class="pull-bottom">4</span></a><a class="author-info-articles-categories article-meta" href="/blog_lyl/categories"><span class="pull-top">分类</span><span class="pull-bottom">12</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/blog_lyl">首页</a><a class="menu-item" href="/blog_lyl/tags">标签</a><a class="menu-item" href="/blog_lyl/categories">分类</a><a class="menu-item" href="/blog_lyl/archives">归档</a><a class="menu-item" href="/blog_lyl/about">关于</a></nav><div class="right-info"><a class="title-name" href="/blog_lyl/">lyl'blog</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">数据库面试-Redis</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2024-03-14 | 更新于 2024-03-14</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/blog_lyl/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/blog_lyl/tags/%E9%9D%A2%E8%AF%95/">面试</a></div></div></div><div class="main-content"><p>持续补充…</p>
<span id="more"></span>



<h3 id="【Redis-基础】"><a href="#【Redis-基础】" class="headerlink" title="【Redis 基础】"></a>【Redis 基础】</h3><h4 id="–-什么是-Redis？"><a href="#–-什么是-Redis？" class="headerlink" title="– 什么是 Redis？"></a>– 什么是 Redis？</h4><p>Redis（REmote DIctionary Server）是一个<strong>基于 C 语言</strong>开发的<strong>开源 NoSQL</strong> 数据库（BSD 许可）。数据保存在内存中的（<strong>内存数据库，支持持久化</strong>），因此读写速度非常快，被广泛应用于分布式缓存方向。并且，Redis 存储的是 <strong>KV 键值对数据</strong>。</p>
<p>Redis 内置了<strong>多种数据类型</strong>实现（比如 String、Hash、Sorted Set、Bitmap、HyperLogLog、GEO）。并且，Redis 还支持事务、持久化、Lua 脚本、多种开箱即用的集群方案（Redis Sentinel、Redis Cluster）。</p>
<h4 id="–-Redis-为什么这么快？"><a href="#–-Redis-为什么这么快？" class="headerlink" title="– Redis 为什么这么快？"></a>– Redis 为什么这么快？</h4><p>Redis 基于内存，内存的访问速度是磁盘的上千倍；</p>
<p>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用（Redis 线程模式后面会详细介绍到）；</p>
<p>Redis 内置了多种优化过后的数据类型&#x2F;结构实现，性能非常高。</p>
<h4 id="–-说一下-Redis-和-Memcached-的区别和共同点"><a href="#–-说一下-Redis-和-Memcached-的区别和共同点" class="headerlink" title="– 说一下 Redis 和 Memcached 的区别和共同点"></a>– 说一下 Redis 和 Memcached 的区别和共同点</h4><p><strong>共同点</strong>：</p>
<ol>
<li>都是基于内存的数据库，一般都用来当做缓存使用。</li>
<li>都有过期策略。</li>
<li>两者的性能都非常高。</li>
</ol>
<p><strong>区别</strong>：</p>
<ol>
<li><strong>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</strong>。Redis 不仅仅支持简单的 k&#x2F;v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k&#x2F;v 数据类型。</li>
<li><strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memcached 把数据全部存在内存之中。</strong></li>
<li><strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</li>
<li><strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></li>
<li><strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。</strong></li>
<li><strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</strong> （Redis 6.0 针对网络数据的读写引入了多线程）</li>
<li><strong>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</strong></li>
<li>**Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</li>
</ol>
<h4 id="–-为什么要用-Redis-为什么要用缓存？"><a href="#–-为什么要用-Redis-为什么要用缓存？" class="headerlink" title="– 为什么要用 Redis&#x2F;为什么要用缓存？"></a>– 为什么要用 Redis&#x2F;为什么要用缓存？</h4><ul>
<li>高性能：高频数据且不会经常改变，那么就可以将该数据存在缓存中。操作缓存就是直接操作内存，所以速度相当快。</li>
<li>高并发：直接操作缓存能够承受的数据库请求数量远远大于直接访问数据库，所以可以考虑把数据库中的部分数据转移到缓存中去，这样一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。</li>
</ul>
<h4 id="–-常见的缓存读写策略有哪些？"><a href="#–-常见的缓存读写策略有哪些？" class="headerlink" title="– 常见的缓存读写策略有哪些？"></a>– 常见的缓存读写策略有哪些？</h4><h4 id="–-什么是-Redis-Module？有什么用？"><a href="#–-什么是-Redis-Module？有什么用？" class="headerlink" title="– 什么是 Redis Module？有什么用？"></a>– 什么是 Redis Module？有什么用？</h4><p> 4.0 版本开始，支持通过 Module 来扩展其功能以满足特殊的需求。这些 Module 以动态链接库（so 文件）的形式被加载到 Redis 中，这是一种非常灵活的动态扩展功能的实现方式。</p>
<h3 id="【Redis-应用】"><a href="#【Redis-应用】" class="headerlink" title="【Redis 应用】"></a>【Redis 应用】</h3><h4 id="–-Redis-除了做缓存，还能做什么？★"><a href="#–-Redis-除了做缓存，还能做什么？★" class="headerlink" title="– Redis 除了做缓存，还能做什么？★"></a>– Redis 除了做缓存，还能做什么？★</h4><ul>
<li><strong>分布式锁</strong>：通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，都是基于 Redisson 来实现分布式锁。<a target="_blank" rel="noopener" href="https://javaguide.cn/distributed-system/distributed-lock.html">分布式锁详解</a></li>
<li><strong>限流</strong>：一般是通过 Redis + Lua 脚本的方式来实现限流。</li>
<li><strong>消息队列</strong>：Redis 自带的 List 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</li>
<li><strong>延时队列</strong>：Redisson 内置了延时队列（基于 Sorted Set 实现的）。</li>
<li><strong>分布式 Session</strong> ：利用 String 或者 Hash 数据类型保存 Session 数据，所有的服务器都可以访问。</li>
<li><strong>复杂业务场景</strong>：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 Bitmap 统计活跃用户、通过 Sorted Set 维护排行榜。</li>
<li>……</li>
</ul>
<h4 id="–-如何基于-Redis-实现分布式锁？"><a href="#–-如何基于-Redis-实现分布式锁？" class="headerlink" title="– 如何基于 Redis 实现分布式锁？"></a>– 如何基于 Redis 实现分布式锁？</h4><h4 id="–-Redis-可以做消息队列么？"><a href="#–-Redis-可以做消息队列么？" class="headerlink" title="– Redis 可以做消息队列么？"></a>– Redis 可以做消息队列么？</h4><p>可以是可以，但不建议使用 Redis 来做消息队列。和专业的消息队列相比，还是有很多欠缺的地方。</p>
<h4 id="–-Redis-可以做搜索引擎么？"><a href="#–-Redis-可以做搜索引擎么？" class="headerlink" title="– Redis 可以做搜索引擎么？"></a>– Redis 可以做搜索引擎么？</h4><p>可以实现全文搜索引擎功能的，需要借助 RediSearch ，这是一个基于 Redis 的搜索引擎模块。</p>
<p>RediSearch 支持中文分词、聚合统计、停用词、同义词、拼写检查、标签查询、向量相似度查询、多关键词搜索、分页搜索等功能，算是一个功能比较完善的全文搜索引擎了。</p>
<p>对于小型项目的简单搜索场景来说，使用 RediSearch 来作为搜索引擎还是没有问题的（搭配 RedisJSON 使用）。</p>
<h4 id="【Redis-数据类型】"><a href="#【Redis-数据类型】" class="headerlink" title="【Redis 数据类型】"></a>【Redis 数据类型】</h4><h4 id="–-Redis-常用的数据类型有哪些？"><a href="#–-Redis-常用的数据类型有哪些？" class="headerlink" title="– Redis 常用的数据类型有哪些？"></a>– Redis 常用的数据类型有哪些？</h4><p>Redis 中比较常见的数据类型有下面这些：</p>
<ul>
<li><strong>5 种基础数据类型</strong>：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</li>
<li><strong>3 种特殊数据类型</strong>：HyperLogLog（基数统计）、Bitmap （位图）、Geospatial (地理位置)。</li>
</ul>
<p>除了上面提到的之外，还有一些其他的比如 <a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/data-structure/bloom-filter.html">Bloom filter（布隆过滤器）open in new window</a>、Bitfield（位域）。</p>
<h4 id="–-String-的应用场景有哪些？"><a href="#–-String-的应用场景有哪些？" class="headerlink" title="– String 的应用场景有哪些？"></a>– String 的应用场景有哪些？</h4><p>是一种二进制安全的数据类型，可以用来存储<strong>任何类型</strong>的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。</p>
<p>String 的常见应用场景如下：</p>
<ul>
<li>常规数据（比如 <strong>Session、Token、序列化后的对象、图片的路径</strong>）的缓存；</li>
<li>计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；</li>
<li>分布式锁(利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁)；</li>
<li>……</li>
</ul>
<h4 id="–-String-还是-Hash-存储对象数据更好呢？"><a href="#–-String-还是-Hash-存储对象数据更好呢？" class="headerlink" title="– String 还是 Hash 存储对象数据更好呢？"></a>– String 还是 Hash 存储对象数据更好呢？</h4><ul>
<li><strong>String</strong> 存储的是序列化后的对象数据，<strong>存放的是整个对象</strong>。<strong>Hash 是对对象的每个字段单独存储</strong>，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。</li>
<li><strong>String</strong> 存储相对来说<strong>更加节省内存</strong>，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，String 就非常适合。</li>
</ul>
<p>绝大部分情况，建议使用 String 来存储对象数据！</p>
<h4 id="–-购物车信息用-String-还是-Hash-存储更好呢"><a href="#–-购物车信息用-String-还是-Hash-存储更好呢" class="headerlink" title="– 购物车信息用 String 还是 Hash 存储更好呢?"></a>– 购物车信息用 String 还是 Hash 存储更好呢?</h4><p>由于购物车中的商品频繁修改和变动，购物车信息建议使用 Hash 存储：</p>
<ul>
<li>用户 id 为 key</li>
<li>商品 id 为 field，商品数量为 value</li>
</ul>
<p>那用户购物车信息的维护具体应该怎么操作呢？</p>
<ul>
<li>用户添加商品就是往 Hash 里面增加新的 field 与 value；</li>
<li>查询购物车信息就是遍历对应的 Hash；</li>
<li>更改商品数量直接修改对应的 value 值（直接 set 或者做运算皆可）；</li>
<li>删除商品就是删除 Hash 中对应的 field；</li>
<li>清空购物车直接删除对应的 key 即可。</li>
</ul>
<p>这里只是以业务比较简单的购物车场景举例，实际电商场景下，field 只保存一个商品 id 是没办法满足需求的。</p>
<h4 id="–-使用-Redis-实现一个排行榜怎么做？"><a href="#–-使用-Redis-实现一个排行榜怎么做？" class="headerlink" title="– 使用 Redis 实现一个排行榜怎么做？"></a>– 使用 Redis 实现一个排行榜怎么做？</h4><p>Redis 中 <code>Sorted Set</code> （有序集合）的数据类型被用在各种排行榜的场景。</p>
<p>相关的一些 Redis 命令: <code>ZRANGE</code> (从小到大排序zrange)、 <code>ZREVRANGE</code> （从大到小排序zrevrange）、<code>ZREVRANK</code> (zrevrank指定元素排名)。</p>
<h4 id="–-Redis-的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者-B-树？"><a href="#–-Redis-的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者-B-树？" class="headerlink" title="– Redis 的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者 B+树？"></a>– Redis 的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者 B+树？</h4><ul>
<li>跳表诞生的初衷就是为了克服平衡树的一些缺点。跳表使用概率平衡而不是严格强制的平衡，因此，跳表中的插入和删除算法比平衡树的等效算法简单得多，速度也快得多。</li>
<li>相比较于红黑树来说，跳表的实现也更简单一些，不需要通过旋转和染色（红黑变换）来保证黑平衡。并且，按照区间来查找数据这个操作，红黑树的效率没有跳表高。</li>
<li>Redis 作为内存数据库它不可能存储大量的数据，所以对于索引不需要通过 B+树这种方式进行维护，只需按照概率进行随机维护即可，节约内存。</li>
</ul>
<h4 id="–-Set-的应用场景是什么？"><a href="#–-Set-的应用场景是什么？" class="headerlink" title="–  Set 的应用场景是什么？"></a>–  Set 的应用场景是什么？</h4><p>Redis 中 <code>Set</code> 是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 <code>HashSet</code> 。</p>
<p><code>Set</code> 的常见应用场景如下：</p>
<ul>
<li>存放的<strong>数据不能重复</strong>的场景：网站 UV 统计（数据量巨大的场景还是 <code>HyperLogLog</code>更适合一些）、文章点赞、动态点赞等等。</li>
<li>需要<strong>获取多个数据源交集、并集和差集</strong>的场景：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集） 等等。</li>
<li>需要<strong>随机</strong>获取数据源中的元素的场景：抽奖系统、随机点名等等。</li>
</ul>
<h4 id="–-使用-Set-实现抽奖系统怎么做？"><a href="#–-使用-Set-实现抽奖系统怎么做？" class="headerlink" title="– 使用 Set 实现抽奖系统怎么做？"></a>– 使用 Set 实现抽奖系统怎么做？</h4><p>如果想要使用 <code>Set</code> 实现一个简单的抽奖系统的话，直接使用下面这几个命令就可以了：</p>
<ul>
<li><code>SADD key member1 member2 ...</code>：向指定集合添加一个或多个元素。</li>
<li><code>SPOP key count</code>：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。</li>
<li><code>SRANDMEMBER key count</code> : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。</li>
</ul>
<h4 id="【Redis-持久化机制（重要）】"><a href="#【Redis-持久化机制（重要）】" class="headerlink" title="【Redis 持久化机制（重要）】"></a>【Redis 持久化机制（重要）】</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/100885432">Redis两种持久化机制RDB和AOF详解（面试常问，工作常用） - 知乎 (zhihu.com)</a></p>
<p>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式:</p>
<ul>
<li>快照（snapshotting，RDB）</li>
<li>只追加文件（append-only file, AOF）</li>
<li><strong>RDB 和 AOF 的混合持久化(Redis 4.0 新增)</strong></li>
</ul>
<h4 id="–-RDB-持久化"><a href="#–-RDB-持久化" class="headerlink" title="– RDB 持久化"></a>– RDB 持久化</h4><ul>
<li>通过创建快照来获得存储在内存里面的数据在 <strong>某个时间点</strong> 上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</li>
<li><strong>快照持久化</strong>是 <strong>Redis 默认采用</strong>的持久化方式</li>
</ul>
<p><strong>RDB 创建快照时会阻塞主线程吗？</strong></p>
<p>Redis 提供了两个命令来生成 RDB 快照文件：</p>
<ul>
<li>save : 同步保存操作，会阻塞 Redis 主线程；</li>
<li>bgsave : fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。</li>
</ul>
<h4 id="–-AOF-持久化"><a href="#–-AOF-持久化" class="headerlink" title="– AOF 持久化"></a>– AOF 持久化</h4><p>AOF 持久化的<strong>实时性更好</strong>。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化（<strong>Redis 6.0 之后</strong>已经<strong>默认</strong>是<strong>开启</strong>了），可以通过 <code>appendonly</code> 参数开启。</p>
<h3 id="【Redis-线程模型（重要）】"><a href="#【Redis-线程模型（重要）】" class="headerlink" title="【Redis 线程模型（重要）】"></a>【Redis 线程模型（重要）】</h3><p>对于读写命令来说，Redis 一直是单线程模型。不过，在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作， Redis 6.0 版本之后引入了多线程来处理网络请求（提高网络 IO 读写性能）。</p>
<h4 id="–-Redis-单线程模型了解吗？"><a href="#–-Redis-单线程模型了解吗？" class="headerlink" title="– Redis 单线程模型了解吗？"></a>– Redis 单线程模型了解吗？</h4><p>Redis <strong>基于 Reactor 模式</strong>开发了自己的<strong>网络事件处理器</strong>：这个处理器被称为<strong>文件事件处理器</strong>（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 <strong>Redis 是单线程模型</strong>。</p>
<p><strong>既然是单线程，那怎么监听大量的客户端连接呢？</strong></p>
<p>Redis 通过 <strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。</p>
<p>这样的好处：<strong>I&#x2F;O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>。</p>
<p>文件事件处理器（file event handler）主要是包含 4 个部分：</p>
<ul>
<li>多个 socket（客户端连接）</li>
<li>IO 多路复用程序（支持多个客户端连接的关键）</li>
<li>文件事件分派器（将 socket 关联到相应的事件处理器）</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<h4 id="–-Redis6-0-之前为什么不使用多线程？"><a href="#–-Redis6-0-之前为什么不使用多线程？" class="headerlink" title="– Redis6.0 之前为什么不使用多线程？"></a>– Redis6.0 之前为什么不使用多线程？</h4><p><strong>Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。</strong>不过，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主线程之外的其他线程来“异步处理”。</p>
<ul>
<li>单线程编程容易并且更容易维护；</li>
<li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li>
<li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li>
</ul>
<h4 id="–-Redis6-0-之后为何引入了多线程？"><a href="#–-Redis6-0-之后为何引入了多线程？" class="headerlink" title="– Redis6.0 之后为何引入了多线程？"></a>– Redis6.0 之后为何引入了多线程？</h4><p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。</p>
<p>虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。</p>
<p><strong>Redis6.0</strong> 的多线程<strong>默认是禁用</strong>的，只使用主线程。</p>
<h4 id="–-Redis-后台线程了解吗？"><a href="#–-Redis-后台线程了解吗？" class="headerlink" title="– Redis 后台线程了解吗？"></a>– Redis 后台线程了解吗？</h4><p> Redis 是单线程模型（主要逻辑是单线程完成的），但实际还有一些后台线程用于执行一些比较耗时的操作：</p>
<ul>
<li>通过 <code>bio_close_file</code> 后台线程来释放 AOF &#x2F; RDB 等过程中产生的临时文件资源。</li>
<li>通过 <code>bio_aof_fsync</code> 后台线程调用 <code>fsync</code> 函数将系统内核缓冲区还未同步到到磁盘的数据强制刷到磁盘（ AOF 文件）。</li>
<li>通过 <code>bio_lazy_free</code>后台线程释放大对象（已删除）占用的内存空间.</li>
</ul>
<h3 id="【Redis-内存管理】"><a href="#【Redis-内存管理】" class="headerlink" title="【Redis 内存管理】"></a>【Redis 内存管理】</h3><h4 id="–-Redis-给缓存数据设置过期时间有啥用？"><a href="#–-Redis-给缓存数据设置过期时间有啥用？" class="headerlink" title="– Redis 给缓存数据设置过期时间有啥用？"></a>– Redis 给缓存数据设置过期时间有啥用？</h4><p>因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。</p>
<p><strong>Redis 中除了字符串类型有自己独有设置过期时间的命令 <code>setex</code> 外，其他方法都需要依靠 <code>expire</code> 命令来设置过期时间 。另外， <code>persist</code> 命令可以移除一个键的过期时间。</strong></p>
<h5 id="过期时间除了有助于缓解内存的消耗，还有什么其他用么？"><a href="#过期时间除了有助于缓解内存的消耗，还有什么其他用么？" class="headerlink" title="过期时间除了有助于缓解内存的消耗，还有什么其他用么？"></a>过期时间除了有助于缓解内存的消耗，还有什么其他用么？</h5><p>有些业务场景就是需要<strong>某个数据只在某一时间段内存在</strong>，比如我们的<strong>短信验证码</strong>可能只在 1 分钟内有效，<strong>用户登录的 Token</strong> 可能只在 1 天内有效。</p>
<p>如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。</p>
<h4 id="–-Redis-是如何判断数据是否过期的呢？"><a href="#–-Redis-是如何判断数据是否过期的呢？" class="headerlink" title="– Redis 是如何判断数据是否过期的呢？"></a>– Redis 是如何判断数据是否过期的呢？</h4><p>Redis 通过一个叫做<strong>过期字典</strong>（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p>
<p>键：数据库中的某个key，值：对应的该key的过期时间</p>
<h4 id="–-过期的数据的删除策略了解么？☆"><a href="#–-过期的数据的删除策略了解么？☆" class="headerlink" title="– 过期的数据的删除策略了解么？☆"></a>– 过期的数据的删除策略了解么？☆</h4><ol>
<li><strong>惰性删除</strong>：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li>
<li><strong>定期删除</strong>：每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li>
</ol>
<p><strong>定期删除对内存更加友好，惰性删除对 CPU 更加友好</strong>。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性&#x2F;懒汉式删除</strong> 。</p>
<h4 id="–-Redis-内存淘汰机制了解么？"><a href="#–-Redis-内存淘汰机制了解么？" class="headerlink" title="– Redis 内存淘汰机制了解么？"></a>– Redis 内存淘汰机制了解么？</h4><p>可能存在<strong>定期删除和惰性删除漏掉</strong>了很多<strong>过期 key</strong> 的情况，解决方法就是Redis 内存淘汰机制。</p>
<p>Redis 提供 6 种数据淘汰策略：</p>
<ol>
<li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最近最少使用的数据淘汰。</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选将要过期的数据淘汰。</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中任意选择数据淘汰。</li>
<li><strong>allkeys-lru（least recently used）</strong>：<strong>当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</strong>。</li>
<li><strong>allkeys-random</strong>：从数据集（<code>server.db[i].dict</code>）中任意选择数据淘汰。</li>
<li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>
</ol>
<p>4.0 版本后增加以下两种：</p>
<ol>
<li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最不经常使用的数据淘汰。</li>
<li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key。</li>
</ol>
<h3 id="【Redis-事务】"><a href="#【Redis-事务】" class="headerlink" title="【Redis 事务】"></a>【Redis 事务】</h3><h4 id="–-什么是-Redis-事务？"><a href="#–-什么是-Redis-事务？" class="headerlink" title="– 什么是 Redis 事务？"></a>– 什么是 Redis 事务？</h4><p><strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></p>
<p>实际开发中使用的非常少，功能比较鸡肋。</p>
<h4 id="–-Redis-事务支持原子性吗？"><a href="#–-Redis-事务支持原子性吗？" class="headerlink" title="– Redis 事务支持原子性吗？"></a>– Redis 事务支持原子性吗？</h4><p>事务具有四大特性：<strong>1. 原子性</strong>，<strong>2. 隔离性</strong>，<strong>3. 持久性</strong>，<strong>4. 一致性</strong>。</p>
<p>Redis 事务在运行错误的情况下，<strong>除了执行过程中出现错误的命令外，其他命令都能正常执行。并且，Redis 事务是不支持回滚（roll back）操作的</strong>。因此，Redis 事务其实是<strong>不满足原子性</strong>的。</p>
<p>为了简单便捷，性能。</p>
<h4 id="–-Redis-事务支持持久性吗？"><a href="#–-Redis-事务支持持久性吗？" class="headerlink" title="– Redis 事务支持持久性吗？"></a>– Redis 事务支持持久性吗？</h4><p>Redis 不同于 Memcached 的很重要一点就是，<strong>Redis 支持持久化</strong>，而且支持 3 种持久化方式:</p>
<ul>
<li>快照（snapshotting，RDB）</li>
<li>只追加文件（append-only file, AOF）：实时性更好</li>
<li>RDB 和 AOF 的混合持久化(Redis 4.0 新增)</li>
</ul>
<p>三种不同的 AOF 持久化方式：AOF 持久化的<code>fsync</code>策略为 no、everysec 时都会存在数据丢失的情况 。always 下可以基本是可以满足持久性要求的，但性能太差，实际开发过程中不会使用。</p>
<p>因此，<strong>Redis 事务的持久性也是没办法保证的</strong>。</p>
<h3 id="【Redis-性能优化（重要）】"><a href="#【Redis-性能优化（重要）】" class="headerlink" title="【Redis 性能优化（重要）】"></a>【Redis 性能优化（重要）】</h3><h4 id="–-使用批量操作减少网络传输"><a href="#–-使用批量操作减少网络传输" class="headerlink" title="– 使用批量操作减少网络传输"></a>– 使用批量操作减少网络传输</h4><p>Redis 命令的执行可以简化为以下 4 步：</p>
<ol>
<li>发送命令</li>
<li>命令排队</li>
<li>命令执行</li>
<li>返回结果</li>
</ol>
<p>其中，第 1 步和第 4 步耗费时间之和称为 <strong>Round Trip Time (RTT,往返时间)</strong> ，也就是数据在网络上传输的时间</p>
<h4 id="–-原生批量操作命令"><a href="#–-原生批量操作命令" class="headerlink" title="– 原生批量操作命令"></a>– 原生批量操作命令</h4><h4 id="–-Lua-脚本"><a href="#–-Lua-脚本" class="headerlink" title="– Lua 脚本"></a>– Lua 脚本</h4><h4 id="–-大量-key-集中过期问题"><a href="#–-大量-key-集中过期问题" class="headerlink" title="– 大量 key 集中过期问题"></a>– 大量 key 集中过期问题</h4><ol>
<li><strong>给 key 设置随机过期时间</strong>。</li>
<li>开启 lazy-free（惰性删除&#x2F;延迟释放） 。lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</li>
</ol>
<p>尽量给 key 设置随机过期时间。</p>
<h4 id="–-Redis-bigkey（大-Key）"><a href="#–-Redis-bigkey（大-Key）" class="headerlink" title="– Redis bigkey（大 Key）"></a>– Redis bigkey（大 Key）</h4><h5 id="什么是-bigkey？"><a href="#什么是-bigkey？" class="headerlink" title="什么是 bigkey？"></a>什么是 bigkey？</h5><p>一个 key 对应的 <strong>value 所占用的内存</strong>比较大，那这个 key 就可以看作是 bigkey。</p>
<p>参考标准：</p>
<ul>
<li>String 类型的 value 超过 1MB</li>
<li>复合类型（List、Hash、Set、Sorted Set 等）的 value 包含的元素超过 5000 个（不过，对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）</li>
</ul>
<h4 id="–-Redis-hotkey（热-Key）"><a href="#–-Redis-hotkey（热-Key）" class="headerlink" title="– Redis hotkey（热 Key）"></a>– Redis hotkey（热 Key）</h4><h5 id="什么是-hotkey？"><a href="#什么是-hotkey？" class="headerlink" title="什么是 hotkey？"></a>什么是 hotkey？</h5><p>一个 <strong>key 的访问次数</strong>比较多且明显多于其他 key 的话，那这个 key 就可以看作是 <strong>hotkey（热 Key）</strong>。</p>
<p>如果突然访问 hotkey 的请求超出了 Redis 的处理能力，Redis 就会直接宕机。这种情况下，大量请求将落到后面的数据库上，可能会导致数据库崩溃。</p>
<p>因此，hotkey 很可能成为系统性能的瓶颈点，需要单独对其进行优化，以确保系统的高可用性和稳定性。</p>
<h5 id="如何发现-hotkey？"><a href="#如何发现-hotkey？" class="headerlink" title="如何发现 hotkey？"></a>如何发现 hotkey？</h5><h5 id="如何解决-hotkey？"><a href="#如何解决-hotkey？" class="headerlink" title="如何解决 hotkey？"></a>如何解决 hotkey？</h5><p><strong>读写分离</strong>：主节点处理写请求，从节点处理读请求。</p>
<p><strong>使用 Redis Cluster</strong>：将热点数据分散存储在多个 Redis 节点上。</p>
<p><strong>二级缓存</strong>：hotkey 采用二级缓存的方式进行处理，将 hotkey 存放一份到 JVM 本地内存中（可以用 Caffeine）。</p>
<h4 id="–-慢查询命令？"><a href="#–-慢查询命令？" class="headerlink" title="– 慢查询命令？"></a>– 慢查询命令？</h4><ul>
<li>Redis 慢查询统计的是命令执行这一步骤的耗时，慢查询命令也就是那些命令执行时间较长的命令。</li>
<li>慢查询，顾名思义，执行很慢的查询。有多慢？超过 long_query_time 参数设定的时间阈值（默认10s），就被认为是慢的，是需要优化的。慢查询被记录在慢查询日志里。</li>
<li>由于慢查询日志会占用一定内存空间，如果设置最大记录条数过大，可能会导致内存占用过高的问题。</li>
</ul>
<h4 id="–-Redis-内存碎片"><a href="#–-Redis-内存碎片" class="headerlink" title="– Redis 内存碎片"></a>– Redis 内存碎片</h4><h5 id="什么是内存碎片-为什么会有-Redis-内存碎片"><a href="#什么是内存碎片-为什么会有-Redis-内存碎片" class="headerlink" title="什么是内存碎片?为什么会有 Redis 内存碎片?"></a>什么是内存碎片?为什么会有 Redis 内存碎片?</h5><p>简单地理解为那些<strong>不可用的空闲内存</strong>。Redis 内存碎片虽然不会影响 Redis 性能，但是会<strong>增加内存消耗</strong>。</p>
<p>例子：操作系统为你分配了 32 字节的连续内存空间，而你存储数据实际只需要使用 24 字节内存空间，那这多余出来的 8 字节内存空间如果后续没办法再被分配存储其他数据的话，就可以被称为内存碎片。</p>
<h5 id="为什么会有-Redis-内存碎片"><a href="#为什么会有-Redis-内存碎片" class="headerlink" title="为什么会有 Redis 内存碎片?"></a>为什么会有 Redis 内存碎片?</h5><ul>
<li>Redis 存储存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。</li>
<li>频繁修改 Redis 中的数据也会产生内存碎片。（当 Redis 中的某个数据删除时，Redis 通常不会轻易释放内存给操作系统。）</li>
</ul>
<h5 id="如何查看-Redis-内存碎片的信息？"><a href="#如何查看-Redis-内存碎片的信息？" class="headerlink" title="如何查看 Redis 内存碎片的信息？"></a>如何查看 Redis 内存碎片的信息？</h5><p><code>info memory</code> 命令</p>
<h5 id="如何清理-Redis-内存碎片？"><a href="#如何清理-Redis-内存碎片？" class="headerlink" title="如何清理 Redis 内存碎片？"></a>如何清理 Redis 内存碎片？</h5><p>Redis4.0-RC3 版本以后自带了内存整理，可以避免内存碎片率过大的问题。</p>
<p>直接通过 <code>config set</code> 命令将 <code>activedefrag</code> 配置项设置为 <code>yes</code> 即可。</p>
<h3 id="【Redis-生产问题（重要）】"><a href="#【Redis-生产问题（重要）】" class="headerlink" title="【Redis 生产问题（重要）】"></a>【Redis 生产问题（重要）】</h3><h4 id="–-缓存穿透"><a href="#–-缓存穿透" class="headerlink" title="– 缓存穿透"></a>– 缓存穿透</h4><p>大量请求的 key 是不合理的，<strong>根本不存在于缓存中，也不存在于数据库中</strong> 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>
<p><strong>例子</strong>：某个黑客故意制造一些非法的 key 发起大量请求，导致大量请求落到数据库，结果数据库上也没有查到对应的数据。也就是说这些请求最终都落到了数据库上，对数据库造成了巨大的压力。</p>
<h5 id="解决办法？"><a href="#解决办法？" class="headerlink" title="解决办法？"></a>解决办法？</h5><p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。</p>
<ol>
<li><p><strong>缓存无效 key</strong></p>
<p>缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下：<code>SET key value EX 10086</code> 。尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p>
</li>
<li><p><strong>布隆过滤器</strong>☆</p>
<p>通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。</p>
</li>
<li><p><strong>接口限流</strong>☆</p>
<p>根据用户或者 IP 对接口进行限流，对于异常频繁的访问行为，还可以采取黑名单机制，例如将异常 IP 列入黑名单。</p>
</li>
</ol>
<h4 id="–-缓存击穿"><a href="#–-缓存击穿" class="headerlink" title="– 缓存击穿"></a>– 缓存击穿</h4><p>请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>
<p><strong>例子</strong>：秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。</p>
<h5 id="解决办法？-1"><a href="#解决办法？-1" class="headerlink" title="解决办法？"></a>解决办法？</h5><ol>
<li>设置热点数据永不过期或者过期时间比较长。</li>
<li>针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li>
<li>请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求会落到数据库上，减少数据库的压力。</li>
</ol>
<h4 id="–-缓存穿透和缓存击穿区别？"><a href="#–-缓存穿透和缓存击穿区别？" class="headerlink" title="– 缓存穿透和缓存击穿区别？"></a>– 缓存穿透和缓存击穿区别？</h4><p>缓存穿透：key不存在于缓存或数据库中。</p>
<p>缓存击穿：请求的 key 对应的是 <strong>热点数据</strong>，数据在缓存中已过期，只存在于数据库中</p>
<h4 id="–-缓存雪崩"><a href="#–-缓存雪崩" class="headerlink" title="– 缓存雪崩"></a>– 缓存雪崩</h4><p><strong>缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。</strong> </p>
<p>缓存服务宕机也会导致缓存雪崩现象，导致所有的请求都落到了数据库上。</p>
<h5 id="缓存预热如何实现？"><a href="#缓存预热如何实现？" class="headerlink" title="缓存预热如何实现？"></a><strong>缓存预热如何实现？</strong></h5><p>常见的缓存预热方式有两种：</p>
<ol>
<li>使用定时任务，比如 xxl-job，来定时触发缓存预热的逻辑，将数据库中的热点数据查询出来并存入缓存中。</li>
<li>使用消息队列，比如 Kafka，来异步地进行缓存预热，将数据库中的热点数据的主键或者 ID 发送到消息队列中，然后由缓存服务消费消息队列中的数据，根据主键或者 ID 查询数据库并更新缓存。</li>
</ol>
<h4 id="–-缓存雪崩和缓存击穿有什么区别？"><a href="#–-缓存雪崩和缓存击穿有什么区别？" class="headerlink" title="– 缓存雪崩和缓存击穿有什么区别？"></a>– 缓存雪崩和缓存击穿有什么区别？</h4><p>比较像，但缓存雪崩导致的原因是缓存中的<strong>大量或者所有数据失效</strong>，缓存击穿导致的原因主要是<strong>某个热点数据不存在与缓存中</strong>（通常是因为缓存中的那份数据已经过期）</p>
<h4 id="–-如何保证缓存和数据库数据的一致性？"><a href="#–-如何保证缓存和数据库数据的一致性？" class="headerlink" title="– 如何保证缓存和数据库数据的一致性？"></a>– 如何保证缓存和数据库数据的一致性？</h4><ol>
<li><p>缓存失效时间变短（不推荐，治标不治本）</p>
</li>
<li><p><strong>增加 cache 更新重试机制（常用）</strong>？</p>
</li>
</ol>
<h4 id="–-哪些情况可能会导致-Redis-阻塞？"><a href="#–-哪些情况可能会导致-Redis-阻塞？" class="headerlink" title="– 哪些情况可能会导致 Redis 阻塞？"></a>– 哪些情况可能会导致 Redis 阻塞？</h4><h3 id="【重要知识点】"><a href="#【重要知识点】" class="headerlink" title="【重要知识点】"></a>【重要知识点】</h3><h4 id="–-3种常用的缓存读写策略详解"><a href="#–-3种常用的缓存读写策略详解" class="headerlink" title="– 3种常用的缓存读写策略详解"></a>– 3种常用的缓存读写策略详解</h4><p><strong>缓存常用的 3 种读写策略</strong></p>
<ul>
<li><strong>1. Cache Aside Pattern（旁路缓存模式）</strong><ul>
<li>Cache Aside Pattern 是我们平时<strong>使用比较多</strong>的一个缓存读写模式，比较适合读请求比较多的场景。</li>
<li>Cache Aside Pattern 中服务端需要同时维系 <strong>db</strong> 和 <strong>cache</strong>，并且是以 db 的结果为准。</li>
<li><strong>写</strong>：先更新 db，然后直接删除 cache </li>
<li><strong>读</strong> ：<ul>
<li>从 cache 中读取数据，读取到就直接返回</li>
<li>cache 中读取不到的话，就从 db 中读取数据返回，再把数据放到 cache 中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="–在写数据的过程中，可以先删除-cache-，后更新-db-么？"><a href="#–在写数据的过程中，可以先删除-cache-，后更新-db-么？" class="headerlink" title="–在写数据的过程中，可以先删除 cache ，后更新 db 么？"></a>–在写数据的过程中，可以先删除 cache ，后更新 db 么？</h5><p>那肯定是不行的！因为这样可能会造成 <strong>数据库（db）和缓存（Cache）数据不一致</strong>。</p>
<h5 id="–在写数据的过程中，先更新-db，后删除-cache-就没有问题了么？"><a href="#–在写数据的过程中，先更新-db，后删除-cache-就没有问题了么？" class="headerlink" title="–在写数据的过程中，先更新 db，后删除 cache 就没有问题了么？"></a>–在写数据的过程中，先更新 db，后删除 cache 就没有问题了么？</h5><p>概率非常小，因为缓存的写入速度是比数据库的写入速度快很多。</p>
<ul>
<li><p><strong>2. Read&#x2F;Write Through Pattern（读写穿透）</strong></p>
<ul>
<li>服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。</li>
<li><strong>写（Write Through）：</strong><ul>
<li>先查 cache，cache 中不存在，直接更新 db。</li>
<li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 db（<strong>同步更新 cache 和 db</strong>）</li>
</ul>
</li>
<li><strong>读(Read Through)：</strong><ul>
<li>从 cache 中读取数据，读取到就直接返回 。</li>
<li>读取不到的话，先从 db 加载，写入到 cache 后返回响应。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>3. Write Behind Pattern（异步缓存写入）</strong></p>
<ul>
<li><p>Write Behind Pattern 和 Read&#x2F;Write Through Pattern 都是由 cache 服务来负责 cache 和 db 的读写。</p>
</li>
<li><p>不同：<strong>Read&#x2F;Write Through 是同步更新 cache 和 db，而 Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。</strong></p>
</li>
<li><p>对数据一致性带来了更大的挑战。</p>
</li>
<li><p>消息队列中消息的异步写入磁盘、MySQL 的 Innodb Buffer Pool 机制都用到了这种策略。Write Behind Pattern 下 db 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。</p>
</li>
</ul>
</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">lyl_L-</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://sunrisel135.github.io/blog_lyl/2024/03/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95-Redis/">https://sunrisel135.github.io/blog_lyl/2024/03/14/数据库面试-Redis/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">本文声明: </span><span class="post-copyright-info">内容均为个人总结，仅供个人参考！</span></div></div></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/blog_lyl/2024/03/15/Java%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95-Spring/"><i class="fas fa-angle-left">&nbsp;</i><span>Java框架面试-Spring</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/blog_lyl/2024/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"><span>数据库面试-数据库基础</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2024 By lyl_L-</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/copy.js"></script><!--script(src=url)--></body></html>