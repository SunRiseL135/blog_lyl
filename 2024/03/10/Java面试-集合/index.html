<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java面试-集合"><meta name="keywords" content="面试"><meta name="author" content="lyl_L-,undefined"><meta name="copyright" content="lyl_L-"><title>Java面试-集合【lyl'blog】</title><link rel="stylesheet" href="/blog_lyl/css/fan.css"><link rel="stylesheet" href="/blog_lyl/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/blog_lyl/L.ico"><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- script(src=url_for("/js/mathjax/mathjax.js"))--><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/blog_lyl/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: {},
  valine: {},
  twikoo: {},
}</script><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/blog_lyl/atom.xml" title="lyl'blog" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0%E3%80%91"><span class="toc-number">1.</span> <span class="toc-text">【集合概述】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-Java%E9%9B%86%E5%90%88"><span class="toc-number">1.1.</span> <span class="toc-text">– Java集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E8%AF%B4%E8%AF%B4-List-Set-Queue-Map-%E5%9B%9B%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">– 说说 List, Set, Queue, Map 四者的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.</span> <span class="toc-text">– 集合框架底层数据结构总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E5%A6%82%E4%BD%95%E9%80%89%E7%94%A8%E9%9B%86%E5%90%88"><span class="toc-number">1.4.</span> <span class="toc-text">– 如何选用集合?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">– 为什么要使用集合？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%90List%E3%80%91"><span class="toc-number">1.6.</span> <span class="toc-text">【List】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-ArrayList-%E5%92%8C-Array%EF%BC%88%E6%95%B0%E7%BB%84%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">– ArrayList 和 Array（数组）的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-ArrayList-%E5%92%8C-Vector-%E7%9A%84%E5%8C%BA%E5%88%AB-%EF%BC%88%E4%BA%86%E8%A7%A3%E5%8D%B3%E5%8F%AF%EF%BC%89"><span class="toc-number">1.8.</span> <span class="toc-text">– ArrayList 和 Vector 的区别?（了解即可）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-Vector-%E5%92%8C-Stack-%E7%9A%84%E5%8C%BA%E5%88%AB-%EF%BC%88%E4%BA%86%E8%A7%A3%E5%8D%B3%E5%8F%AF%EF%BC%89"><span class="toc-number">1.9.</span> <span class="toc-text">– Vector 和 Stack 的区别?（了解即可）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-ArrayList-%E5%8F%AF%E4%BB%A5%E6%B7%BB%E5%8A%A0-null-%E5%80%BC%E5%90%97%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">– ArrayList 可以添加 null 值吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-ArrayList-%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9F"><span class="toc-number">1.11.</span> <span class="toc-text">– ArrayList 插入和删除元素的时间复杂度？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-LinkedList-%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9F"><span class="toc-number">1.12.</span> <span class="toc-text">– LinkedList 插入和删除元素的时间复杂度？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-RandomAccess-%E6%8E%A5%E5%8F%A3%EF%BC%9FLinkedList-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%AE%9E%E7%8E%B0-RandomAccess-%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="toc-number">1.13.</span> <span class="toc-text">– RandomAccess 接口？LinkedList 为什么不能实现 RandomAccess 接口？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-ArrayList-%E4%B8%8E-LinkedList-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.14.</span> <span class="toc-text">– ArrayList 与 LinkedList 区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%92%8C%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">1.15.</span> <span class="toc-text">– 双向链表和双向循环链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E8%AF%B4%E4%B8%80%E8%AF%B4-ArrayList-%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%90%A7"><span class="toc-number">1.16.</span> <span class="toc-text">– 说一说 ArrayList 的扩容机制吧</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Set%E3%80%91"><span class="toc-number">2.</span> <span class="toc-text">【Set】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-Comparable-%E5%92%8C-Comparator-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.</span> <span class="toc-text">– Comparable 和 Comparator 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E6%97%A0%E5%BA%8F%E6%80%A7%E5%92%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%80%A7%E7%9A%84%E5%90%AB%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.2.</span> <span class="toc-text">– 无序性和不可重复性的含义是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E6%AF%94%E8%BE%83-HashSet%E3%80%81LinkedHashSet-%E5%92%8C-TreeSet-%E4%B8%89%E8%80%85%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">2.3.</span> <span class="toc-text">– 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Queue%E3%80%91"><span class="toc-number">3.</span> <span class="toc-text">【Queue】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-Queue-%E4%B8%8E-Deque-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.</span> <span class="toc-text">– Queue 与 Deque 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-ArrayDeque-%E4%B8%8E-LinkedList-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.2.</span> <span class="toc-text">– ArrayDeque 与 LinkedList 的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Map%E3%80%91"><span class="toc-number">4.</span> <span class="toc-text">【Map】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-HashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.</span> <span class="toc-text">– HashMap 和 Hashtable 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-HashMap-%E5%92%8C-HashSet-%E5%8C%BA%E5%88%AB"><span class="toc-number">4.2.</span> <span class="toc-text">– HashMap 和 HashSet 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-HashMap-%E5%92%8C-TreeMap-%E5%8C%BA%E5%88%AB"><span class="toc-number">4.3.</span> <span class="toc-text">– HashMap 和 TreeMap 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-HashSet-%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E9%87%8D%E5%A4%8D-%E2%98%85"><span class="toc-number">4.4.</span> <span class="toc-text">– HashSet 如何检查重复? ★</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-HashMap-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-%E2%98%85"><span class="toc-number">4.5.</span> <span class="toc-text">– HashMap 的底层实现 ★</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-HashMap-%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-2-%E7%9A%84%E5%B9%82%E6%AC%A1%E6%96%B9"><span class="toc-number">4.6.</span> <span class="toc-text">– HashMap 的长度为什么是 2 的幂次方</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-HashMap-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C%E5%AF%BC%E8%87%B4%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98"><span class="toc-number">4.7.</span> <span class="toc-text">– HashMap 多线程操作导致死循环问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-HashMap-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">4.8.</span> <span class="toc-text">– HashMap 为什么线程不安全？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-HashMap-%E5%B8%B8%E8%A7%81%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">4.9.</span> <span class="toc-text">– HashMap 常见的遍历方式?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-ConcurrentHashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.10.</span> <span class="toc-text">– ConcurrentHashMap 和 Hashtable 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-ConcurrentHashMap-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-%E5%BA%95%E5%B1%82%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.11.</span> <span class="toc-text">– ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-JDK-1-7-%E5%92%8C-JDK-1-8-%E7%9A%84-ConcurrentHashMap-%E5%AE%9E%E7%8E%B0%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">4.12.</span> <span class="toc-text">– JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-ConcurrentHashMap-%E4%B8%BA%E4%BB%80%E4%B9%88-key-%E5%92%8C-value-%E4%B8%8D%E8%83%BD%E4%B8%BA-null%EF%BC%9F"><span class="toc-number">4.13.</span> <span class="toc-text">– ConcurrentHashMap 为什么 key 和 value 不能为 null？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-ConcurrentHashMap-%E8%83%BD%E4%BF%9D%E8%AF%81%E5%A4%8D%E5%90%88%E6%93%8D%E4%BD%9C%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E5%90%97%EF%BC%9F"><span class="toc-number">4.14.</span> <span class="toc-text">– ConcurrentHashMap 能保证复合操作的原子性吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Collections-%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%88%E4%B8%8D%E9%87%8D%E8%A6%81%EF%BC%89%E3%80%91"><span class="toc-number">5.</span> <span class="toc-text">【Collections 工具类（不重要）】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%85%B6%E4%BB%96-%E6%B3%A8%E6%84%8F%E9%A1%B9%E3%80%91"><span class="toc-number">6.</span> <span class="toc-text">【其他 注意项】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E9%9B%86%E5%90%88%E5%88%A4%E7%A9%BA"><span class="toc-number">6.1.</span> <span class="toc-text">– 集合判空</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E9%9B%86%E5%90%88%E8%BD%AC-Map"><span class="toc-number">6.2.</span> <span class="toc-text">– 集合转 Map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86"><span class="toc-number">6.3.</span> <span class="toc-text">– 集合遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E9%9B%86%E5%90%88%E5%8E%BB%E9%87%8D"><span class="toc-number">6.4.</span> <span class="toc-text">– 集合去重</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E9%9B%86%E5%90%88%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-number">6.5.</span> <span class="toc-text">– 集合转数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%93-%E6%95%B0%E7%BB%84%E8%BD%AC%E9%9B%86%E5%90%88"><span class="toc-number">6.6.</span> <span class="toc-text">– 数组转集合</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/blog_lyl/images/Java.png"></div><div class="author-info-name">lyl_L-</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/SunRiseL135" target="_blank">GitHub<i class="icon-dot bg-color5"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/blog_lyl/archives"><span class="pull-top">日志</span><span class="pull-bottom">10</span></a><a class="author-info-articles-tags article-meta" href="/blog_lyl/tags"><span class="pull-top">标签</span><span class="pull-bottom">4</span></a><a class="author-info-articles-categories article-meta" href="/blog_lyl/categories"><span class="pull-top">分类</span><span class="pull-bottom">8</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/blog_lyl">首页</a><a class="menu-item" href="/blog_lyl/tags">标签</a><a class="menu-item" href="/blog_lyl/categories">分类</a><a class="menu-item" href="/blog_lyl/archives">归档</a><a class="menu-item" href="/blog_lyl/about">关于</a></nav><div class="right-info"><a class="title-name" href="/blog_lyl/">lyl'blog</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">Java面试-集合</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2024-03-10 | 更新于 2024-03-11</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/blog_lyl/categories/Java%E9%9B%86%E5%90%88/">Java集合</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/blog_lyl/tags/%E9%9D%A2%E8%AF%95/">面试</a></div></div></div><div class="main-content"><p>Java集合框架总结…</p>
<span id="more"></span>



<h3 id="【集合概述】"><a href="#【集合概述】" class="headerlink" title="【集合概述】"></a>【集合概述】</h3><h4 id="–-Java集合"><a href="#–-Java集合" class="headerlink" title="– Java集合"></a>– Java集合</h4><p>Java 集合， 也叫作容器，主要是由两大接口派生而来：</p>
<ol>
<li><code>Collection</code>接口，主要用于存放<strong>单一元素</strong>；</li>
<li><code>Map</code> 接口，主要用于存放<strong>键值对</strong>。</li>
</ol>
<h4 id="–-说说-List-Set-Queue-Map-四者的区别？"><a href="#–-说说-List-Set-Queue-Map-四者的区别？" class="headerlink" title="– 说说 List, Set, Queue, Map 四者的区别？"></a>– 说说 List, Set, Queue, Map 四者的区别？</h4><ul>
<li><code>List</code>(<em>对付顺序的好帮手</em>): 存储的元素是<strong>有序的</strong>、<strong>可重复</strong>的。</li>
<li><code>Set</code>(<em>注重独一无二的性质</em>): 存储的元素<strong>不可重复</strong>的。</li>
<li><code>Queue</code>(<em>实现排队功能的叫号机</em>): 按特定的<strong>排队</strong>规则来确定先后顺序，存储的元素是<strong>有序</strong>的、<strong>可重复</strong>的。</li>
<li><code>Map</code>(<em>用 key 来搜索的专家</em>): 使用<strong>键值对（key-value）</strong>存储，<strong>key 是无序的、不可重复的</strong>，<strong>value 是无序的、可重复的</strong>，<strong>每个键最多映射到一个值</strong>。</li>
</ul>
<h4 id="–-集合框架底层数据结构总结"><a href="#–-集合框架底层数据结构总结" class="headerlink" title="– 集合框架底层数据结构总结"></a>– 集合框架底层数据结构总结</h4><ul>
<li><strong>Collection</strong><ul>
<li><code>List</code><ul>
<li><code>ArrayList</code>：**<code>Object[]</code> 数组**。详细可以查看：<a href="">ArrayList 源码分析</a>。</li>
<li><code>Vector</code>：<code>Object[]</code> 数组。</li>
<li><code>LinkedList</code>：<strong>双向链表</strong> (JDK1.6 之前为循环链表，JDK1.7 取消了循环)。详细可以查看：<a href="">LinkedList 源码分析</a>。</li>
</ul>
</li>
<li><code>Set</code><ul>
<li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 HashMap 来保存元素。</li>
<li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 LinkedHashMap 来实现的。</li>
<li><code>TreeSet</code>(有序，唯一): <strong>红黑树</strong>(自平衡的排序二叉树)</li>
</ul>
</li>
<li><strong>Queue</strong><ul>
<li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现小顶堆。详细可以查看：<a href="">PriorityQueue 源码分析</a>。</li>
<li><code>DelayQueue</code>:<code>PriorityQueue</code>。详细可以查看：<a href="">DelayQueue 源码分析</a>。</li>
<li><code>ArrayDeque</code>: 可扩容动态双向数组。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Map</strong><ul>
<li><code>HashMap</code>：<strong>JDK1.8 之前</strong> <code>HashMap</code> 由<strong>数组+链表</strong>组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。<strong>JDK1.8 以后</strong>在解决哈希冲突时有了较大的变化，<strong>当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树</strong>，以减少搜索时间。详细可以查看：<a href="">HashMap 源码分析</a>。</li>
<li><code>LinkedHashMap</code>：<code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于<strong>拉链式散列结构即由数组和链表或红黑树组成</strong>。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条<strong>双向链表</strong>，使得上面的结构可以保持键值对的插入顺序。</li>
<li><code>Hashtable</code>：<strong>数组+链表</strong>组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的。</li>
<li><code>TreeMap</code>：红黑树（自平衡的排序二叉树）。</li>
</ul>
</li>
</ul>
<h4 id="–-如何选用集合"><a href="#–-如何选用集合" class="headerlink" title="– 如何选用集合?"></a>– 如何选用集合?</h4><ul>
<li>根据<strong>键值</strong>获取到元素值时就选用 <code>Map</code> 接口下的集合<ul>
<li>需要<strong>排序</strong>时选择 <code>TreeMap</code></li>
<li>不需要排序时就选择 <code>HashMap</code></li>
<li>需要保证<strong>线程安全</strong>就选用 <code>ConcurrentHashMap</code></li>
</ul>
</li>
<li>只需要存放<strong>元素值</strong>时，就选择实现<code>Collection</code> 接口的集合，<ul>
<li>需要<strong>保证元素唯一</strong>时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code>，</li>
<li>不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code>，然后再根据实现这些接口的集合的特点来选用。</li>
</ul>
</li>
</ul>
<h4 id="–-为什么要使用集合？"><a href="#–-为什么要使用集合？" class="headerlink" title="– 为什么要使用集合？"></a>– 为什么要使用集合？</h4><ul>
<li>数组：存储一组类型相同的数据</li>
<li>集合：存储的数据类型多种多样且数量不确定</li>
<li>Java 集合提高了数据的存储和处理灵活性，可以更好地适应现代软件开发中多样化的数据需求，并支持高质量的代码编写</li>
</ul>
<h4 id="【List】"><a href="#【List】" class="headerlink" title="【List】"></a>【List】</h4><h4 id="–-ArrayList-和-Array（数组）的区别？"><a href="#–-ArrayList-和-Array（数组）的区别？" class="headerlink" title="– ArrayList 和 Array（数组）的区别？"></a>– ArrayList 和 Array（数组）的区别？</h4><p><code>ArrayList</code> 动态数组，比 Array（静态数组） 使用起来更加灵活：</p>
<ul>
<li><code>ArrayList</code>会<strong>动态地扩容或缩容</strong>，而 <code>Array</code> 创建后就无法改变长度。</li>
<li><code>ArrayList</code> 可使用<strong>泛型</strong>来确保类型安全，<code>Array</code> 则不行。</li>
<li><code>ArrayList</code> 中<strong>只能存储对象</strong>。对于基本类型数据，需要使用其对应的<strong>包装类</strong>（如 Integer、Double 等）。<code>Array</code> 则是都可以存储。</li>
<li><code>ArrayList</code> 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度的数组，<strong>只能按照下标访问其中的元素，不具备动态添加、删除元素的能力</strong>。</li>
<li><code>ArrayList</code><strong>创建时不需要指定大小</strong>，而<code>Array</code>创建时<strong>必须指定大小</strong>。</li>
</ul>
<h4 id="–-ArrayList-和-Vector-的区别-（了解即可）"><a href="#–-ArrayList-和-Vector-的区别-（了解即可）" class="headerlink" title="– ArrayList 和 Vector 的区别?（了解即可）"></a>– ArrayList 和 Vector 的区别?（了解即可）</h4><ul>
<li><code>ArrayList</code> 是 List 的主要实现类，底层使用 Object[]存储，适用于频繁的查找工作，线程不安全 </li>
<li><code>Vector</code> 是 List 的古老实现类，底层使用Object[] 存储，<strong>线程安全</strong></li>
</ul>
<h4 id="–-Vector-和-Stack-的区别-（了解即可）"><a href="#–-Vector-和-Stack-的区别-（了解即可）" class="headerlink" title="– Vector 和 Stack 的区别?（了解即可）"></a>– Vector 和 Stack 的区别?（了解即可）</h4><ul>
<li><code>Vector</code> 和 Stack 两者都是线程安全的，都是使用 synchronized 关键字进行同步处理。</li>
<li><code>Stack</code> 继承自 Vector，是一个后进先出的栈，而 Vector 是一个列表。</li>
</ul>
<p>随着 Java 并发编程的发展，Vector 和 Stack 已经被淘汰，推荐使用并发集合类（例如 <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code> 等）或者手动实现线程安全的方法来提供安全的多线程操作支持。</p>
<h4 id="–-ArrayList-可以添加-null-值吗？"><a href="#–-ArrayList-可以添加-null-值吗？" class="headerlink" title="– ArrayList 可以添加 null 值吗？"></a>– ArrayList 可以添加 null 值吗？</h4><p><code>ArrayList</code> 中可以<strong>存储任何类型的对象</strong>，包括 null 值。</p>
<p>不建议向ArrayList 中添加 null 值， null 值无意义，会让代码难以维护比如忘记做判空处理就会导致空指针异常。</p>
<h4 id="–-ArrayList-插入和删除元素的时间复杂度？"><a href="#–-ArrayList-插入和删除元素的时间复杂度？" class="headerlink" title="– ArrayList 插入和删除元素的时间复杂度？"></a>– ArrayList 插入和删除元素的时间复杂度？</h4><p><strong>对于插入：</strong></p>
<ul>
<li><p><strong>头插：</strong>需将所有元素依次向后移一个位置，所以<strong>O(n)</strong></p>
</li>
<li><p><strong>尾插</strong>：<code>ArrayList</code> 的容量未达到极限时，**O(1)**，只需在数组末尾添加元素；</p>
<p>容量已达到极限需要扩容时，需要执行一次 <strong>O(n)</strong> 的操作将原数组复制到新的更大的数组中，然后<strong>再</strong>执行 <strong>O(1)</strong> 的操作添加元素。</p>
</li>
<li><p><strong>指定位置插入：</strong>目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n&#x2F;2 个元素，因此时间复杂度为 **O(n)**。</p>
</li>
</ul>
<p><strong>对于删除：</strong></p>
<ul>
<li>头部删除：需将所有元素依次向前移动一个位置，**O(n)**。</li>
<li>尾部删除：**O(1)**。</li>
<li>指定位置删除：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 **O(n)**。</li>
</ul>
<h4 id="–-LinkedList-插入和删除元素的时间复杂度？"><a href="#–-LinkedList-插入和删除元素的时间复杂度？" class="headerlink" title="– LinkedList 插入和删除元素的时间复杂度？"></a>– LinkedList 插入和删除元素的时间复杂度？</h4><ul>
<li>头部插入&#x2F;删除：只需修改头结点的指针即可，时间复杂度为 **O(1)**。</li>
<li>尾部插入&#x2F;删除：只需修改尾结点的指针即可，时间复杂度为 **O(1)**。</li>
<li>指定位置插入&#x2F;删除：需<strong>先移动</strong>到指定位置，<strong>再修改</strong>指定节点的指针完成插入&#x2F;删除，因此需移动平均 n&#x2F;2 个元素，时间复杂度为 **O(n)**。</li>
</ul>
<h4 id="–-RandomAccess-接口？LinkedList-为什么不能实现-RandomAccess-接口？"><a href="#–-RandomAccess-接口？LinkedList-为什么不能实现-RandomAccess-接口？" class="headerlink" title="– RandomAccess 接口？LinkedList 为什么不能实现 RandomAccess 接口？"></a>– RandomAccess 接口？LinkedList 为什么不能实现 RandomAccess 接口？</h4><p>★<code>RandomAccess</code> 是一个<strong>标记接口</strong>，用来<strong>表明实现该接口的类支持随机访问（即可以通过索引快速访问元素）</strong>。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</p>
<p>在 <code>binarySearch（)</code> 方法中，它要判断传入的 list 是否 <code>RandomAccess</code> 的实例，如果是，调用<code>indexedBinarySearch()</code>方法，如果不是，那么调用<code>iteratorBinarySearch()</code>方法</p>
<p><code>LinkedList</code> 底层数据结构是链表，内存地址不连续，<strong>只能通过指针来定位</strong>，<strong>不支持随机快速访问</strong>，所以不能实现 <code>RandomAccess</code> 接口。</p>
<h4 id="–-ArrayList-与-LinkedList-区别"><a href="#–-ArrayList-与-LinkedList-区别" class="headerlink" title="– ArrayList 与 LinkedList 区别?"></a>– ArrayList 与 LinkedList 区别?</h4><ul>
<li><p><strong>是否保证线程安全</strong>：<code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也<strong>就</strong>是<strong>不保证线程安全</strong>；</p>
</li>
<li><p><strong>底层数据结构</strong>：<code>ArrayList</code> 底层使用的是 <code>Object</code> <strong>数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。）</p>
</li>
<li><p><strong>插入和删除是否受元素位置的影响：</strong></p>
<p><code>ArrayList</code> 采用<strong>数组存储</strong>，插入和删除元素的时间复杂度受元素位置的影响；</p>
<p><code>add(E e)</code>方法， <code>ArrayList</code> 会默认追加到列表的末尾。</p>
<p><code>LinkedList</code> 采用<strong>链表存储</strong>，在<strong>头尾插入或者删除元素</strong>不受元素位置的影响<code>LinkedList</code> 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响。<strong>指定位置</strong>需要先移动到指定位置再插入和删除。</p>
</li>
<li><p><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code>（实现了 <code>RandomAccess</code> 接口） 支持。</p>
</li>
<li><p><strong>内存空间占用：</strong> <code>ArrayList</code> 的空间浪费主要体现在在 list 列表的结尾会<strong>预留</strong>一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p>
</li>
</ul>
<h4 id="–-双向链表和双向循环链表"><a href="#–-双向链表和双向循环链表" class="headerlink" title="– 双向链表和双向循环链表"></a>– 双向链表和双向循环链表</h4><ul>
<li><strong>双向链表：</strong> 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。</li>
<li><strong>双向循环链表：</strong> 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。</li>
</ul>
<h4 id="–-说一说-ArrayList-的扩容机制吧"><a href="#–-说一说-ArrayList-的扩容机制吧" class="headerlink" title="– 说一说 ArrayList 的扩容机制吧"></a>– 说一说 ArrayList 的扩容机制吧</h4><h3 id="【Set】"><a href="#【Set】" class="headerlink" title="【Set】"></a>【Set】</h3><h4 id="–-Comparable-和-Comparator-的区别"><a href="#–-Comparable-和-Comparator-的区别" class="headerlink" title="– Comparable 和 Comparator 的区别"></a>– Comparable 和 Comparator 的区别</h4><p>都是 Java 中用于排序的接口。</p>
<p>需要对一个集合使用自定义排序时，我们就要重写<code>compareTo()</code>方法或<code>compare()</code>方法。</p>
<p>需要对某一个集合实现两种排序方式时，可以重写compareTo()方法和使用自制的Comparator方法或者以两个 Comparator 来实现。</p>
<ul>
<li><code>Comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li>
<li><code>Comparator</code>接口实际上是出自 <code>java.util</code> 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序。<code>Comparator</code> <strong>定制排序</strong>。</li>
</ul>
<h4 id="–-无序性和不可重复性的含义是什么"><a href="#–-无序性和不可重复性的含义是什么" class="headerlink" title="– 无序性和不可重复性的含义是什么"></a>– 无序性和不可重复性的含义是什么</h4><ul>
<li><strong>无序性</strong>不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的<strong>顺序</strong>添加 ，而是根据数据的哈希值决定的。</li>
<li><strong>不可重复性</strong>是指添加的元素按照 <code>equals()</code> 判断时 ，返回 false，需要同时重写 <code>equals()</code> 方法和 <code>hashCode()</code> 方法。</li>
</ul>
<h4 id="–-比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#–-比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="– 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>– 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h4><ul>
<li>都是 <code>Set</code> 接口的实现类，都能保证<strong>元素唯一</strong>，并且都<strong>不</strong>是<strong>线程安全</strong>的。</li>
<li><strong>底层数据结构：</strong><code>HashSet</code> 的底层数据结构是<strong>哈希表</strong>（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是<strong>链表和哈希表</strong>，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是<strong>红黑树</strong>，元素是有序的，排序的方式有<strong>自然排序</strong>和<strong>定制排序</strong>。</li>
<li><strong>应用场景：</strong><code>HashSet</code> <strong>不</strong>能保证元素插入和取出的<strong>有序</strong>，<code>LinkedHashSet</code> 用于保证元素的插入和取出<strong>顺序</strong>满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素<strong>自定义排序规则</strong>的场景。</li>
</ul>
<h3 id="【Queue】"><a href="#【Queue】" class="headerlink" title="【Queue】"></a>【Queue】</h3><h4 id="–-Queue-与-Deque-的区别"><a href="#–-Queue-与-Deque-的区别" class="headerlink" title="– Queue 与 Deque 的区别"></a>– Queue 与 Deque 的区别</h4><ul>
<li><p><code>Queue</code> 是单端队列，只能从<strong>一端插</strong>入元素，<strong>另一端删除</strong>元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p>
<p> 扩展了 <code>Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p>
</li>
<li><p><code>Deque</code> 是双端队列，扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法</p>
<p>同样根据失败后处理方式的不同分为两类。事实上，Deque 还提供有 push() 和 pop() 等其他方法，可用于模拟栈。</p>
</li>
</ul>
<h4 id="–-ArrayDeque-与-LinkedList-的区别"><a href="#–-ArrayDeque-与-LinkedList-的区别" class="headerlink" title="– ArrayDeque 与 LinkedList 的区别"></a>– ArrayDeque 与 LinkedList 的区别</h4><p>都实现了 <code>Deque</code> 接口，两者都具有队列的功能。</p>
<ul>
<li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li>
<li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li>
<li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li>
<li>从<strong>性能</strong>的角度上，选用 <code>ArrayDeque</code> 来实现队列更好。<code>ArrayDeque</code> 也可以用于实现栈。</li>
</ul>
<h3 id="【Map】"><a href="#【Map】" class="headerlink" title="【Map】"></a>【Map】</h3><h4 id="–-HashMap-和-Hashtable-的区别"><a href="#–-HashMap-和-Hashtable-的区别" class="headerlink" title="– HashMap 和 Hashtable 的区别"></a>– HashMap 和 Hashtable 的区别</h4><ul>
<li><p><strong>线程是否安全：</strong><code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</p>
</li>
<li><p><code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰；</p>
</li>
<li><p><code>HashMap</code>的key可以存储1个null，value可以有多个； Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</p>
</li>
<li><p><strong>初始容量大小和每次扩充容量大小的不同</strong>：</p>
<ul>
<li><p><code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1</p>
</li>
<li><p>创建时如果给定了容量初始值，那么 <code>Hashtable</code> 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <strong><code>HashMap</code> 总是使用 2 的幂作为哈希表的大小</strong>,后面会介绍到为什么是 2 的幂次方。</p>
</li>
</ul>
</li>
<li><p><strong>底层数据结构</strong></p>
<p><code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间。<code>Hashtable</code> 没有这样的机制。</p>
</li>
</ul>
<h4 id="–-HashMap-和-HashSet-区别"><a href="#–-HashMap-和-HashSet-区别" class="headerlink" title="– HashMap 和 HashSet 区别"></a>– HashMap 和 HashSet 区别</h4><p><code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。</p>
<ul>
<li><code>HashMap</code>实现了 <code>Map</code> 接口，存储键值对，调用 <code>put()</code>向 map 中添加元素，HashMap<code>使用键（Key）计算</code>hashcode。</li>
<li><code>HashSet</code>实现 <code>Set</code> 接口，仅存储对象，调用 <code>add()</code>方法向 <code>Set</code> 中添加元素，使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</li>
</ul>
<h4 id="–-HashMap-和-TreeMap-区别"><a href="#–-HashMap-和-TreeMap-区别" class="headerlink" title="– HashMap 和 TreeMap 区别"></a>– HashMap 和 TreeMap 区别</h4><p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p>
<ul>
<li>相比于<code>HashMap</code>来说 <code>TreeMap</code> 主要多了对集合中的元素根据键<strong>排序</strong>的能力以及<strong>对集合内元素的搜索</strong>的能力。</li>
</ul>
<h4 id="–-HashSet-如何检查重复-★"><a href="#–-HashSet-如何检查重复-★" class="headerlink" title="– HashSet 如何检查重复? ★"></a>– HashSet 如何检查重复? ★</h4><p>对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p>
<h4 id="–-HashMap-的底层实现-★"><a href="#–-HashMap-的底层实现-★" class="headerlink" title="– HashMap 的底层实现 ★"></a>– HashMap 的底层实现 ★</h4><ul>
<li><p><strong>JDK1.8 之前</strong> <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 <code>hashcode</code> 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>
</li>
<li><p>所谓扰动函数指的就是 HashMap 的 <code>hash</code> 方法。使用 <code>hash</code> 方法也就是扰动函数是为了防止一些实现比较差的 <code>hashCode()</code> 方法 换句话说使用扰动函数之后可以减少碰撞。</p>
</li>
<li><p><strong>JDK1.8 之后</strong>在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
</li>
<li><p><strong>拉链法”</strong> ：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
</li>
</ul>
<h4 id="–-HashMap-的长度为什么是-2-的幂次方"><a href="#–-HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="– HashMap 的长度为什么是 2 的幂次方"></a>– HashMap 的长度为什么是 2 的幂次方</h4><p>为了<strong>加快哈希计算</strong>以及<strong>减少哈希冲突</strong>。</p>
<p><strong>“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。”</strong> 并且 <strong>采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。</strong></p>
<h4 id="–-HashMap-多线程操作导致死循环问题"><a href="#–-HashMap-多线程操作导致死循环问题" class="headerlink" title="– HashMap 多线程操作导致死循环问题"></a>– HashMap 多线程操作导致死循环问题</h4><p>JDK1.7 及之前版本的 <code>HashMap</code> 在多线程环境下<strong>扩容操作</strong>可能存在死循环问题，这是由于当一个桶位中有多个元素需要进行扩容时，多个线程同时<strong>对链表进行操作</strong>，<strong>头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束</strong>。</p>
<p>JDK1.8 版本的 <code>HashMap</code> 采用了<strong>尾插法</strong>而不是头插法来避免链表倒置，使得<strong>插入的节点永远都是放在链表的末尾，避免了链表中的环形结构</strong>。</p>
<p>并发环境下，推荐使用 <code>ConcurrentHashMap</code> 。</p>
<h4 id="–-HashMap-为什么线程不安全？"><a href="#–-HashMap-为什么线程不安全？" class="headerlink" title="– HashMap 为什么线程不安全？"></a>– HashMap 为什么线程不安全？</h4><p>JDK1.7 及之前版本，在多线程环境下，<code>HashMap</code> 扩容时会造成死循环和数据丢失的问题。</p>
<p>JDK 1.8 后，在 <code>HashMap</code> 中，多个键值对可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。多个线程对 <code>HashMap</code> 的 <code>put</code> 操作会导致线程不安全，具体来说会有数据覆盖的风险。</p>
<h4 id="–-HashMap-常见的遍历方式"><a href="#–-HashMap-常见的遍历方式" class="headerlink" title="– HashMap 常见的遍历方式?"></a>– HashMap 常见的遍历方式?</h4><p><strong>存在阻塞时 parallelStream 性能最高, 非阻塞时 parallelStream 性能最低</strong> 。</p>
<h4 id="–-ConcurrentHashMap-和-Hashtable-的区别"><a href="#–-ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="– ConcurrentHashMap 和 Hashtable 的区别"></a>– ConcurrentHashMap 和 Hashtable 的区别</h4><p>区别主要体现在<strong>实现线程安全的方式</strong>上不同。</p>
<ul>
<li><p><strong>底层数据结构：</strong></p>
<ul>
<li><code>ConcurrentHashMap</code>，JDK1.7采用分段的数组+链表，JDK1.8采用数组+链表&#x2F;红黑二叉树。</li>
<li><code>Hashtable</code>，<strong>数组+链表</strong></li>
</ul>
</li>
<li><p><strong>实现线程安全的方式（重要）：</strong></p>
<ul>
<li>JDK1.7，<code>ConcurrentHashMap</code>对整个桶数组进行了分割分段(<code>Segment</code>，<strong>分段锁</strong>)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</li>
<li>JDK1.8，<code>ConcurrentHashMap</code> 直接用 <code>Node</code> 数组+链表+红黑树的数据结构，并发控制使用 <code>synchronized</code> 和 <strong>CAS</strong> 来操作。（JDK1.6 以后 <code>synchronized</code> 锁做了很多优化） 存在旧的东西就是为了<strong>向下兼容</strong>版本。</li>
<li><strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。</li>
</ul>
</li>
</ul>
<h4 id="–-ConcurrentHashMap-线程安全的具体实现方式-底层具体实现"><a href="#–-ConcurrentHashMap-线程安全的具体实现方式-底层具体实现" class="headerlink" title="– ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现"></a>– ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现</h4><h4 id="–-JDK-1-7-和-JDK-1-8-的-ConcurrentHashMap-实现有什么不同？"><a href="#–-JDK-1-7-和-JDK-1-8-的-ConcurrentHashMap-实现有什么不同？" class="headerlink" title="– JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？"></a>– JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？</h4><ul>
<li><strong>线程安全实现方式</strong>：JDK 1.7 ， <code>Segment</code> 分段锁， <code>Segment</code> 继承自 <code>ReentrantLock</code>。JDK1.8 ，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</li>
<li><strong>Hash 碰撞解决方法</strong> : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树</li>
<li><strong>并发度</strong>：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</li>
</ul>
<h4 id="–-ConcurrentHashMap-为什么-key-和-value-不能为-null？"><a href="#–-ConcurrentHashMap-为什么-key-和-value-不能为-null？" class="headerlink" title="– ConcurrentHashMap 为什么 key 和 value 不能为 null？"></a>– ConcurrentHashMap 为什么 key 和 value 不能为 null？</h4><p>避免二义性，</p>
<p>用 null 作为键，那么你就无法区分这个键是否存在于 <code>ConcurrentHashMap</code> 中，还是根本没有这个键。同样，</p>
<p>用 null 作为值，那么你就无法区分这个值是否是真正存储在 <code>ConcurrentHashMap</code> 中的，还是因为找不到对应的键而返回的。</p>
<h4 id="–-ConcurrentHashMap-能保证复合操作的原子性吗？"><a href="#–-ConcurrentHashMap-能保证复合操作的原子性吗？" class="headerlink" title="– ConcurrentHashMap 能保证复合操作的原子性吗？"></a>– ConcurrentHashMap 能保证复合操作的原子性吗？</h4><p>不一定！</p>
<ul>
<li><code>ConcurrentHashMap</code> 是线程安全的，可以保证多个线程同时对它进行读写操作时，不会出现数据不一致的情况和死循环问题。</li>
<li>复合操作是指由多个基本操作(如<code>put</code>、<code>get</code>、<code>remove</code>、<code>containsKey</code>等)组成的操作。这种操作在执行过程中可能会<strong>被其他线程打断</strong>，导致结果不符合预期。</li>
</ul>
<p><strong>那如何保证 <code>ConcurrentHashMap</code> 复合操作的原子性呢？</strong></p>
<p><code>ConcurrentHashMap</code> 提供了一些原子性的复合操作，如 <code>putIfAbsent</code>、<code>compute</code>、<code>computeIfAbsent</code> 、<code>computeIfPresent</code>、<code>merge</code>等。这些<strong>方法</strong>都可以接受一个函数作为参数，根据给定的 key 和 value 来计算一个新的 value，并且将其更新到 map 中。</p>
<h3 id="【Collections-工具类（不重要）】"><a href="#【Collections-工具类（不重要）】" class="headerlink" title="【Collections 工具类（不重要）】"></a>【Collections 工具类（不重要）】</h3><p><strong><code>Collections</code> 工具类常用方法</strong>:</p>
<ul>
<li>排序</li>
<li>查找,替换操作</li>
<li>同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)</li>
</ul>
<h3 id="【其他-注意项】"><a href="#【其他-注意项】" class="headerlink" title="【其他 注意项】"></a>【其他 注意项】</h3><h4 id="–-集合判空"><a href="#–-集合判空" class="headerlink" title="– 集合判空"></a>– 集合判空</h4><p>判断所有集合内部的元素是否为空，使用 <code>isEmpty()</code> 方法，而不是 <code>size()==0</code> 的方式。</p>
<p>这是因为 **isEmpty() 方法的可读性更好，并且时间复杂度为 O(1)**。</p>
<h4 id="–-集合转-Map"><a href="#–-集合转-Map" class="headerlink" title="– 集合转 Map"></a>– 集合转 Map</h4><p>在使用 <code>java.util.stream.Collectors</code> 类的 <code>toMap()</code> 方法转为 <code>Map</code> 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。</p>
<h4 id="–-集合遍历"><a href="#–-集合遍历" class="headerlink" title="– 集合遍历"></a>– 集合遍历</h4><p>不要在 <code>foreach</code> 循环里进行元素的 <code>remove/add</code> 操作。<code>remove</code> 元素请使用 <code>Iterator</code> 方式，如果并发操作，需要对 <code>Iterator</code> 对象加锁。</p>
<ul>
<li>foreach 语法底层其实还是依赖 <code>Iterator</code> 。不过， <code>remove/add</code> 操作直接调用的是集合自己的方法，而不是 <code>Iterator</code> 的 <code>remove/add</code>方法。这就导致 <code>Iterator</code> 莫名其妙地发现自己有元素被 <code>remove/add</code> ，然后，它就会抛出一个 <code>ConcurrentModificationException</code> 来提示用户发生了并发修改异常。这就是单线程状态下产生的 <strong>fail-fast 机制</strong>。</li>
<li><strong>fail-fast 机制</strong>：多个线程对 fail-fast 集合进行修改的时候，可能会抛出<code>ConcurrentModificationException</code>。 即使是单线程下也有可能会出现这种情况，上面已经提到过。</li>
</ul>
<h4 id="–-集合去重"><a href="#–-集合去重" class="headerlink" title="– 集合去重"></a>– 集合去重</h4><p>可以利用 <strong><code>Set</code></strong> 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 <code>List</code> 的 <code>contains()</code> 进行遍历去重或者判断包含操作。</p>
<h4 id="–-集合转数组"><a href="#–-集合转数组" class="headerlink" title="– 集合转数组"></a>– 集合转数组</h4><p>使用集合转数组的方法，必须使用集合的 <strong><code>toArray(T[] array)</code><strong>，</strong>传入的是类型完全一致、长度为 0 的空数组</strong>。</p>
<h4 id="–-数组转集合"><a href="#–-数组转集合" class="headerlink" title="– 数组转集合"></a>– 数组转集合</h4><p>使用工具类 <code>Arrays.asList()</code> 把数组转换成集合时，不能使用其修改集合相关的方法， 它的 <code>add/remove/clear</code> 方法会抛出 <code>UnsupportedOperationException</code> 异常。</p>
<ul>
<li><code>Arrays.asList()</code>是泛型方法，传递的数组必须是对象数组，而不是基本类型。</li>
<li>使用集合的修改方法: <code>add()</code>、<code>remove()</code>、<code>clear()</code>会抛出异常。</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">lyl_L-</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://sunrisel135.github.io/blog_lyl/2024/03/10/Java%E9%9D%A2%E8%AF%95-%E9%9B%86%E5%90%88/">https://sunrisel135.github.io/blog_lyl/2024/03/10/Java面试-集合/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">本文声明: </span><span class="post-copyright-info">内容均为个人总结，仅供个人参考！</span></div></div></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/blog_lyl/2024/03/10/Java%E9%9D%A2%E8%AF%95-IO/"><i class="fas fa-angle-left">&nbsp;</i><span>Java面试-IO</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/blog_lyl/2024/03/08/Java%E9%9D%A2%E8%AF%95-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span>Java面试-并发编程</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2024 By lyl_L-</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/blog_lyl/js/copy.js"></script><!--script(src=url)--></body></html>